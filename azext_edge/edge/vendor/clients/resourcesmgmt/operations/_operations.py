# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer
from .._vendor import _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_delete_at_scope_request(scope: str, deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_check_existence_at_scope_request(scope: str, deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="HEAD", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_create_or_update_at_scope_request(scope: str, deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_get_at_scope_request(scope: str, deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_cancel_at_scope_request(scope: str, deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_validate_at_scope_request(scope: str, deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_export_template_at_scope_request(scope: str, deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_list_at_scope_request(
    scope: str, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/deployments/"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_delete_at_tenant_scope_request(deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_check_existence_at_tenant_scope_request(deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="HEAD", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_create_or_update_at_tenant_scope_request(deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_get_at_tenant_scope_request(deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_cancel_at_tenant_scope_request(deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_validate_at_tenant_scope_request(deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_what_if_at_tenant_scope_request(deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_export_template_at_tenant_scope_request(deployment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_list_at_tenant_scope_request(
    *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/deployments/"

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_delete_at_management_group_scope_request(
    group_id: str, deployment_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_check_existence_at_management_group_scope_request(
    group_id: str, deployment_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="HEAD", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_create_or_update_at_management_group_scope_request(
    group_id: str, deployment_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_get_at_management_group_scope_request(
    group_id: str, deployment_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_cancel_at_management_group_scope_request(
    group_id: str, deployment_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"  # pylint: disable=line-too-long
    path_format_arguments = {
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_validate_at_management_group_scope_request(
    group_id: str, deployment_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"  # pylint: disable=line-too-long
    path_format_arguments = {
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_what_if_at_management_group_scope_request(
    group_id: str, deployment_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"  # pylint: disable=line-too-long
    path_format_arguments = {
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_export_template_at_management_group_scope_request(
    group_id: str, deployment_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"  # pylint: disable=line-too-long
    path_format_arguments = {
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_list_at_management_group_scope_request(
    group_id: str, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/"
    path_format_arguments = {
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_delete_at_subscription_scope_request(
    deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_check_existence_at_subscription_scope_request(
    deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="HEAD", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_create_or_update_at_subscription_scope_request(
    deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_get_at_subscription_scope_request(
    deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_cancel_at_subscription_scope_request(
    deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_validate_at_subscription_scope_request(
    deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_what_if_at_subscription_scope_request(
    deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_export_template_at_subscription_scope_request(
    deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_list_at_subscription_scope_request(
    subscription_id: str, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_delete_request(
    resource_group_name: str, deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_check_existence_request(
    resource_group_name: str, deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="HEAD", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_create_or_update_request(
    resource_group_name: str, deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_get_request(
    resource_group_name: str, deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_cancel_request(
    resource_group_name: str, deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_validate_request(
    resource_group_name: str, deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_what_if_request(
    resource_group_name: str, deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_export_template_request(
    resource_group_name: str, deployment_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_list_by_resource_group_request(
    resource_group_name: str,
    subscription_id: str,
    *,
    filter: Optional[str] = None,
    top: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/"
    )
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployments_calculate_template_hash_request(*, json: JSON, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/calculateTemplateHash"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_providers_unregister_request(
    resource_provider_namespace: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/{resourceProviderNamespace}/unregister"
    path_format_arguments = {
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_providers_register_at_management_group_scope_request(
    resource_provider_namespace: str, group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/{resourceProviderNamespace}/register"
    path_format_arguments = {
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_providers_provider_permissions_request(
    resource_provider_namespace: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/{resourceProviderNamespace}/providerPermissions"
    path_format_arguments = {
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_providers_register_request(
    resource_provider_namespace: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/{resourceProviderNamespace}/register"
    path_format_arguments = {
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_providers_list_request(subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_providers_list_at_tenant_scope_request(*, expand: Optional[str] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers"

    # Construct parameters
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_providers_get_request(
    resource_provider_namespace: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/{resourceProviderNamespace}"
    path_format_arguments = {
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_providers_get_at_tenant_scope_request(
    resource_provider_namespace: str, *, expand: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/{resourceProviderNamespace}"
    path_format_arguments = {
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_provider_resource_types_list_request(
    resource_provider_namespace: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/{resourceProviderNamespace}/resourceTypes"
    path_format_arguments = {
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_list_by_resource_group_request(
    resource_group_name: str,
    subscription_id: str,
    *,
    filter: Optional[str] = None,
    expand: Optional[str] = None,
    top: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/resources"
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_move_resources_request(
    source_resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/moveResources"
    path_format_arguments = {
        "sourceResourceGroupName": _SERIALIZER.url(
            "source_resource_group_name",
            source_resource_group_name,
            "str",
            max_length=90,
            min_length=1,
            pattern=r"^[-\w\._\(\)]+$",
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_validate_move_resources_request(
    source_resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{sourceResourceGroupName}/validateMoveResources"
    path_format_arguments = {
        "sourceResourceGroupName": _SERIALIZER.url(
            "source_resource_group_name",
            source_resource_group_name,
            "str",
            max_length=90,
            min_length=1,
            pattern=r"^[-\w\._\(\)]+$",
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_list_request(
    subscription_id: str,
    *,
    filter: Optional[str] = None,
    expand: Optional[str] = None,
    top: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resources"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_check_existence_request(
    resource_group_name: str,
    resource_provider_namespace: str,
    parent_resource_path: str,
    resource_type: str,
    resource_name: str,
    subscription_id: str,
    *,
    api_version: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
        "parentResourcePath": _SERIALIZER.url("parent_resource_path", parent_resource_path, "str", skip_quote=True),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str", skip_quote=True),
        "resourceName": _SERIALIZER.url("resource_name", resource_name, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="HEAD", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_delete_request(
    resource_group_name: str,
    resource_provider_namespace: str,
    parent_resource_path: str,
    resource_type: str,
    resource_name: str,
    subscription_id: str,
    *,
    api_version: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
        "parentResourcePath": _SERIALIZER.url("parent_resource_path", parent_resource_path, "str", skip_quote=True),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str", skip_quote=True),
        "resourceName": _SERIALIZER.url("resource_name", resource_name, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_create_or_update_request(
    resource_group_name: str,
    resource_provider_namespace: str,
    parent_resource_path: str,
    resource_type: str,
    resource_name: str,
    subscription_id: str,
    *,
    api_version: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
        "parentResourcePath": _SERIALIZER.url("parent_resource_path", parent_resource_path, "str", skip_quote=True),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str", skip_quote=True),
        "resourceName": _SERIALIZER.url("resource_name", resource_name, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_update_request(
    resource_group_name: str,
    resource_provider_namespace: str,
    parent_resource_path: str,
    resource_type: str,
    resource_name: str,
    subscription_id: str,
    *,
    api_version: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
        "parentResourcePath": _SERIALIZER.url("parent_resource_path", parent_resource_path, "str", skip_quote=True),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str", skip_quote=True),
        "resourceName": _SERIALIZER.url("resource_name", resource_name, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_get_request(
    resource_group_name: str,
    resource_provider_namespace: str,
    parent_resource_path: str,
    resource_type: str,
    resource_name: str,
    subscription_id: str,
    *,
    api_version: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
        "parentResourcePath": _SERIALIZER.url("parent_resource_path", parent_resource_path, "str", skip_quote=True),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str", skip_quote=True),
        "resourceName": _SERIALIZER.url("resource_name", resource_name, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_check_existence_by_id_request(resource_id: str, *, api_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceId}"
    path_format_arguments = {
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="HEAD", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_delete_by_id_request(resource_id: str, *, api_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceId}"
    path_format_arguments = {
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_create_or_update_by_id_request(resource_id: str, *, api_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceId}"
    path_format_arguments = {
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_update_by_id_request(resource_id: str, *, api_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceId}"
    path_format_arguments = {
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_resources_get_by_id_request(resource_id: str, *, api_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{resourceId}"
    path_format_arguments = {
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_groups_check_existence_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}"
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="HEAD", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_groups_create_or_update_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}"
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_groups_delete_request(
    resource_group_name: str, subscription_id: str, *, force_deletion_types: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}"
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if force_deletion_types is not None:
        _params["forceDeletionTypes"] = _SERIALIZER.query("force_deletion_types", force_deletion_types, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_groups_get_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}"
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_groups_update_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}"
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_groups_export_template_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/exportTemplate"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_groups_list_request(
    subscription_id: str, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tags_delete_value_request(tag_name: str, tag_value: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/tagNames/{tagName}/tagValues/{tagValue}"
    path_format_arguments = {
        "tagName": _SERIALIZER.url("tag_name", tag_name, "str"),
        "tagValue": _SERIALIZER.url("tag_value", tag_value, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_tags_create_or_update_value_request(
    tag_name: str, tag_value: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/tagNames/{tagName}/tagValues/{tagValue}"
    path_format_arguments = {
        "tagName": _SERIALIZER.url("tag_name", tag_name, "str"),
        "tagValue": _SERIALIZER.url("tag_value", tag_value, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_tags_create_or_update_request(tag_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/tagNames/{tagName}"
    path_format_arguments = {
        "tagName": _SERIALIZER.url("tag_name", tag_name, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_tags_delete_request(tag_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/tagNames/{tagName}"
    path_format_arguments = {
        "tagName": _SERIALIZER.url("tag_name", tag_name, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_tags_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/tagNames"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tags_create_or_update_at_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/tags/default"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_tags_update_at_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/tags/default"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_tags_get_at_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/tags/default"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tags_delete_at_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/tags/default"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_operations_get_at_scope_request(
    scope: str, deployment_name: str, operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/operations/{operationId}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_operations_list_at_scope_request(
    scope: str, deployment_name: str, *, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/operations"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_operations_get_at_tenant_scope_request(
    deployment_name: str, operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/deployments/{deploymentName}/operations/{operationId}"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_operations_list_at_tenant_scope_request(
    deployment_name: str, *, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Resources/deployments/{deploymentName}/operations"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_operations_get_at_management_group_scope_request(
    group_id: str, deployment_name: str, operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/operations/{operationId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_operations_list_at_management_group_scope_request(
    group_id: str, deployment_name: str, *, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/operations"  # pylint: disable=line-too-long
    path_format_arguments = {
        "groupId": _SERIALIZER.url("group_id", group_id, "str", max_length=90, min_length=1),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_operations_get_at_subscription_scope_request(
    deployment_name: str, operation_id: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/operations/{operationId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_operations_list_at_subscription_scope_request(
    deployment_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/operations"
    path_format_arguments = {
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_operations_get_request(
    resource_group_name: str, deployment_name: str, operation_id: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/deployments/{deploymentName}/operations/{operationId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deployment_operations_list_request(
    resource_group_name: str, deployment_name: str, subscription_id: str, *, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-03-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/deployments/{deploymentName}/operations"
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "deploymentName": _SERIALIZER.url(
            "deployment_name", deployment_name, "str", max_length=64, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~resources.mgmt.ResourceManagementClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists all of the available Microsoft.Resources REST API operations.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "display": {
                        "description": "str",  # Optional. Description of the operation.
                        "operation": "str",  # Optional. Operation type: Read, write, delete,
                          etc.
                        "provider": "str",  # Optional. Service provider:
                          Microsoft.Resources.
                        "resource": "str"  # Optional. Resource on which the operation is
                          performed: Profile, endpoint, etc.
                    },
                    "name": "str"  # Optional. Operation name: {provider}/{resource}/{operation}.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class DeploymentsOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~resources.mgmt.ResourceManagementClient`'s
        :attr:`deployments` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _delete_at_scope_initial(  # pylint: disable=inconsistent-return-statements
        self, scope: str, deployment_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_delete_at_scope_request(
            scope=scope,
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_delete_at_scope(self, scope: str, deployment_name: str, **kwargs: Any) -> LROPoller[None]:
        """Deletes a deployment from the deployment history.

        A template deployment that is currently running cannot be deleted. Deleting a template
        deployment removes the associated deployment operations. This is an asynchronous operation that
        returns a status of 202 until the template deployment is successfully deleted. The Location
        response header contains the URI that is used to obtain the status of the process. While the
        process is running, a call to the URI in the Location header returns a status of 202. When the
        process finishes, the URI in the Location header returns a status of 204 on success. If the
        asynchronous request failed, the URI in the Location header returns an error-level status code.

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_at_scope_initial(  # type: ignore
                scope=scope,
                deployment_name=deployment_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def check_existence_at_scope(self, scope: str, deployment_name: str, **kwargs: Any) -> bool:
        """Checks whether the deployment exists.

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_check_existence_at_scope_request(
            scope=scope,
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
        return 200 <= response.status_code <= 299

    def _create_or_update_at_scope_initial(
        self, scope: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_create_or_update_at_scope_request(
            scope=scope,
            deployment_name=deployment_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update_at_scope(
        self,
        scope: str,
        deployment_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at a given scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """

    @overload
    def begin_create_or_update_at_scope(
        self, scope: str, deployment_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at a given scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """

    @distributed_trace
    def begin_create_or_update_at_scope(
        self, scope: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at a given scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Is either a JSON type or a
         IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_at_scope_initial(
                scope=scope,
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_at_scope(self, scope: str, deployment_name: str, **kwargs: Any) -> JSON:
        """Gets a deployment.

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployments_get_at_scope_request(
            scope=scope,
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def cancel_at_scope(  # pylint: disable=inconsistent-return-statements
        self, scope: str, deployment_name: str, **kwargs: Any
    ) -> None:
        """Cancels a currently running template deployment.

        You can cancel a deployment only if the provisioningState is Accepted or Running. After the
        deployment is canceled, the provisioningState is set to Canceled. Canceling a template
        deployment stops the currently running template deployment and leaves the resources partially
        deployed.

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_cancel_at_scope_request(
            scope=scope,
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    def _validate_at_scope_initial(
        self, scope: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_validate_at_scope_request(
            scope=scope,
            deployment_name=deployment_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 400:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def begin_validate_at_scope(
        self,
        scope: str,
        deployment_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """

    @overload
    def begin_validate_at_scope(
        self, scope: str, deployment_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """

    @distributed_trace
    def begin_validate_at_scope(
        self, scope: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._validate_at_scope_initial(
                scope=scope,
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def export_template_at_scope(self, scope: str, deployment_name: str, **kwargs: Any) -> JSON:
        """Exports the template used for specified deployment.

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "template": {}  # Optional. The template content.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployments_export_template_at_scope_request(
            scope=scope,
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_at_scope(
        self, scope: str, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Get all the deployments at the given scope.

        :param scope: The resource scope. Required.
        :type scope: str
        :keyword filter: The filter to apply on the operation. For example, you can use
         $filter=provisioningState eq '{state}'. Default value is None.
        :paramtype filter: str
        :keyword top: The number of results to get. If null is passed, returns all deployments. Default
         value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deployments_list_at_scope_request(
                    scope=scope,
                    filter=filter,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _delete_at_tenant_scope_initial(  # pylint: disable=inconsistent-return-statements
        self, deployment_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_delete_at_tenant_scope_request(
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_delete_at_tenant_scope(self, deployment_name: str, **kwargs: Any) -> LROPoller[None]:
        """Deletes a deployment from the deployment history.

        A template deployment that is currently running cannot be deleted. Deleting a template
        deployment removes the associated deployment operations. This is an asynchronous operation that
        returns a status of 202 until the template deployment is successfully deleted. The Location
        response header contains the URI that is used to obtain the status of the process. While the
        process is running, a call to the URI in the Location header returns a status of 202. When the
        process finishes, the URI in the Location header returns a status of 204 on success. If the
        asynchronous request failed, the URI in the Location header returns an error-level status code.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_at_tenant_scope_initial(  # type: ignore
                deployment_name=deployment_name, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def check_existence_at_tenant_scope(self, deployment_name: str, **kwargs: Any) -> bool:
        """Checks whether the deployment exists.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_check_existence_at_tenant_scope_request(
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
        return 200 <= response.status_code <= 299

    def _create_or_update_at_tenant_scope_initial(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_create_or_update_at_tenant_scope_request(
            deployment_name=deployment_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update_at_tenant_scope(
        self, deployment_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at tenant scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """

    @overload
    def begin_create_or_update_at_tenant_scope(
        self, deployment_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at tenant scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """

    @distributed_trace
    def begin_create_or_update_at_tenant_scope(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at tenant scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Is either a JSON type or a
         IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_at_tenant_scope_initial(
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_at_tenant_scope(self, deployment_name: str, **kwargs: Any) -> JSON:
        """Gets a deployment.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployments_get_at_tenant_scope_request(
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def cancel_at_tenant_scope(  # pylint: disable=inconsistent-return-statements
        self, deployment_name: str, **kwargs: Any
    ) -> None:
        """Cancels a currently running template deployment.

        You can cancel a deployment only if the provisioningState is Accepted or Running. After the
        deployment is canceled, the provisioningState is set to Canceled. Canceling a template
        deployment stops the currently running template deployment and leaves the resources partially
        deployed.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_cancel_at_tenant_scope_request(
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    def _validate_at_tenant_scope_initial(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_validate_at_tenant_scope_request(
            deployment_name=deployment_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 400:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def begin_validate_at_tenant_scope(
        self, deployment_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """

    @overload
    def begin_validate_at_tenant_scope(
        self, deployment_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """

    @distributed_trace
    def begin_validate_at_tenant_scope(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._validate_at_tenant_scope_initial(
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _what_if_at_tenant_scope_initial(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_what_if_at_tenant_scope_request(
            deployment_name=deployment_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("str", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_what_if_at_tenant_scope(
        self, deployment_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the tenant
        group.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "whatIfSettings": {
                            "resultFormat": "str"  # Optional. The format of the What-If
                              results. Known values are: "ResourceIdOnly" and "FullResourcePayloads".
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """

    @overload
    def begin_what_if_at_tenant_scope(
        self, deployment_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the tenant
        group.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """

    @distributed_trace
    def begin_what_if_at_tenant_scope(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the tenant
        group.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "whatIfSettings": {
                            "resultFormat": "str"  # Optional. The format of the What-If
                              results. Known values are: "ResourceIdOnly" and "FullResourcePayloads".
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._what_if_at_tenant_scope_initial(
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def export_template_at_tenant_scope(self, deployment_name: str, **kwargs: Any) -> JSON:
        """Exports the template used for specified deployment.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "template": {}  # Optional. The template content.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployments_export_template_at_tenant_scope_request(
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_at_tenant_scope(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Get all the deployments at the tenant scope.

        :keyword filter: The filter to apply on the operation. For example, you can use
         $filter=provisioningState eq '{state}'. Default value is None.
        :paramtype filter: str
        :keyword top: The number of results to get. If null is passed, returns all deployments. Default
         value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deployments_list_at_tenant_scope_request(
                    filter=filter,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _delete_at_management_group_scope_initial(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, deployment_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_delete_at_management_group_scope_request(
            group_id=group_id,
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_delete_at_management_group_scope(
        self, group_id: str, deployment_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes a deployment from the deployment history.

        A template deployment that is currently running cannot be deleted. Deleting a template
        deployment removes the associated deployment operations. This is an asynchronous operation that
        returns a status of 202 until the template deployment is successfully deleted. The Location
        response header contains the URI that is used to obtain the status of the process. While the
        process is running, a call to the URI in the Location header returns a status of 202. When the
        process finishes, the URI in the Location header returns a status of 204 on success. If the
        asynchronous request failed, the URI in the Location header returns an error-level status code.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_at_management_group_scope_initial(  # type: ignore
                group_id=group_id,
                deployment_name=deployment_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def check_existence_at_management_group_scope(self, group_id: str, deployment_name: str, **kwargs: Any) -> bool:
        """Checks whether the deployment exists.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_check_existence_at_management_group_scope_request(
            group_id=group_id,
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
        return 200 <= response.status_code <= 299

    def _create_or_update_at_management_group_scope_initial(
        self, group_id: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_create_or_update_at_management_group_scope_request(
            group_id=group_id,
            deployment_name=deployment_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update_at_management_group_scope(
        self,
        group_id: str,
        deployment_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at management group scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """

    @overload
    def begin_create_or_update_at_management_group_scope(
        self,
        group_id: str,
        deployment_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at management group scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """

    @distributed_trace
    def begin_create_or_update_at_management_group_scope(
        self, group_id: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at management group scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Is either a JSON type or a
         IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_at_management_group_scope_initial(
                group_id=group_id,
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_at_management_group_scope(self, group_id: str, deployment_name: str, **kwargs: Any) -> JSON:
        """Gets a deployment.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployments_get_at_management_group_scope_request(
            group_id=group_id,
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def cancel_at_management_group_scope(  # pylint: disable=inconsistent-return-statements
        self, group_id: str, deployment_name: str, **kwargs: Any
    ) -> None:
        """Cancels a currently running template deployment.

        You can cancel a deployment only if the provisioningState is Accepted or Running. After the
        deployment is canceled, the provisioningState is set to Canceled. Canceling a template
        deployment stops the currently running template deployment and leaves the resources partially
        deployed.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_cancel_at_management_group_scope_request(
            group_id=group_id,
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    def _validate_at_management_group_scope_initial(
        self, group_id: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_validate_at_management_group_scope_request(
            group_id=group_id,
            deployment_name=deployment_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 400:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def begin_validate_at_management_group_scope(
        self,
        group_id: str,
        deployment_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """

    @overload
    def begin_validate_at_management_group_scope(
        self,
        group_id: str,
        deployment_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """

    @distributed_trace
    def begin_validate_at_management_group_scope(
        self, group_id: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._validate_at_management_group_scope_initial(
                group_id=group_id,
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _what_if_at_management_group_scope_initial(
        self, group_id: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_what_if_at_management_group_scope_request(
            group_id=group_id,
            deployment_name=deployment_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("str", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_what_if_at_management_group_scope(
        self,
        group_id: str,
        deployment_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the management
        group.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "whatIfSettings": {
                            "resultFormat": "str"  # Optional. The format of the What-If
                              results. Known values are: "ResourceIdOnly" and "FullResourcePayloads".
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """

    @overload
    def begin_what_if_at_management_group_scope(
        self,
        group_id: str,
        deployment_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the management
        group.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """

    @distributed_trace
    def begin_what_if_at_management_group_scope(
        self, group_id: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the management
        group.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location to store the deployment data. Required.
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "whatIfSettings": {
                            "resultFormat": "str"  # Optional. The format of the What-If
                              results. Known values are: "ResourceIdOnly" and "FullResourcePayloads".
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._what_if_at_management_group_scope_initial(
                group_id=group_id,
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def export_template_at_management_group_scope(self, group_id: str, deployment_name: str, **kwargs: Any) -> JSON:
        """Exports the template used for specified deployment.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "template": {}  # Optional. The template content.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployments_export_template_at_management_group_scope_request(
            group_id=group_id,
            deployment_name=deployment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_at_management_group_scope(
        self, group_id: str, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Get all the deployments for a management group.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :keyword filter: The filter to apply on the operation. For example, you can use
         $filter=provisioningState eq '{state}'. Default value is None.
        :paramtype filter: str
        :keyword top: The number of results to get. If null is passed, returns all deployments. Default
         value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deployments_list_at_management_group_scope_request(
                    group_id=group_id,
                    filter=filter,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _delete_at_subscription_scope_initial(  # pylint: disable=inconsistent-return-statements
        self, deployment_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_delete_at_subscription_scope_request(
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_delete_at_subscription_scope(self, deployment_name: str, **kwargs: Any) -> LROPoller[None]:
        """Deletes a deployment from the deployment history.

        A template deployment that is currently running cannot be deleted. Deleting a template
        deployment removes the associated deployment operations. This is an asynchronous operation that
        returns a status of 202 until the template deployment is successfully deleted. The Location
        response header contains the URI that is used to obtain the status of the process. While the
        process is running, a call to the URI in the Location header returns a status of 202. When the
        process finishes, the URI in the Location header returns a status of 204 on success. If the
        asynchronous request failed, the URI in the Location header returns an error-level status code.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_at_subscription_scope_initial(  # type: ignore
                deployment_name=deployment_name, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def check_existence_at_subscription_scope(self, deployment_name: str, **kwargs: Any) -> bool:
        """Checks whether the deployment exists.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_check_existence_at_subscription_scope_request(
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
        return 200 <= response.status_code <= 299

    def _create_or_update_at_subscription_scope_initial(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_create_or_update_at_subscription_scope_request(
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update_at_subscription_scope(
        self, deployment_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at subscription scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """

    @overload
    def begin_create_or_update_at_subscription_scope(
        self, deployment_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at subscription scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """

    @distributed_trace
    def begin_create_or_update_at_subscription_scope(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources at subscription scope.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Is either a JSON type or a
         IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_at_subscription_scope_initial(
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_at_subscription_scope(self, deployment_name: str, **kwargs: Any) -> JSON:
        """Gets a deployment.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployments_get_at_subscription_scope_request(
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def cancel_at_subscription_scope(  # pylint: disable=inconsistent-return-statements
        self, deployment_name: str, **kwargs: Any
    ) -> None:
        """Cancels a currently running template deployment.

        You can cancel a deployment only if the provisioningState is Accepted or Running. After the
        deployment is canceled, the provisioningState is set to Canceled. Canceling a template
        deployment stops the currently running template deployment and leaves the resources partially
        deployed.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_cancel_at_subscription_scope_request(
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    def _validate_at_subscription_scope_initial(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_validate_at_subscription_scope_request(
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 400:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def begin_validate_at_subscription_scope(
        self, deployment_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """

    @overload
    def begin_validate_at_subscription_scope(
        self, deployment_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """

    @distributed_trace
    def begin_validate_at_subscription_scope(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._validate_at_subscription_scope_initial(
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _what_if_at_subscription_scope_initial(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_what_if_at_subscription_scope_request(
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("str", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_what_if_at_subscription_scope(
        self, deployment_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the
        subscription.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to What If. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "whatIfSettings": {
                            "resultFormat": "str"  # Optional. The format of the What-If
                              results. Known values are: "ResourceIdOnly" and "FullResourcePayloads".
                        }
                    },
                    "location": "str"  # Optional. The location to store the deployment data.
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """

    @overload
    def begin_what_if_at_subscription_scope(
        self, deployment_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the
        subscription.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to What If. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """

    @distributed_trace
    def begin_what_if_at_subscription_scope(
        self, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the
        subscription.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to What If. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "whatIfSettings": {
                            "resultFormat": "str"  # Optional. The format of the What-If
                              results. Known values are: "ResourceIdOnly" and "FullResourcePayloads".
                        }
                    },
                    "location": "str"  # Optional. The location to store the deployment data.
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._what_if_at_subscription_scope_initial(
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def export_template_at_subscription_scope(self, deployment_name: str, **kwargs: Any) -> JSON:
        """Exports the template used for specified deployment.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "template": {}  # Optional. The template content.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployments_export_template_at_subscription_scope_request(
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_at_subscription_scope(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Get all the deployments for a subscription.

        :keyword filter: The filter to apply on the operation. For example, you can use
         $filter=provisioningState eq '{state}'. Default value is None.
        :paramtype filter: str
        :keyword top: The number of results to get. If null is passed, returns all deployments. Default
         value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deployments_list_at_subscription_scope_request(
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, deployment_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_delete_request(
            resource_group_name=resource_group_name,
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_delete(self, resource_group_name: str, deployment_name: str, **kwargs: Any) -> LROPoller[None]:
        """Deletes a deployment from the deployment history.

        A template deployment that is currently running cannot be deleted. Deleting a template
        deployment removes the associated deployment operations. Deleting a template deployment does
        not affect the state of the resource group. This is an asynchronous operation that returns a
        status of 202 until the template deployment is successfully deleted. The Location response
        header contains the URI that is used to obtain the status of the process. While the process is
        running, a call to the URI in the Location header returns a status of 202. When the process
        finishes, the URI in the Location header returns a status of 204 on success. If the
        asynchronous request failed, the URI in the Location header returns an error-level status code.

        :param resource_group_name: The name of the resource group with the deployment to delete. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                deployment_name=deployment_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def check_existence(self, resource_group_name: str, deployment_name: str, **kwargs: Any) -> bool:
        """Checks whether the deployment exists.

        :param resource_group_name: The name of the resource group with the deployment to check. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_check_existence_request(
            resource_group_name=resource_group_name,
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
        return 200 <= response.status_code <= 299

    def _create_or_update_initial(
        self, resource_group_name: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_create_or_update_request(
            resource_group_name=resource_group_name,
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        deployment_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources to a resource group.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param resource_group_name: The name of the resource group to deploy the resources to. The name
         is case insensitive. The resource group must already exist. Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        deployment_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources to a resource group.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param resource_group_name: The name of the resource group to deploy the resources to. The name
         is case insensitive. The resource group must already exist. Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self, resource_group_name: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Deploys resources to a resource group.

        You can provide the template and parameters directly in the request or link to JSON files.

        :param resource_group_name: The name of the resource group to deploy the resources to. The name
         is case insensitive. The resource group must already exist. Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Additional parameters supplied to the operation. Is either a JSON type or a
         IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, resource_group_name: str, deployment_name: str, **kwargs: Any) -> JSON:
        """Gets a deployment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployments_get_request(
            resource_group_name=resource_group_name,
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def cancel(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, deployment_name: str, **kwargs: Any
    ) -> None:
        """Cancels a currently running template deployment.

        You can cancel a deployment only if the provisioningState is Accepted or Running. After the
        deployment is canceled, the provisioningState is set to Canceled. Canceling a template
        deployment stops the currently running template deployment and leaves the resource group
        partially deployed.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_deployments_cancel_request(
            resource_group_name=resource_group_name,
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    def _validate_initial(
        self, resource_group_name: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_validate_request(
            resource_group_name=resource_group_name,
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 400:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def begin_validate(
        self,
        resource_group_name: str,
        deployment_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param resource_group_name: The name of the resource group the template will be deployed to.
         The name is case insensitive. Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """

    @overload
    def begin_validate(
        self,
        resource_group_name: str,
        deployment_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param resource_group_name: The name of the resource group the template will be deployed to.
         The name is case insensitive. Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """

    @distributed_trace
    def begin_validate(
        self, resource_group_name: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Validates whether the specified template is syntactically correct and will be accepted by Azure
        Resource Manager..

        :param resource_group_name: The name of the resource group the template will be deployed to.
         The name is case insensitive. Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        }
                    },
                    "location": "str",  # Optional. The location to store the deployment data.
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    }
                }

                # response body for status code(s): 200, 400
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    }
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._validate_initial(
                resource_group_name=resource_group_name,
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _what_if_initial(
        self, resource_group_name: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_deployments_what_if_request(
            resource_group_name=resource_group_name,
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("str", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_what_if(
        self,
        resource_group_name: str,
        deployment_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the resource
        group.

        :param resource_group_name: The name of the resource group the template will be deployed to.
         The name is case insensitive. Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "whatIfSettings": {
                            "resultFormat": "str"  # Optional. The format of the What-If
                              results. Known values are: "ResourceIdOnly" and "FullResourcePayloads".
                        }
                    },
                    "location": "str"  # Optional. The location to store the deployment data.
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """

    @overload
    def begin_what_if(
        self,
        resource_group_name: str,
        deployment_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the resource
        group.

        :param resource_group_name: The name of the resource group the template will be deployed to.
         The name is case insensitive. Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """

    @distributed_trace
    def begin_what_if(
        self, resource_group_name: str, deployment_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Returns changes that will be made by the deployment if executed at the scope of the resource
        group.

        :param resource_group_name: The name of the resource group the template will be deployed to.
         The name is case insensitive. Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param parameters: Parameters to validate. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "mode": "str",  # The mode that is used to deploy resources. This
                          value can be either Incremental or Complete. In Incremental mode, resources
                          are deployed without deleting existing resources that are not included in the
                          template. In Complete mode, resources are deployed and existing resources in
                          the resource group that are not included in the template are deleted. Be
                          careful when using Complete mode as you may unintentionally delete resources.
                          Required. Known values are: "Incremental" and "Complete".
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "expressionEvaluationOptions": {
                            "scope": "str"  # Optional. The scope to be used for
                              evaluation of parameters, variables and functions in a nested template.
                              Known values are: "NotSpecified", "Outer", and "Inner".
                        },
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "parameters": {
                            "str": {
                                "reference": {
                                    "keyVault": {
                                        "id": "str"  # Azure Key Vault
                                          resource id. Required.
                                    },
                                    "secretName": "str",  # Azure Key Vault
                                      secret name. Required.
                                    "secretVersion": "str"  # Optional. Azure Key
                                      Vault secret version.
                                },
                                "value": {}  # Optional. Input value to the parameter
                                  .
                            }
                        },
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "template": {},  # Optional. The template content. You use this
                          element when you want to pass the template syntax directly in the request
                          rather than link to an existing template. It can be a JObject or well-formed
                          JSON string. Use either the templateLink property or the template property,
                          but not both.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "whatIfSettings": {
                            "resultFormat": "str"  # Optional. The format of the What-If
                              results. Known values are: "ResourceIdOnly" and "FullResourcePayloads".
                        }
                    },
                    "location": "str"  # Optional. The location to store the deployment data.
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "properties": {
                        "changes": [
                            {
                                "changeType": "str",  # Type of change that will be
                                  made to the resource when the deployment is executed. Required. Known
                                  values are: "Create", "Delete", "Ignore", "Deploy", "NoChange",
                                  "Modify", and "Unsupported".
                                "resourceId": "str",  # Resource ID. Required.
                                "after": {},  # Optional. The predicted snapshot of
                                  the resource after the deployment is executed.
                                "before": {},  # Optional. The snapshot of the
                                  resource before the deployment is executed.
                                "delta": [
                                    {
                                        "path": "str",  # The path of the
                                          property. Required.
                                        "propertyChangeType": "str",  # The
                                          type of property change. Required. Known values are:
                                          "Create", "Delete", "Modify", "Array", and "NoEffect".
                                        "after": {},  # Optional. The value
                                          of the property after the deployment is executed.
                                        "before": {},  # Optional. The value
                                          of the property before the deployment is executed.
                                        "children": [
                                            ...
                                        ]
                                    }
                                ],
                                "unsupportedReason": "str"  # Optional. The
                                  explanation about why the resource is unsupported by What-If.
                            }
                        ]
                    },
                    "status": "str"  # Optional. Status of the What-If operation.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._what_if_initial(
                resource_group_name=resource_group_name,
                deployment_name=deployment_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def export_template(self, resource_group_name: str, deployment_name: str, **kwargs: Any) -> JSON:
        """Exports the template used for specified deployment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "template": {}  # Optional. The template content.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployments_export_template_request(
            resource_group_name=resource_group_name,
            deployment_name=deployment_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_by_resource_group(
        self, resource_group_name: str, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Get all the deployments for a resource group.

        :param resource_group_name: The name of the resource group with the deployments to get. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :keyword filter: The filter to apply on the operation. For example, you can use
         $filter=provisioningState eq '{state}'. Default value is None.
        :paramtype filter: str
        :keyword top: The number of results to get. If null is passed, returns all deployments. Default
         value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The ID of the deployment.
                    "location": "str",  # Optional. the location of the deployment.
                    "name": "str",  # Optional. The name of the deployment.
                    "properties": {
                        "correlationId": "str",  # Optional. The correlation ID of the
                          deployment.
                        "debugSetting": {
                            "detailLevel": "str"  # Optional. Specifies the type of
                              information to log for debugging. The permitted values are none,
                              requestContent, responseContent, or both requestContent and
                              responseContent separated by a comma. The default is none. When setting
                              this value, carefully consider the type of information you are passing in
                              during deployment. By logging information about the request or response,
                              you could potentially expose sensitive data that is retrieved through the
                              deployment operations.
                        },
                        "dependencies": [
                            {
                                "dependsOn": [
                                    {
                                        "id": "str",  # Optional. The ID of
                                          the dependency.
                                        "resourceName": "str",  # Optional.
                                          The dependency resource name.
                                        "resourceType": "str"  # Optional.
                                          The dependency resource type.
                                    }
                                ],
                                "id": "str",  # Optional. The ID of the dependency.
                                "resourceName": "str",  # Optional. The dependency
                                  resource name.
                                "resourceType": "str"  # Optional. The dependency
                                  resource type.
                            }
                        ],
                        "duration": "str",  # Optional. The duration of the template
                          deployment.
                        "error": {
                            "additionalInfo": [
                                {
                                    "info": {},  # Optional. The additional info.
                                    "type": "str"  # Optional. The additional
                                      info type.
                                }
                            ],
                            "code": "str",  # Optional. The error code.
                            "details": [
                                ...
                            ],
                            "message": "str",  # Optional. The error message.
                            "target": "str"  # Optional. The error target.
                        },
                        "mode": "str",  # Optional. The deployment mode. Possible values are
                          Incremental and Complete. Known values are: "Incremental" and "Complete".
                        "onErrorDeployment": {
                            "deploymentName": "str",  # Optional. The deployment to be
                              used on error case.
                            "provisioningState": "str",  # Optional. The state of the
                              provisioning for the on error deployment.
                            "type": "str"  # Optional. The deployment on error behavior
                              type. Possible values are LastSuccessful and SpecificDeployment. Known
                              values are: "LastSuccessful" and "SpecificDeployment".
                        },
                        "outputResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ],
                        "outputs": {},  # Optional. Key/value pairs that represent deployment
                          output.
                        "parameters": {},  # Optional. Deployment parameters.
                        "parametersLink": {
                            "uri": "str",  # The URI of the parameters file. Required.
                            "contentVersion": "str"  # Optional. If included, must match
                              the ContentVersion in the template.
                        },
                        "providers": [
                            {
                                "id": "str",  # Optional. The provider ID.
                                "namespace": "str",  # Optional. The namespace of the
                                  resource provider.
                                "providerAuthorizationConsentState": "str",  #
                                  Optional. The provider authorization consent state. Known values are:
                                  "NotSpecified", "Required", "NotRequired", and "Consented".
                                "registrationPolicy": "str",  # Optional. The
                                  registration policy of the resource provider.
                                "registrationState": "str",  # Optional. The
                                  registration state of the resource provider.
                                "resourceTypes": [
                                    {
                                        "aliases": [
                                            {
                                                "defaultMetadata": {
                                                    "attributes":
                                                      "str",  # Optional. The attributes of the token
                                                      that the alias path is referring to. Known values
                                                      are: "None" and "Modifiable".
                                                    "type": "str"
                                                      # Optional. The type of the token that the alias
                                                      path is referring to. Known values are:
                                                      "NotSpecified", "Any", "String", "Object",
                                                      "Array", "Integer", "Number", and "Boolean".
                                                },
                                                "defaultPath": "str",
                                                  # Optional. The default path for an alias.
                                                "defaultPattern": {
                                                    "phrase":
                                                      "str",  # Optional. The alias pattern phrase.
                                                    "type":
                                                      "str",  # Optional. The type of alias pattern.
                                                      Known values are: "NotSpecified" and "Extract".
                                                    "variable":
                                                      "str"  # Optional. The alias pattern variable.
                                                },
                                                "name": "str",  #
                                                  Optional. The alias name.
                                                "paths": [
                                                    {
                "apiVersions": [
                "str"  # Optional. The API versions.
                                                        ],
                "metadata": {
                "attributes": "str",  # Optional. The
                                                              attributes of the token that the alias
                                                              path is referring to. Known values are:
                                                              "None" and "Modifiable".
                "type": "str"  # Optional. The type of
                                                              the token that the alias path is
                                                              referring to. Known values are:
                                                              "NotSpecified", "Any", "String",
                                                              "Object", "Array", "Integer", "Number",
                                                              and "Boolean".
                                                        },
                "path": "str",  # Optional. The path of an
                                                          alias.
                "pattern": {
                "phrase": "str",  # Optional. The alias
                                                              pattern phrase.
                "type": "str",  # Optional. The type of
                                                              alias pattern. Known values are:
                                                              "NotSpecified" and "Extract".
                "variable": "str"  # Optional. The alias
                                                              pattern variable.
                                                        }
                                                    }
                                                ],
                                                "type": "str"  #
                                                  Optional. The type of the alias. Known values are:
                                                  "NotSpecified", "PlainText", and "Mask".
                                            }
                                        ],
                                        "apiProfiles": [
                                            {
                                                "apiVersion": "str",
                                                  # Optional. The API version.
                                                "profileVersion":
                                                  "str"  # Optional. The profile version.
                                            }
                                        ],
                                        "apiVersions": [
                                            "str"  # Optional. The API
                                              version.
                                        ],
                                        "capabilities": "str",  # Optional.
                                          The additional capabilities offered by this resource type.
                                        "defaultApiVersion": "str",  #
                                          Optional. The default API version.
                                        "locationMappings": [
                                            {
                                                "extendedLocations":
                                                  [
                                                    "str"  #
                                                      Optional. The extended locations for the azure
                                                      location.
                                                ],
                                                "location": "str",  #
                                                  Optional. The azure location.
                                                "type": "str"  #
                                                  Optional. The extended location type.
                                            }
                                        ],
                                        "locations": [
                                            "str"  # Optional. The
                                              collection of locations where this resource type can be
                                              created.
                                        ],
                                        "properties": {
                                            "str": "str"  # Optional. The
                                              properties.
                                        },
                                        "resourceType": "str",  # Optional.
                                          The resource type.
                                        "zoneMappings": [
                                            {
                                                "location": "str",  #
                                                  Optional. The location of the zone mapping.
                                                "zones": [
                                                    "str"  #
                                                      Optional. The collection of provider resource
                                                      types.
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        "provisioningState": "str",  # Optional. Denotes the state of
                          provisioning. Known values are: "NotSpecified", "Accepted", "Running",
                          "Ready", "Creating", "Created", "Deleting", "Deleted", "Canceled", "Failed",
                          "Succeeded", and "Updating".
                        "templateHash": "str",  # Optional. The hash produced for the
                          template.
                        "templateLink": {
                            "contentVersion": "str",  # Optional. If included, must match
                              the ContentVersion in the template.
                            "id": "str",  # Optional. The resource id of a Template Spec.
                              Use either the id or uri property, but not both.
                            "queryString": "str",  # Optional. The query string (for
                              example, a SAS token) to be used with the templateLink URI.
                            "relativePath": "str",  # Optional. The relativePath property
                              can be used to deploy a linked template at a location relative to the
                              parent. If the parent template was linked with a TemplateSpec, this will
                              reference an artifact in the TemplateSpec.  If the parent was linked with
                              a URI, the child deployment will be a combination of the parent and
                              relativePath URIs.
                            "uri": "str"  # Optional. The URI of the template to deploy.
                              Use either the uri or id property, but not both.
                        },
                        "timestamp": "2020-02-20 00:00:00",  # Optional. The timestamp of the
                          template deployment.
                        "validatedResources": [
                            {
                                "id": "str"  # Optional. The fully qualified resource
                                  Id.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Deployment tags.
                    },
                    "type": "str"  # Optional. The type of the deployment.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deployments_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def calculate_template_hash(self, template: JSON, **kwargs: Any) -> JSON:
        """Calculate the hash of the given template.

        :param template: The template provided to calculate hash. Required.
        :type template: JSON
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "minifiedTemplate": "str",  # Optional. The minified template string.
                    "templateHash": "str"  # Optional. The template hash.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _json = template

        request = build_deployments_calculate_template_hash_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class ProvidersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~resources.mgmt.ResourceManagementClient`'s
        :attr:`providers` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def unregister(self, resource_provider_namespace: str, **kwargs: Any) -> JSON:
        """Unregisters a subscription from a resource provider.

        :param resource_provider_namespace: The namespace of the resource provider to unregister.
         Required.
        :type resource_provider_namespace: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The provider ID.
                    "namespace": "str",  # Optional. The namespace of the resource provider.
                    "providerAuthorizationConsentState": "str",  # Optional. The provider
                      authorization consent state. Known values are: "NotSpecified", "Required",
                      "NotRequired", and "Consented".
                    "registrationPolicy": "str",  # Optional. The registration policy of the
                      resource provider.
                    "registrationState": "str",  # Optional. The registration state of the
                      resource provider.
                    "resourceTypes": [
                        {
                            "aliases": [
                                {
                                    "defaultMetadata": {
                                        "attributes": "str",  # Optional. The
                                          attributes of the token that the alias path is referring to.
                                          Known values are: "None" and "Modifiable".
                                        "type": "str"  # Optional. The type
                                          of the token that the alias path is referring to. Known
                                          values are: "NotSpecified", "Any", "String", "Object",
                                          "Array", "Integer", "Number", and "Boolean".
                                    },
                                    "defaultPath": "str",  # Optional. The
                                      default path for an alias.
                                    "defaultPattern": {
                                        "phrase": "str",  # Optional. The
                                          alias pattern phrase.
                                        "type": "str",  # Optional. The type
                                          of alias pattern. Known values are: "NotSpecified" and
                                          "Extract".
                                        "variable": "str"  # Optional. The
                                          alias pattern variable.
                                    },
                                    "name": "str",  # Optional. The alias name.
                                    "paths": [
                                        {
                                            "apiVersions": [
                                                "str"  # Optional.
                                                  The API versions.
                                            ],
                                            "metadata": {
                                                "attributes": "str",
                                                  # Optional. The attributes of the token that the
                                                  alias path is referring to. Known values are: "None"
                                                  and "Modifiable".
                                                "type": "str"  #
                                                  Optional. The type of the token that the alias path
                                                  is referring to. Known values are: "NotSpecified",
                                                  "Any", "String", "Object", "Array", "Integer",
                                                  "Number", and "Boolean".
                                            },
                                            "path": "str",  # Optional.
                                              The path of an alias.
                                            "pattern": {
                                                "phrase": "str",  #
                                                  Optional. The alias pattern phrase.
                                                "type": "str",  #
                                                  Optional. The type of alias pattern. Known values
                                                  are: "NotSpecified" and "Extract".
                                                "variable": "str"  #
                                                  Optional. The alias pattern variable.
                                            }
                                        }
                                    ],
                                    "type": "str"  # Optional. The type of the
                                      alias. Known values are: "NotSpecified", "PlainText", and "Mask".
                                }
                            ],
                            "apiProfiles": [
                                {
                                    "apiVersion": "str",  # Optional. The API
                                      version.
                                    "profileVersion": "str"  # Optional. The
                                      profile version.
                                }
                            ],
                            "apiVersions": [
                                "str"  # Optional. The API version.
                            ],
                            "capabilities": "str",  # Optional. The additional
                              capabilities offered by this resource type.
                            "defaultApiVersion": "str",  # Optional. The default API
                              version.
                            "locationMappings": [
                                {
                                    "extendedLocations": [
                                        "str"  # Optional. The extended
                                          locations for the azure location.
                                    ],
                                    "location": "str",  # Optional. The azure
                                      location.
                                    "type": "str"  # Optional. The extended
                                      location type.
                                }
                            ],
                            "locations": [
                                "str"  # Optional. The collection of locations where
                                  this resource type can be created.
                            ],
                            "properties": {
                                "str": "str"  # Optional. The properties.
                            },
                            "resourceType": "str",  # Optional. The resource type.
                            "zoneMappings": [
                                {
                                    "location": "str",  # Optional. The location
                                      of the zone mapping.
                                    "zones": [
                                        "str"  # Optional. The collection of
                                          provider resource types.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_providers_unregister_request(
            resource_provider_namespace=resource_provider_namespace,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def register_at_management_group_scope(  # pylint: disable=inconsistent-return-statements
        self, resource_provider_namespace: str, group_id: str, **kwargs: Any
    ) -> None:
        """Registers a management group with a resource provider. Use this operation to register a
        resource provider with resource types that can be deployed at the management group scope. It
        does not recursively register subscriptions within the management group. Instead, you must
        register subscriptions individually.

        :param resource_provider_namespace: The namespace of the resource provider to register.
         Required.
        :type resource_provider_namespace: str
        :param group_id: The management group ID. Required.
        :type group_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_providers_register_at_management_group_scope_request(
            resource_provider_namespace=resource_provider_namespace,
            group_id=group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def provider_permissions(self, resource_provider_namespace: str, **kwargs: Any) -> JSON:
        """Get the provider permissions.

        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "nextLink": "str",  # Optional. The URL to use for getting the next set of
                      results.
                    "value": [
                        {
                            "applicationId": "str",  # Optional. The application id.
                            "managedByRoleDefinition": {
                                "id": "str",  # Optional. The role definition ID.
                                "isServiceRole": bool,  # Optional. If this is a
                                  service role.
                                "name": "str",  # Optional. The role definition name.
                                "permissions": [
                                    {
                                        "actions": [
                                            "str"  # Optional. Allowed
                                              actions.
                                        ],
                                        "dataActions": [
                                            "str"  # Optional. Allowed
                                              Data actions.
                                        ],
                                        "notActions": [
                                            "str"  # Optional. Denied
                                              actions.
                                        ],
                                        "notDataActions": [
                                            "str"  # Optional. Denied
                                              Data actions.
                                        ]
                                    }
                                ],
                                "scopes": [
                                    "str"  # Optional. Role definition assignable
                                      scopes.
                                ]
                            },
                            "providerAuthorizationConsentState": "str",  # Optional. The
                              provider authorization consent state. Known values are: "NotSpecified",
                              "Required", "NotRequired", and "Consented".
                            "roleDefinition": {
                                "id": "str",  # Optional. The role definition ID.
                                "isServiceRole": bool,  # Optional. If this is a
                                  service role.
                                "name": "str",  # Optional. The role definition name.
                                "permissions": [
                                    {
                                        "actions": [
                                            "str"  # Optional. Allowed
                                              actions.
                                        ],
                                        "dataActions": [
                                            "str"  # Optional. Allowed
                                              Data actions.
                                        ],
                                        "notActions": [
                                            "str"  # Optional. Denied
                                              actions.
                                        ],
                                        "notDataActions": [
                                            "str"  # Optional. Denied
                                              Data actions.
                                        ]
                                    }
                                ],
                                "scopes": [
                                    "str"  # Optional. Role definition assignable
                                      scopes.
                                ]
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_providers_provider_permissions_request(
            resource_provider_namespace=resource_provider_namespace,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def register(
        self,
        resource_provider_namespace: str,
        properties: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Registers a subscription with a resource provider.

        :param resource_provider_namespace: The namespace of the resource provider to register.
         Required.
        :type resource_provider_namespace: str
        :param properties: The third party consent for S2S. Default value is None.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "thirdPartyProviderConsent": {
                        "consentToAuthorization": bool  # Optional. A value indicating
                          whether authorization is consented or not.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The provider ID.
                    "namespace": "str",  # Optional. The namespace of the resource provider.
                    "providerAuthorizationConsentState": "str",  # Optional. The provider
                      authorization consent state. Known values are: "NotSpecified", "Required",
                      "NotRequired", and "Consented".
                    "registrationPolicy": "str",  # Optional. The registration policy of the
                      resource provider.
                    "registrationState": "str",  # Optional. The registration state of the
                      resource provider.
                    "resourceTypes": [
                        {
                            "aliases": [
                                {
                                    "defaultMetadata": {
                                        "attributes": "str",  # Optional. The
                                          attributes of the token that the alias path is referring to.
                                          Known values are: "None" and "Modifiable".
                                        "type": "str"  # Optional. The type
                                          of the token that the alias path is referring to. Known
                                          values are: "NotSpecified", "Any", "String", "Object",
                                          "Array", "Integer", "Number", and "Boolean".
                                    },
                                    "defaultPath": "str",  # Optional. The
                                      default path for an alias.
                                    "defaultPattern": {
                                        "phrase": "str",  # Optional. The
                                          alias pattern phrase.
                                        "type": "str",  # Optional. The type
                                          of alias pattern. Known values are: "NotSpecified" and
                                          "Extract".
                                        "variable": "str"  # Optional. The
                                          alias pattern variable.
                                    },
                                    "name": "str",  # Optional. The alias name.
                                    "paths": [
                                        {
                                            "apiVersions": [
                                                "str"  # Optional.
                                                  The API versions.
                                            ],
                                            "metadata": {
                                                "attributes": "str",
                                                  # Optional. The attributes of the token that the
                                                  alias path is referring to. Known values are: "None"
                                                  and "Modifiable".
                                                "type": "str"  #
                                                  Optional. The type of the token that the alias path
                                                  is referring to. Known values are: "NotSpecified",
                                                  "Any", "String", "Object", "Array", "Integer",
                                                  "Number", and "Boolean".
                                            },
                                            "path": "str",  # Optional.
                                              The path of an alias.
                                            "pattern": {
                                                "phrase": "str",  #
                                                  Optional. The alias pattern phrase.
                                                "type": "str",  #
                                                  Optional. The type of alias pattern. Known values
                                                  are: "NotSpecified" and "Extract".
                                                "variable": "str"  #
                                                  Optional. The alias pattern variable.
                                            }
                                        }
                                    ],
                                    "type": "str"  # Optional. The type of the
                                      alias. Known values are: "NotSpecified", "PlainText", and "Mask".
                                }
                            ],
                            "apiProfiles": [
                                {
                                    "apiVersion": "str",  # Optional. The API
                                      version.
                                    "profileVersion": "str"  # Optional. The
                                      profile version.
                                }
                            ],
                            "apiVersions": [
                                "str"  # Optional. The API version.
                            ],
                            "capabilities": "str",  # Optional. The additional
                              capabilities offered by this resource type.
                            "defaultApiVersion": "str",  # Optional. The default API
                              version.
                            "locationMappings": [
                                {
                                    "extendedLocations": [
                                        "str"  # Optional. The extended
                                          locations for the azure location.
                                    ],
                                    "location": "str",  # Optional. The azure
                                      location.
                                    "type": "str"  # Optional. The extended
                                      location type.
                                }
                            ],
                            "locations": [
                                "str"  # Optional. The collection of locations where
                                  this resource type can be created.
                            ],
                            "properties": {
                                "str": "str"  # Optional. The properties.
                            },
                            "resourceType": "str",  # Optional. The resource type.
                            "zoneMappings": [
                                {
                                    "location": "str",  # Optional. The location
                                      of the zone mapping.
                                    "zones": [
                                        "str"  # Optional. The collection of
                                          provider resource types.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """

    @overload
    def register(
        self,
        resource_provider_namespace: str,
        properties: Optional[IO] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Registers a subscription with a resource provider.

        :param resource_provider_namespace: The namespace of the resource provider to register.
         Required.
        :type resource_provider_namespace: str
        :param properties: The third party consent for S2S. Default value is None.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The provider ID.
                    "namespace": "str",  # Optional. The namespace of the resource provider.
                    "providerAuthorizationConsentState": "str",  # Optional. The provider
                      authorization consent state. Known values are: "NotSpecified", "Required",
                      "NotRequired", and "Consented".
                    "registrationPolicy": "str",  # Optional. The registration policy of the
                      resource provider.
                    "registrationState": "str",  # Optional. The registration state of the
                      resource provider.
                    "resourceTypes": [
                        {
                            "aliases": [
                                {
                                    "defaultMetadata": {
                                        "attributes": "str",  # Optional. The
                                          attributes of the token that the alias path is referring to.
                                          Known values are: "None" and "Modifiable".
                                        "type": "str"  # Optional. The type
                                          of the token that the alias path is referring to. Known
                                          values are: "NotSpecified", "Any", "String", "Object",
                                          "Array", "Integer", "Number", and "Boolean".
                                    },
                                    "defaultPath": "str",  # Optional. The
                                      default path for an alias.
                                    "defaultPattern": {
                                        "phrase": "str",  # Optional. The
                                          alias pattern phrase.
                                        "type": "str",  # Optional. The type
                                          of alias pattern. Known values are: "NotSpecified" and
                                          "Extract".
                                        "variable": "str"  # Optional. The
                                          alias pattern variable.
                                    },
                                    "name": "str",  # Optional. The alias name.
                                    "paths": [
                                        {
                                            "apiVersions": [
                                                "str"  # Optional.
                                                  The API versions.
                                            ],
                                            "metadata": {
                                                "attributes": "str",
                                                  # Optional. The attributes of the token that the
                                                  alias path is referring to. Known values are: "None"
                                                  and "Modifiable".
                                                "type": "str"  #
                                                  Optional. The type of the token that the alias path
                                                  is referring to. Known values are: "NotSpecified",
                                                  "Any", "String", "Object", "Array", "Integer",
                                                  "Number", and "Boolean".
                                            },
                                            "path": "str",  # Optional.
                                              The path of an alias.
                                            "pattern": {
                                                "phrase": "str",  #
                                                  Optional. The alias pattern phrase.
                                                "type": "str",  #
                                                  Optional. The type of alias pattern. Known values
                                                  are: "NotSpecified" and "Extract".
                                                "variable": "str"  #
                                                  Optional. The alias pattern variable.
                                            }
                                        }
                                    ],
                                    "type": "str"  # Optional. The type of the
                                      alias. Known values are: "NotSpecified", "PlainText", and "Mask".
                                }
                            ],
                            "apiProfiles": [
                                {
                                    "apiVersion": "str",  # Optional. The API
                                      version.
                                    "profileVersion": "str"  # Optional. The
                                      profile version.
                                }
                            ],
                            "apiVersions": [
                                "str"  # Optional. The API version.
                            ],
                            "capabilities": "str",  # Optional. The additional
                              capabilities offered by this resource type.
                            "defaultApiVersion": "str",  # Optional. The default API
                              version.
                            "locationMappings": [
                                {
                                    "extendedLocations": [
                                        "str"  # Optional. The extended
                                          locations for the azure location.
                                    ],
                                    "location": "str",  # Optional. The azure
                                      location.
                                    "type": "str"  # Optional. The extended
                                      location type.
                                }
                            ],
                            "locations": [
                                "str"  # Optional. The collection of locations where
                                  this resource type can be created.
                            ],
                            "properties": {
                                "str": "str"  # Optional. The properties.
                            },
                            "resourceType": "str",  # Optional. The resource type.
                            "zoneMappings": [
                                {
                                    "location": "str",  # Optional. The location
                                      of the zone mapping.
                                    "zones": [
                                        "str"  # Optional. The collection of
                                          provider resource types.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """

    @distributed_trace
    def register(
        self, resource_provider_namespace: str, properties: Optional[Union[JSON, IO]] = None, **kwargs: Any
    ) -> JSON:
        """Registers a subscription with a resource provider.

        :param resource_provider_namespace: The namespace of the resource provider to register.
         Required.
        :type resource_provider_namespace: str
        :param properties: The third party consent for S2S. Is either a JSON type or a IO type. Default
         value is None.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "thirdPartyProviderConsent": {
                        "consentToAuthorization": bool  # Optional. A value indicating
                          whether authorization is consented or not.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The provider ID.
                    "namespace": "str",  # Optional. The namespace of the resource provider.
                    "providerAuthorizationConsentState": "str",  # Optional. The provider
                      authorization consent state. Known values are: "NotSpecified", "Required",
                      "NotRequired", and "Consented".
                    "registrationPolicy": "str",  # Optional. The registration policy of the
                      resource provider.
                    "registrationState": "str",  # Optional. The registration state of the
                      resource provider.
                    "resourceTypes": [
                        {
                            "aliases": [
                                {
                                    "defaultMetadata": {
                                        "attributes": "str",  # Optional. The
                                          attributes of the token that the alias path is referring to.
                                          Known values are: "None" and "Modifiable".
                                        "type": "str"  # Optional. The type
                                          of the token that the alias path is referring to. Known
                                          values are: "NotSpecified", "Any", "String", "Object",
                                          "Array", "Integer", "Number", and "Boolean".
                                    },
                                    "defaultPath": "str",  # Optional. The
                                      default path for an alias.
                                    "defaultPattern": {
                                        "phrase": "str",  # Optional. The
                                          alias pattern phrase.
                                        "type": "str",  # Optional. The type
                                          of alias pattern. Known values are: "NotSpecified" and
                                          "Extract".
                                        "variable": "str"  # Optional. The
                                          alias pattern variable.
                                    },
                                    "name": "str",  # Optional. The alias name.
                                    "paths": [
                                        {
                                            "apiVersions": [
                                                "str"  # Optional.
                                                  The API versions.
                                            ],
                                            "metadata": {
                                                "attributes": "str",
                                                  # Optional. The attributes of the token that the
                                                  alias path is referring to. Known values are: "None"
                                                  and "Modifiable".
                                                "type": "str"  #
                                                  Optional. The type of the token that the alias path
                                                  is referring to. Known values are: "NotSpecified",
                                                  "Any", "String", "Object", "Array", "Integer",
                                                  "Number", and "Boolean".
                                            },
                                            "path": "str",  # Optional.
                                              The path of an alias.
                                            "pattern": {
                                                "phrase": "str",  #
                                                  Optional. The alias pattern phrase.
                                                "type": "str",  #
                                                  Optional. The type of alias pattern. Known values
                                                  are: "NotSpecified" and "Extract".
                                                "variable": "str"  #
                                                  Optional. The alias pattern variable.
                                            }
                                        }
                                    ],
                                    "type": "str"  # Optional. The type of the
                                      alias. Known values are: "NotSpecified", "PlainText", and "Mask".
                                }
                            ],
                            "apiProfiles": [
                                {
                                    "apiVersion": "str",  # Optional. The API
                                      version.
                                    "profileVersion": "str"  # Optional. The
                                      profile version.
                                }
                            ],
                            "apiVersions": [
                                "str"  # Optional. The API version.
                            ],
                            "capabilities": "str",  # Optional. The additional
                              capabilities offered by this resource type.
                            "defaultApiVersion": "str",  # Optional. The default API
                              version.
                            "locationMappings": [
                                {
                                    "extendedLocations": [
                                        "str"  # Optional. The extended
                                          locations for the azure location.
                                    ],
                                    "location": "str",  # Optional. The azure
                                      location.
                                    "type": "str"  # Optional. The extended
                                      location type.
                                }
                            ],
                            "locations": [
                                "str"  # Optional. The collection of locations where
                                  this resource type can be created.
                            ],
                            "properties": {
                                "str": "str"  # Optional. The properties.
                            },
                            "resourceType": "str",  # Optional. The resource type.
                            "zoneMappings": [
                                {
                                    "location": "str",  # Optional. The location
                                      of the zone mapping.
                                    "zones": [
                                        "str"  # Optional. The collection of
                                          provider resource types.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            if properties is not None:
                _json = properties
            else:
                _json = None

        request = build_providers_register_request(
            resource_provider_namespace=resource_provider_namespace,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list(self, *, expand: Optional[str] = None, **kwargs: Any) -> Iterable[JSON]:
        """Gets all resource providers for a subscription.

        :keyword expand: The properties to include in the results. For example, use &$expand=metadata
         in the query string to retrieve resource provider metadata. To include property aliases in
         response, use $expand=resourceTypes/aliases. Default value is None.
        :paramtype expand: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The provider ID.
                    "namespace": "str",  # Optional. The namespace of the resource provider.
                    "providerAuthorizationConsentState": "str",  # Optional. The provider
                      authorization consent state. Known values are: "NotSpecified", "Required",
                      "NotRequired", and "Consented".
                    "registrationPolicy": "str",  # Optional. The registration policy of the
                      resource provider.
                    "registrationState": "str",  # Optional. The registration state of the
                      resource provider.
                    "resourceTypes": [
                        {
                            "aliases": [
                                {
                                    "defaultMetadata": {
                                        "attributes": "str",  # Optional. The
                                          attributes of the token that the alias path is referring to.
                                          Known values are: "None" and "Modifiable".
                                        "type": "str"  # Optional. The type
                                          of the token that the alias path is referring to. Known
                                          values are: "NotSpecified", "Any", "String", "Object",
                                          "Array", "Integer", "Number", and "Boolean".
                                    },
                                    "defaultPath": "str",  # Optional. The
                                      default path for an alias.
                                    "defaultPattern": {
                                        "phrase": "str",  # Optional. The
                                          alias pattern phrase.
                                        "type": "str",  # Optional. The type
                                          of alias pattern. Known values are: "NotSpecified" and
                                          "Extract".
                                        "variable": "str"  # Optional. The
                                          alias pattern variable.
                                    },
                                    "name": "str",  # Optional. The alias name.
                                    "paths": [
                                        {
                                            "apiVersions": [
                                                "str"  # Optional.
                                                  The API versions.
                                            ],
                                            "metadata": {
                                                "attributes": "str",
                                                  # Optional. The attributes of the token that the
                                                  alias path is referring to. Known values are: "None"
                                                  and "Modifiable".
                                                "type": "str"  #
                                                  Optional. The type of the token that the alias path
                                                  is referring to. Known values are: "NotSpecified",
                                                  "Any", "String", "Object", "Array", "Integer",
                                                  "Number", and "Boolean".
                                            },
                                            "path": "str",  # Optional.
                                              The path of an alias.
                                            "pattern": {
                                                "phrase": "str",  #
                                                  Optional. The alias pattern phrase.
                                                "type": "str",  #
                                                  Optional. The type of alias pattern. Known values
                                                  are: "NotSpecified" and "Extract".
                                                "variable": "str"  #
                                                  Optional. The alias pattern variable.
                                            }
                                        }
                                    ],
                                    "type": "str"  # Optional. The type of the
                                      alias. Known values are: "NotSpecified", "PlainText", and "Mask".
                                }
                            ],
                            "apiProfiles": [
                                {
                                    "apiVersion": "str",  # Optional. The API
                                      version.
                                    "profileVersion": "str"  # Optional. The
                                      profile version.
                                }
                            ],
                            "apiVersions": [
                                "str"  # Optional. The API version.
                            ],
                            "capabilities": "str",  # Optional. The additional
                              capabilities offered by this resource type.
                            "defaultApiVersion": "str",  # Optional. The default API
                              version.
                            "locationMappings": [
                                {
                                    "extendedLocations": [
                                        "str"  # Optional. The extended
                                          locations for the azure location.
                                    ],
                                    "location": "str",  # Optional. The azure
                                      location.
                                    "type": "str"  # Optional. The extended
                                      location type.
                                }
                            ],
                            "locations": [
                                "str"  # Optional. The collection of locations where
                                  this resource type can be created.
                            ],
                            "properties": {
                                "str": "str"  # Optional. The properties.
                            },
                            "resourceType": "str",  # Optional. The resource type.
                            "zoneMappings": [
                                {
                                    "location": "str",  # Optional. The location
                                      of the zone mapping.
                                    "zones": [
                                        "str"  # Optional. The collection of
                                          provider resource types.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_providers_list_request(
                    subscription_id=self._config.subscription_id,
                    expand=expand,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_at_tenant_scope(self, *, expand: Optional[str] = None, **kwargs: Any) -> Iterable[JSON]:
        """Gets all resource providers for the tenant.

        :keyword expand: The properties to include in the results. For example, use &$expand=metadata
         in the query string to retrieve resource provider metadata. To include property aliases in
         response, use $expand=resourceTypes/aliases. Default value is None.
        :paramtype expand: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The provider ID.
                    "namespace": "str",  # Optional. The namespace of the resource provider.
                    "providerAuthorizationConsentState": "str",  # Optional. The provider
                      authorization consent state. Known values are: "NotSpecified", "Required",
                      "NotRequired", and "Consented".
                    "registrationPolicy": "str",  # Optional. The registration policy of the
                      resource provider.
                    "registrationState": "str",  # Optional. The registration state of the
                      resource provider.
                    "resourceTypes": [
                        {
                            "aliases": [
                                {
                                    "defaultMetadata": {
                                        "attributes": "str",  # Optional. The
                                          attributes of the token that the alias path is referring to.
                                          Known values are: "None" and "Modifiable".
                                        "type": "str"  # Optional. The type
                                          of the token that the alias path is referring to. Known
                                          values are: "NotSpecified", "Any", "String", "Object",
                                          "Array", "Integer", "Number", and "Boolean".
                                    },
                                    "defaultPath": "str",  # Optional. The
                                      default path for an alias.
                                    "defaultPattern": {
                                        "phrase": "str",  # Optional. The
                                          alias pattern phrase.
                                        "type": "str",  # Optional. The type
                                          of alias pattern. Known values are: "NotSpecified" and
                                          "Extract".
                                        "variable": "str"  # Optional. The
                                          alias pattern variable.
                                    },
                                    "name": "str",  # Optional. The alias name.
                                    "paths": [
                                        {
                                            "apiVersions": [
                                                "str"  # Optional.
                                                  The API versions.
                                            ],
                                            "metadata": {
                                                "attributes": "str",
                                                  # Optional. The attributes of the token that the
                                                  alias path is referring to. Known values are: "None"
                                                  and "Modifiable".
                                                "type": "str"  #
                                                  Optional. The type of the token that the alias path
                                                  is referring to. Known values are: "NotSpecified",
                                                  "Any", "String", "Object", "Array", "Integer",
                                                  "Number", and "Boolean".
                                            },
                                            "path": "str",  # Optional.
                                              The path of an alias.
                                            "pattern": {
                                                "phrase": "str",  #
                                                  Optional. The alias pattern phrase.
                                                "type": "str",  #
                                                  Optional. The type of alias pattern. Known values
                                                  are: "NotSpecified" and "Extract".
                                                "variable": "str"  #
                                                  Optional. The alias pattern variable.
                                            }
                                        }
                                    ],
                                    "type": "str"  # Optional. The type of the
                                      alias. Known values are: "NotSpecified", "PlainText", and "Mask".
                                }
                            ],
                            "apiProfiles": [
                                {
                                    "apiVersion": "str",  # Optional. The API
                                      version.
                                    "profileVersion": "str"  # Optional. The
                                      profile version.
                                }
                            ],
                            "apiVersions": [
                                "str"  # Optional. The API version.
                            ],
                            "capabilities": "str",  # Optional. The additional
                              capabilities offered by this resource type.
                            "defaultApiVersion": "str",  # Optional. The default API
                              version.
                            "locationMappings": [
                                {
                                    "extendedLocations": [
                                        "str"  # Optional. The extended
                                          locations for the azure location.
                                    ],
                                    "location": "str",  # Optional. The azure
                                      location.
                                    "type": "str"  # Optional. The extended
                                      location type.
                                }
                            ],
                            "locations": [
                                "str"  # Optional. The collection of locations where
                                  this resource type can be created.
                            ],
                            "properties": {
                                "str": "str"  # Optional. The properties.
                            },
                            "resourceType": "str",  # Optional. The resource type.
                            "zoneMappings": [
                                {
                                    "location": "str",  # Optional. The location
                                      of the zone mapping.
                                    "zones": [
                                        "str"  # Optional. The collection of
                                          provider resource types.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_providers_list_at_tenant_scope_request(
                    expand=expand,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_provider_namespace: str, *, expand: Optional[str] = None, **kwargs: Any) -> JSON:
        """Gets the specified resource provider.

        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :keyword expand: The $expand query parameter. For example, to include property aliases in
         response, use $expand=resourceTypes/aliases. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The provider ID.
                    "namespace": "str",  # Optional. The namespace of the resource provider.
                    "providerAuthorizationConsentState": "str",  # Optional. The provider
                      authorization consent state. Known values are: "NotSpecified", "Required",
                      "NotRequired", and "Consented".
                    "registrationPolicy": "str",  # Optional. The registration policy of the
                      resource provider.
                    "registrationState": "str",  # Optional. The registration state of the
                      resource provider.
                    "resourceTypes": [
                        {
                            "aliases": [
                                {
                                    "defaultMetadata": {
                                        "attributes": "str",  # Optional. The
                                          attributes of the token that the alias path is referring to.
                                          Known values are: "None" and "Modifiable".
                                        "type": "str"  # Optional. The type
                                          of the token that the alias path is referring to. Known
                                          values are: "NotSpecified", "Any", "String", "Object",
                                          "Array", "Integer", "Number", and "Boolean".
                                    },
                                    "defaultPath": "str",  # Optional. The
                                      default path for an alias.
                                    "defaultPattern": {
                                        "phrase": "str",  # Optional. The
                                          alias pattern phrase.
                                        "type": "str",  # Optional. The type
                                          of alias pattern. Known values are: "NotSpecified" and
                                          "Extract".
                                        "variable": "str"  # Optional. The
                                          alias pattern variable.
                                    },
                                    "name": "str",  # Optional. The alias name.
                                    "paths": [
                                        {
                                            "apiVersions": [
                                                "str"  # Optional.
                                                  The API versions.
                                            ],
                                            "metadata": {
                                                "attributes": "str",
                                                  # Optional. The attributes of the token that the
                                                  alias path is referring to. Known values are: "None"
                                                  and "Modifiable".
                                                "type": "str"  #
                                                  Optional. The type of the token that the alias path
                                                  is referring to. Known values are: "NotSpecified",
                                                  "Any", "String", "Object", "Array", "Integer",
                                                  "Number", and "Boolean".
                                            },
                                            "path": "str",  # Optional.
                                              The path of an alias.
                                            "pattern": {
                                                "phrase": "str",  #
                                                  Optional. The alias pattern phrase.
                                                "type": "str",  #
                                                  Optional. The type of alias pattern. Known values
                                                  are: "NotSpecified" and "Extract".
                                                "variable": "str"  #
                                                  Optional. The alias pattern variable.
                                            }
                                        }
                                    ],
                                    "type": "str"  # Optional. The type of the
                                      alias. Known values are: "NotSpecified", "PlainText", and "Mask".
                                }
                            ],
                            "apiProfiles": [
                                {
                                    "apiVersion": "str",  # Optional. The API
                                      version.
                                    "profileVersion": "str"  # Optional. The
                                      profile version.
                                }
                            ],
                            "apiVersions": [
                                "str"  # Optional. The API version.
                            ],
                            "capabilities": "str",  # Optional. The additional
                              capabilities offered by this resource type.
                            "defaultApiVersion": "str",  # Optional. The default API
                              version.
                            "locationMappings": [
                                {
                                    "extendedLocations": [
                                        "str"  # Optional. The extended
                                          locations for the azure location.
                                    ],
                                    "location": "str",  # Optional. The azure
                                      location.
                                    "type": "str"  # Optional. The extended
                                      location type.
                                }
                            ],
                            "locations": [
                                "str"  # Optional. The collection of locations where
                                  this resource type can be created.
                            ],
                            "properties": {
                                "str": "str"  # Optional. The properties.
                            },
                            "resourceType": "str",  # Optional. The resource type.
                            "zoneMappings": [
                                {
                                    "location": "str",  # Optional. The location
                                      of the zone mapping.
                                    "zones": [
                                        "str"  # Optional. The collection of
                                          provider resource types.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_providers_get_request(
            resource_provider_namespace=resource_provider_namespace,
            subscription_id=self._config.subscription_id,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_at_tenant_scope(
        self, resource_provider_namespace: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Gets the specified resource provider at the tenant level.

        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :keyword expand: The $expand query parameter. For example, to include property aliases in
         response, use $expand=resourceTypes/aliases. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The provider ID.
                    "namespace": "str",  # Optional. The namespace of the resource provider.
                    "providerAuthorizationConsentState": "str",  # Optional. The provider
                      authorization consent state. Known values are: "NotSpecified", "Required",
                      "NotRequired", and "Consented".
                    "registrationPolicy": "str",  # Optional. The registration policy of the
                      resource provider.
                    "registrationState": "str",  # Optional. The registration state of the
                      resource provider.
                    "resourceTypes": [
                        {
                            "aliases": [
                                {
                                    "defaultMetadata": {
                                        "attributes": "str",  # Optional. The
                                          attributes of the token that the alias path is referring to.
                                          Known values are: "None" and "Modifiable".
                                        "type": "str"  # Optional. The type
                                          of the token that the alias path is referring to. Known
                                          values are: "NotSpecified", "Any", "String", "Object",
                                          "Array", "Integer", "Number", and "Boolean".
                                    },
                                    "defaultPath": "str",  # Optional. The
                                      default path for an alias.
                                    "defaultPattern": {
                                        "phrase": "str",  # Optional. The
                                          alias pattern phrase.
                                        "type": "str",  # Optional. The type
                                          of alias pattern. Known values are: "NotSpecified" and
                                          "Extract".
                                        "variable": "str"  # Optional. The
                                          alias pattern variable.
                                    },
                                    "name": "str",  # Optional. The alias name.
                                    "paths": [
                                        {
                                            "apiVersions": [
                                                "str"  # Optional.
                                                  The API versions.
                                            ],
                                            "metadata": {
                                                "attributes": "str",
                                                  # Optional. The attributes of the token that the
                                                  alias path is referring to. Known values are: "None"
                                                  and "Modifiable".
                                                "type": "str"  #
                                                  Optional. The type of the token that the alias path
                                                  is referring to. Known values are: "NotSpecified",
                                                  "Any", "String", "Object", "Array", "Integer",
                                                  "Number", and "Boolean".
                                            },
                                            "path": "str",  # Optional.
                                              The path of an alias.
                                            "pattern": {
                                                "phrase": "str",  #
                                                  Optional. The alias pattern phrase.
                                                "type": "str",  #
                                                  Optional. The type of alias pattern. Known values
                                                  are: "NotSpecified" and "Extract".
                                                "variable": "str"  #
                                                  Optional. The alias pattern variable.
                                            }
                                        }
                                    ],
                                    "type": "str"  # Optional. The type of the
                                      alias. Known values are: "NotSpecified", "PlainText", and "Mask".
                                }
                            ],
                            "apiProfiles": [
                                {
                                    "apiVersion": "str",  # Optional. The API
                                      version.
                                    "profileVersion": "str"  # Optional. The
                                      profile version.
                                }
                            ],
                            "apiVersions": [
                                "str"  # Optional. The API version.
                            ],
                            "capabilities": "str",  # Optional. The additional
                              capabilities offered by this resource type.
                            "defaultApiVersion": "str",  # Optional. The default API
                              version.
                            "locationMappings": [
                                {
                                    "extendedLocations": [
                                        "str"  # Optional. The extended
                                          locations for the azure location.
                                    ],
                                    "location": "str",  # Optional. The azure
                                      location.
                                    "type": "str"  # Optional. The extended
                                      location type.
                                }
                            ],
                            "locations": [
                                "str"  # Optional. The collection of locations where
                                  this resource type can be created.
                            ],
                            "properties": {
                                "str": "str"  # Optional. The properties.
                            },
                            "resourceType": "str",  # Optional. The resource type.
                            "zoneMappings": [
                                {
                                    "location": "str",  # Optional. The location
                                      of the zone mapping.
                                    "zones": [
                                        "str"  # Optional. The collection of
                                          provider resource types.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_providers_get_at_tenant_scope_request(
            resource_provider_namespace=resource_provider_namespace,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class ProviderResourceTypesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~resources.mgmt.ResourceManagementClient`'s
        :attr:`provider_resource_types` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_provider_namespace: str, *, expand: Optional[str] = None, **kwargs: Any) -> JSON:
        """List the resource types for a specified resource provider.

        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :keyword expand: The $expand query parameter. For example, to include property aliases in
         response, use $expand=resourceTypes/aliases. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "nextLink": "str",  # Optional. The URL to use for getting the next set of
                      results.
                    "value": [
                        {
                            "aliases": [
                                {
                                    "defaultMetadata": {
                                        "attributes": "str",  # Optional. The
                                          attributes of the token that the alias path is referring to.
                                          Known values are: "None" and "Modifiable".
                                        "type": "str"  # Optional. The type
                                          of the token that the alias path is referring to. Known
                                          values are: "NotSpecified", "Any", "String", "Object",
                                          "Array", "Integer", "Number", and "Boolean".
                                    },
                                    "defaultPath": "str",  # Optional. The
                                      default path for an alias.
                                    "defaultPattern": {
                                        "phrase": "str",  # Optional. The
                                          alias pattern phrase.
                                        "type": "str",  # Optional. The type
                                          of alias pattern. Known values are: "NotSpecified" and
                                          "Extract".
                                        "variable": "str"  # Optional. The
                                          alias pattern variable.
                                    },
                                    "name": "str",  # Optional. The alias name.
                                    "paths": [
                                        {
                                            "apiVersions": [
                                                "str"  # Optional.
                                                  The API versions.
                                            ],
                                            "metadata": {
                                                "attributes": "str",
                                                  # Optional. The attributes of the token that the
                                                  alias path is referring to. Known values are: "None"
                                                  and "Modifiable".
                                                "type": "str"  #
                                                  Optional. The type of the token that the alias path
                                                  is referring to. Known values are: "NotSpecified",
                                                  "Any", "String", "Object", "Array", "Integer",
                                                  "Number", and "Boolean".
                                            },
                                            "path": "str",  # Optional.
                                              The path of an alias.
                                            "pattern": {
                                                "phrase": "str",  #
                                                  Optional. The alias pattern phrase.
                                                "type": "str",  #
                                                  Optional. The type of alias pattern. Known values
                                                  are: "NotSpecified" and "Extract".
                                                "variable": "str"  #
                                                  Optional. The alias pattern variable.
                                            }
                                        }
                                    ],
                                    "type": "str"  # Optional. The type of the
                                      alias. Known values are: "NotSpecified", "PlainText", and "Mask".
                                }
                            ],
                            "apiProfiles": [
                                {
                                    "apiVersion": "str",  # Optional. The API
                                      version.
                                    "profileVersion": "str"  # Optional. The
                                      profile version.
                                }
                            ],
                            "apiVersions": [
                                "str"  # Optional. The API version.
                            ],
                            "capabilities": "str",  # Optional. The additional
                              capabilities offered by this resource type.
                            "defaultApiVersion": "str",  # Optional. The default API
                              version.
                            "locationMappings": [
                                {
                                    "extendedLocations": [
                                        "str"  # Optional. The extended
                                          locations for the azure location.
                                    ],
                                    "location": "str",  # Optional. The azure
                                      location.
                                    "type": "str"  # Optional. The extended
                                      location type.
                                }
                            ],
                            "locations": [
                                "str"  # Optional. The collection of locations where
                                  this resource type can be created.
                            ],
                            "properties": {
                                "str": "str"  # Optional. The properties.
                            },
                            "resourceType": "str",  # Optional. The resource type.
                            "zoneMappings": [
                                {
                                    "location": "str",  # Optional. The location
                                      of the zone mapping.
                                    "zones": [
                                        "str"  # Optional. An array of
                                          resource types.
                                    ]
                                }
                            ]
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_provider_resource_types_list_request(
            resource_provider_namespace=resource_provider_namespace,
            subscription_id=self._config.subscription_id,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class ResourcesOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~resources.mgmt.ResourceManagementClient`'s
        :attr:`resources` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(
        self,
        resource_group_name: str,
        *,
        filter: Optional[str] = None,
        expand: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Get all the resources for a resource group.

        :param resource_group_name: The resource group with the resources to get. Required.
        :type resource_group_name: str
        :keyword filter: The filter to apply on the operation.:code:`<br>`:code:`<br>`The properties
         you can use for eq (equals) or ne (not equals) are: location, resourceType, name,
         resourceGroup, identity, identity/principalId, plan, plan/publisher, plan/product, plan/name,
         plan/version, and plan/promotionCode.:code:`<br>`:code:`<br>`For example, to filter by a
         resource type, use: $filter=resourceType eq
         'Microsoft.Network/virtualNetworks':code:`<br>`:code:`<br>`You can use substringof(value,
         property) in the filter. The properties you can use for substring are: name and
         resourceGroup.:code:`<br>`:code:`<br>`For example, to get all resources with 'demo' anywhere in
         the name, use: $filter=substringof('demo', name):code:`<br>`:code:`<br>`You can link more than
         one substringof together by adding and/or operators.:code:`<br>`:code:`<br>`You can filter by
         tag names and values. For example, to filter for a tag name and value, use $filter=tagName eq
         'tag1' and tagValue eq 'Value1'. When you filter by a tag name and value, the tags for each
         resource are not returned in the results.:code:`<br>`:code:`<br>`You can use some properties
         together when filtering. The combinations you can use are: substringof and/or resourceType,
         plan and plan/publisher and plan/name, identity and identity/principalId. Default value is
         None.
        :paramtype filter: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Valid values include ``createdTime`` , ``changedTime`` and ``provisioningState``. For example,
         ``$expand=createdTime,changedTime``. Default value is None.
        :paramtype expand: str
        :keyword top: The number of results to return. If null is passed, returns all resources.
         Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "changedTime": "2020-02-20 00:00:00",  # Optional. The changed time of the
                      resource. This is only present if requested via the $expand query parameter.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The created time of the
                      resource. This is only present if requested via the $expand query parameter.
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "provisioningState": "str",  # Optional. The provisioning state of the
                      resource. This is only present if requested via the $expand query parameter.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_resources_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _move_resources_initial(  # pylint: disable=inconsistent-return-statements
        self, source_resource_group_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_resources_move_resources_request(
            source_resource_group_name=source_resource_group_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    def begin_move_resources(
        self,
        source_resource_group_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[None]:
        """Moves resources from one resource group to another resource group.

        The resources to be moved must be in the same source resource group in the source subscription
        being used. The target resource group may be in a different subscription. When moving
        resources, both the source group and the target group are locked for the duration of the
        operation. Write and delete operations are blocked on the groups until the move completes.

        :param source_resource_group_name: The name of the resource group from the source subscription
         containing the resources to be moved. Required.
        :type source_resource_group_name: str
        :param parameters: Parameters for moving resources. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "resources": [
                        "str"  # Optional. The IDs of the resources.
                    ],
                    "targetResourceGroup": "str"  # Optional. The target resource group.
                }
        """

    @overload
    def begin_move_resources(
        self, source_resource_group_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Moves resources from one resource group to another resource group.

        The resources to be moved must be in the same source resource group in the source subscription
        being used. The target resource group may be in a different subscription. When moving
        resources, both the source group and the target group are locked for the duration of the
        operation. Write and delete operations are blocked on the groups until the move completes.

        :param source_resource_group_name: The name of the resource group from the source subscription
         containing the resources to be moved. Required.
        :type source_resource_group_name: str
        :param parameters: Parameters for moving resources. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_move_resources(
        self, source_resource_group_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[None]:
        """Moves resources from one resource group to another resource group.

        The resources to be moved must be in the same source resource group in the source subscription
        being used. The target resource group may be in a different subscription. When moving
        resources, both the source group and the target group are locked for the duration of the
        operation. Write and delete operations are blocked on the groups until the move completes.

        :param source_resource_group_name: The name of the resource group from the source subscription
         containing the resources to be moved. Required.
        :type source_resource_group_name: str
        :param parameters: Parameters for moving resources. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "resources": [
                        "str"  # Optional. The IDs of the resources.
                    ],
                    "targetResourceGroup": "str"  # Optional. The target resource group.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._move_resources_initial(  # type: ignore
                source_resource_group_name=source_resource_group_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _validate_move_resources_initial(  # pylint: disable=inconsistent-return-statements
        self, source_resource_group_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_resources_validate_move_resources_request(
            source_resource_group_name=source_resource_group_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    def begin_validate_move_resources(
        self,
        source_resource_group_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[None]:
        """Validates whether resources can be moved from one resource group to another resource group.

        This operation checks whether the specified resources can be moved to the target. The resources
        to be moved must be in the same source resource group in the source subscription being used.
        The target resource group may be in a different subscription. If validation succeeds, it
        returns HTTP response code 204 (no content). If validation fails, it returns HTTP response code
        409 (Conflict) with an error message. Retrieve the URL in the Location header value to check
        the result of the long-running operation.

        :param source_resource_group_name: The name of the resource group from the source subscription
         containing the resources to be validated for move. Required.
        :type source_resource_group_name: str
        :param parameters: Parameters for moving resources. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "resources": [
                        "str"  # Optional. The IDs of the resources.
                    ],
                    "targetResourceGroup": "str"  # Optional. The target resource group.
                }
        """

    @overload
    def begin_validate_move_resources(
        self, source_resource_group_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Validates whether resources can be moved from one resource group to another resource group.

        This operation checks whether the specified resources can be moved to the target. The resources
        to be moved must be in the same source resource group in the source subscription being used.
        The target resource group may be in a different subscription. If validation succeeds, it
        returns HTTP response code 204 (no content). If validation fails, it returns HTTP response code
        409 (Conflict) with an error message. Retrieve the URL in the Location header value to check
        the result of the long-running operation.

        :param source_resource_group_name: The name of the resource group from the source subscription
         containing the resources to be validated for move. Required.
        :type source_resource_group_name: str
        :param parameters: Parameters for moving resources. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_validate_move_resources(
        self, source_resource_group_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[None]:
        """Validates whether resources can be moved from one resource group to another resource group.

        This operation checks whether the specified resources can be moved to the target. The resources
        to be moved must be in the same source resource group in the source subscription being used.
        The target resource group may be in a different subscription. If validation succeeds, it
        returns HTTP response code 204 (no content). If validation fails, it returns HTTP response code
        409 (Conflict) with an error message. Retrieve the URL in the Location header value to check
        the result of the long-running operation.

        :param source_resource_group_name: The name of the resource group from the source subscription
         containing the resources to be validated for move. Required.
        :type source_resource_group_name: str
        :param parameters: Parameters for moving resources. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "resources": [
                        "str"  # Optional. The IDs of the resources.
                    ],
                    "targetResourceGroup": "str"  # Optional. The target resource group.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._validate_move_resources_initial(  # type: ignore
                source_resource_group_name=source_resource_group_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(
        self, *, filter: Optional[str] = None, expand: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Get all the resources in a subscription.

        :keyword filter: The filter to apply on the operation.:code:`<br>`:code:`<br>`Filter comparison
         operators include ``eq`` (equals) and ``ne`` (not equals) and may be used with the following
         properties: ``location`` , ``resourceType`` , ``name`` , ``resourceGroup`` , ``identity``
         , ``identity/principalId`` , ``plan`` , ``plan/publisher`` , ``plan/product`` ,
         ``plan/name`` , ``plan/version`` , and ``plan/promotionCode``.:code:`<br>`:code:`<br>`For
         example, to filter by a resource type, use ``$filter=resourceType eq
         'Microsoft.Network/virtualNetworks'`` :code:`<br>`:code:`<br>`:code:`<br>`
         ``substringof(value, property)`` can  be used to filter for substrings of the following
         currently-supported properties: ``name`` and ``resourceGroup`` :code:`<br>`:code:`<br>`For
         example, to get all resources with 'demo' anywhere in the resource name, use
         ``$filter=substringof('demo', name)`` :code:`<br>`:code:`<br>`Multiple substring operations
         can also be combined using ``and`` / ``or`` operators.:code:`<br>`:code:`<br>`Note that any
         truncated number of results queried via ``$top`` may also not be compatible when using a
         filter.:code:`<br>`:code:`<br>`:code:`<br>`Resources can be filtered by tag names and values.
         For example, to filter for a tag name and value, use ``$filter=tagName eq 'tag1' and tagValue
         eq 'Value1'``. Note that when resources are filtered by tag name and value, :code:`<b>the
         original tags for each resource will not be returned in the results.</b>` Any list of
         additional properties queried via ``$expand`` may also not be compatible when filtering by tag
         names/values. :code:`<br>`:code:`<br>`For tag names only, resources can be filtered by prefix
         using the following syntax: ``$filter=startswith(tagName, 'depart')``. This query will return
         all resources with a tag name prefixed by the phrase ``depart`` (i.e. ``department`` ,
         ``departureDate`` , ``departureTime`` , etc.):code:`<br>`:code:`<br>`:code:`<br>`Note that
         some properties can be combined when filtering resources, which include the following:
         ``substringof() and/or resourceType`` , ``plan and plan/publisher and plan/name`` , and
         ``identity and identity/principalId``. Default value is None.
        :paramtype filter: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Valid values include ``createdTime`` , ``changedTime`` and ``provisioningState``. For example,
         ``$expand=createdTime,changedTime``. Default value is None.
        :paramtype expand: str
        :keyword top: The number of recommendations per page if a paged version of this API is being
         used. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "changedTime": "2020-02-20 00:00:00",  # Optional. The changed time of the
                      resource. This is only present if requested via the $expand query parameter.
                    "createdTime": "2020-02-20 00:00:00",  # Optional. The created time of the
                      resource. This is only present if requested via the $expand query parameter.
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "provisioningState": "str",  # Optional. The provisioning state of the
                      resource. This is only present if requested via the $expand query parameter.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_resources_list_request(
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def check_existence(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        *,
        api_version: str,
        **kwargs: Any
    ) -> bool:
        """Checks whether a resource exists.

        :param resource_group_name: The name of the resource group containing the resource to check.
         The name is case insensitive. Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The resource provider of the resource to check. Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource identity. Required.
        :type parent_resource_path: str
        :param resource_type: The resource type. Required.
        :type resource_type: str
        :param resource_name: The name of the resource to check whether it exists. Required.
        :type resource_name: str
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_resources_check_existence_request(
            resource_group_name=resource_group_name,
            resource_provider_namespace=resource_provider_namespace,
            parent_resource_path=parent_resource_path,
            resource_type=resource_type,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
        return 200 <= response.status_code <= 299

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        *,
        api_version: str,
        **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_resources_delete_request(
            resource_group_name=resource_group_name,
            resource_provider_namespace=resource_provider_namespace,
            parent_resource_path=parent_resource_path,
            resource_type=resource_type,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_delete(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        *,
        api_version: str,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes a resource.

        :param resource_group_name: The name of the resource group that contains the resource to
         delete. The name is case insensitive. Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource identity. Required.
        :type parent_resource_path: str
        :param resource_type: The resource type. Required.
        :type resource_type: str
        :param resource_name: The name of the resource to delete. Required.
        :type resource_name: str
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                resource_provider_namespace=resource_provider_namespace,
                parent_resource_path=parent_resource_path,
                resource_type=resource_type,
                resource_name=resource_name,
                api_version=api_version,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        parameters: Union[JSON, IO],
        *,
        api_version: str,
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_resources_create_or_update_request(
            resource_group_name=resource_group_name,
            resource_provider_namespace=resource_provider_namespace,
            parent_resource_path=parent_resource_path,
            resource_type=resource_type,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        parameters: JSON,
        *,
        api_version: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a resource.

        :param resource_group_name: The name of the resource group for the resource. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource identity. Required.
        :type parent_resource_path: str
        :param resource_type: The resource type of the resource to create. Required.
        :type resource_type: str
        :param resource_name: The name of the resource to create. Required.
        :type resource_name: str
        :param parameters: Parameters for creating or updating the resource. Required.
        :type parameters: JSON
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        parameters: IO,
        *,
        api_version: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a resource.

        :param resource_group_name: The name of the resource group for the resource. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource identity. Required.
        :type parent_resource_path: str
        :param resource_type: The resource type of the resource to create. Required.
        :type resource_type: str
        :param resource_name: The name of the resource to create. Required.
        :type resource_name: str
        :param parameters: Parameters for creating or updating the resource. Required.
        :type parameters: IO
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        parameters: Union[JSON, IO],
        *,
        api_version: str,
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a resource.

        :param resource_group_name: The name of the resource group for the resource. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource identity. Required.
        :type parent_resource_path: str
        :param resource_type: The resource type of the resource to create. Required.
        :type resource_type: str
        :param resource_name: The name of the resource to create. Required.
        :type resource_name: str
        :param parameters: Parameters for creating or updating the resource. Is either a JSON type or a
         IO type. Required.
        :type parameters: JSON or IO
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                resource_provider_namespace=resource_provider_namespace,
                parent_resource_path=parent_resource_path,
                resource_type=resource_type,
                resource_name=resource_name,
                parameters=parameters,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        parameters: Union[JSON, IO],
        *,
        api_version: str,
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_resources_update_request(
            resource_group_name=resource_group_name,
            resource_provider_namespace=resource_provider_namespace,
            parent_resource_path=parent_resource_path,
            resource_type=resource_type,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        parameters: JSON,
        *,
        api_version: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a resource.

        :param resource_group_name: The name of the resource group for the resource. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource identity. Required.
        :type parent_resource_path: str
        :param resource_type: The resource type of the resource to update. Required.
        :type resource_type: str
        :param resource_name: The name of the resource to update. Required.
        :type resource_name: str
        :param parameters: Parameters for updating the resource. Required.
        :type parameters: JSON
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        parameters: IO,
        *,
        api_version: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a resource.

        :param resource_group_name: The name of the resource group for the resource. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource identity. Required.
        :type parent_resource_path: str
        :param resource_type: The resource type of the resource to update. Required.
        :type resource_type: str
        :param resource_name: The name of the resource to update. Required.
        :type resource_name: str
        :param parameters: Parameters for updating the resource. Required.
        :type parameters: IO
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        parameters: Union[JSON, IO],
        *,
        api_version: str,
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a resource.

        :param resource_group_name: The name of the resource group for the resource. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource identity. Required.
        :type parent_resource_path: str
        :param resource_type: The resource type of the resource to update. Required.
        :type resource_type: str
        :param resource_name: The name of the resource to update. Required.
        :type resource_name: str
        :param parameters: Parameters for updating the resource. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                resource_provider_namespace=resource_provider_namespace,
                parent_resource_path=parent_resource_path,
                resource_type=resource_type,
                resource_name=resource_name,
                parameters=parameters,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        *,
        api_version: str,
        **kwargs: Any
    ) -> JSON:
        """Gets a resource.

        :param resource_group_name: The name of the resource group containing the resource to get. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource identity. Required.
        :type parent_resource_path: str
        :param resource_type: The resource type of the resource. Required.
        :type resource_type: str
        :param resource_name: The name of the resource to get. Required.
        :type resource_name: str
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_resources_get_request(
            resource_group_name=resource_group_name,
            resource_provider_namespace=resource_provider_namespace,
            parent_resource_path=parent_resource_path,
            resource_type=resource_type,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def check_existence_by_id(self, resource_id: str, *, api_version: str, **kwargs: Any) -> bool:
        """Checks by ID whether a resource exists. This API currently works only for a limited set of
        Resource providers. In the event that a Resource provider does not implement this API, ARM will
        respond with a 405. The alternative then is to use the GET API to check for the existence of
        the resource.

        :param resource_id: The fully qualified ID of the resource, including the resource name and
         resource type. Use the format,
         /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}.
         Required.
        :type resource_id: str
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_resources_check_existence_by_id_request(
            resource_id=resource_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
        return 200 <= response.status_code <= 299

    def _delete_by_id_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_id: str, *, api_version: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_resources_delete_by_id_request(
            resource_id=resource_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_delete_by_id(self, resource_id: str, *, api_version: str, **kwargs: Any) -> LROPoller[None]:
        """Deletes a resource by ID.

        :param resource_id: The fully qualified ID of the resource, including the resource name and
         resource type. Use the format,
         /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}.
         Required.
        :type resource_id: str
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_by_id_initial(  # type: ignore
                resource_id=resource_id,
                api_version=api_version,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _create_or_update_by_id_initial(
        self, resource_id: str, parameters: Union[JSON, IO], *, api_version: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_resources_create_or_update_by_id_request(
            resource_id=resource_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def begin_create_or_update_by_id(
        self,
        resource_id: str,
        parameters: JSON,
        *,
        api_version: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a resource by ID.

        :param resource_id: The fully qualified ID of the resource, including the resource name and
         resource type. Use the format,
         /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}.
         Required.
        :type resource_id: str
        :param parameters: Create or update resource parameters. Required.
        :type parameters: JSON
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def begin_create_or_update_by_id(
        self,
        resource_id: str,
        parameters: IO,
        *,
        api_version: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a resource by ID.

        :param resource_id: The fully qualified ID of the resource, including the resource name and
         resource type. Use the format,
         /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}.
         Required.
        :type resource_id: str
        :param parameters: Create or update resource parameters. Required.
        :type parameters: IO
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def begin_create_or_update_by_id(
        self, resource_id: str, parameters: Union[JSON, IO], *, api_version: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a resource by ID.

        :param resource_id: The fully qualified ID of the resource, including the resource name and
         resource type. Use the format,
         /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}.
         Required.
        :type resource_id: str
        :param parameters: Create or update resource parameters. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_by_id_initial(
                resource_id=resource_id,
                parameters=parameters,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_by_id_initial(
        self, resource_id: str, parameters: Union[JSON, IO], *, api_version: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_resources_update_by_id_request(
            resource_id=resource_id,
            api_version=api_version,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def begin_update_by_id(
        self,
        resource_id: str,
        parameters: JSON,
        *,
        api_version: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a resource by ID.

        :param resource_id: The fully qualified ID of the resource, including the resource name and
         resource type. Use the format,
         /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}.
         Required.
        :type resource_id: str
        :param parameters: Update resource parameters. Required.
        :type parameters: JSON
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def begin_update_by_id(
        self,
        resource_id: str,
        parameters: IO,
        *,
        api_version: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a resource by ID.

        :param resource_id: The fully qualified ID of the resource, including the resource name and
         resource type. Use the format,
         /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}.
         Required.
        :type resource_id: str
        :param parameters: Update resource parameters. Required.
        :type parameters: IO
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def begin_update_by_id(
        self, resource_id: str, parameters: Union[JSON, IO], *, api_version: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a resource by ID.

        :param resource_id: The fully qualified ID of the resource, including the resource name and
         resource type. Use the format,
         /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}.
         Required.
        :type resource_id: str
        :param parameters: Update resource parameters. Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_by_id_initial(
                resource_id=resource_id,
                parameters=parameters,
                api_version=api_version,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_by_id(self, resource_id: str, *, api_version: str, **kwargs: Any) -> JSON:
        """Gets a resource by ID.

        :param resource_id: The fully qualified ID of the resource, including the resource name and
         resource type. Use the format,
         /subscriptions/{guid}/resourceGroups/{resource-group-name}/{resource-provider-namespace}/{resource-type}/{resource-name}.
         Required.
        :type resource_id: str
        :keyword api_version: The API version to use for the operation. Required.
        :paramtype api_version: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # Optional. The extended location name.
                        "type": "str"  # Optional. The extended location type. "EdgeZone"
                    },
                    "id": "str",  # Optional. Resource ID.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str",  # Optional. The identity type. Known values are:
                          "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned", and "None".
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client id of user
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal id of
                                  user assigned identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. The kind of the resource.
                    "location": "str",  # Optional. Resource location.
                    "managedBy": "str",  # Optional. ID of the resource that manages this
                      resource.
                    "name": "str",  # Optional. Resource name.
                    "plan": {
                        "name": "str",  # Optional. The plan ID.
                        "product": "str",  # Optional. The offer ID.
                        "promotionCode": "str",  # Optional. The promotion code.
                        "publisher": "str",  # Optional. The publisher ID.
                        "version": "str"  # Optional. The plan's version.
                    },
                    "properties": {},  # Optional. The resource properties.
                    "sku": {
                        "capacity": 0,  # Optional. The SKU capacity.
                        "family": "str",  # Optional. The SKU family.
                        "model": "str",  # Optional. The SKU model.
                        "name": "str",  # Optional. The SKU name.
                        "size": "str",  # Optional. The SKU size.
                        "tier": "str"  # Optional. The SKU tier.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_resources_get_by_id_request(
            resource_id=resource_id,
            api_version=api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class ResourceGroupsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~resources.mgmt.ResourceManagementClient`'s
        :attr:`resource_groups` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def check_existence(self, resource_group_name: str, **kwargs: Any) -> bool:
        """Checks whether a resource group exists.

        :param resource_group_name: The name of the resource group to check. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :return: bool
        :rtype: bool
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_resource_groups_check_existence_request(
            resource_group_name=resource_group_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
        return 200 <= response.status_code <= 299

    @overload
    def create_or_update(
        self, resource_group_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates or updates a resource group.

        :param resource_group_name: The name of the resource group to create or update. Can include
         alphanumeric, underscore, parentheses, hyphen, period (except at end), and Unicode characters
         that match the allowed characters. Required.
        :type resource_group_name: str
        :param parameters: Parameters supplied to the create or update a resource group. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location of the resource group. It cannot be
                      changed after the resource group has been created. It must be one of the
                      supported Azure locations. Required.
                    "id": "str",  # Optional. The ID of the resource group.
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    },
                    "type": "str"  # Optional. The type of the resource group.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The location of the resource group. It cannot be
                      changed after the resource group has been created. It must be one of the
                      supported Azure locations. Required.
                    "id": "str",  # Optional. The ID of the resource group.
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    },
                    "type": "str"  # Optional. The type of the resource group.
                }
        """

    @overload
    def create_or_update(
        self, resource_group_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Creates or updates a resource group.

        :param resource_group_name: The name of the resource group to create or update. Can include
         alphanumeric, underscore, parentheses, hyphen, period (except at end), and Unicode characters
         that match the allowed characters. Required.
        :type resource_group_name: str
        :param parameters: Parameters supplied to the create or update a resource group. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The location of the resource group. It cannot be
                      changed after the resource group has been created. It must be one of the
                      supported Azure locations. Required.
                    "id": "str",  # Optional. The ID of the resource group.
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    },
                    "type": "str"  # Optional. The type of the resource group.
                }
        """

    @distributed_trace
    def create_or_update(self, resource_group_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates or updates a resource group.

        :param resource_group_name: The name of the resource group to create or update. Can include
         alphanumeric, underscore, parentheses, hyphen, period (except at end), and Unicode characters
         that match the allowed characters. Required.
        :type resource_group_name: str
        :param parameters: Parameters supplied to the create or update a resource group. Is either a
         JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The location of the resource group. It cannot be
                      changed after the resource group has been created. It must be one of the
                      supported Azure locations. Required.
                    "id": "str",  # Optional. The ID of the resource group.
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    },
                    "type": "str"  # Optional. The type of the resource group.
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The location of the resource group. It cannot be
                      changed after the resource group has been created. It must be one of the
                      supported Azure locations. Required.
                    "id": "str",  # Optional. The ID of the resource group.
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    },
                    "type": "str"  # Optional. The type of the resource group.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_resource_groups_create_or_update_request(
            resource_group_name=resource_group_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, *, force_deletion_types: Optional[str] = None, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_resource_groups_delete_request(
            resource_group_name=resource_group_name,
            subscription_id=self._config.subscription_id,
            force_deletion_types=force_deletion_types,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, *, force_deletion_types: Optional[str] = None, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes a resource group.

        When you delete a resource group, all of its resources are also deleted. Deleting a resource
        group deletes all of its template deployments and currently stored operations.

        :param resource_group_name: The name of the resource group to delete. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :keyword force_deletion_types: The resource types you want to force delete. Currently, only the
         following is supported:
         forceDeletionTypes=Microsoft.Compute/virtualMachines,Microsoft.Compute/virtualMachineScaleSets.
         Default value is None.
        :paramtype force_deletion_types: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                force_deletion_types=force_deletion_types,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, resource_group_name: str, **kwargs: Any) -> JSON:
        """Gets a resource group.

        :param resource_group_name: The name of the resource group to get. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The location of the resource group. It cannot be
                      changed after the resource group has been created. It must be one of the
                      supported Azure locations. Required.
                    "id": "str",  # Optional. The ID of the resource group.
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    },
                    "type": "str"  # Optional. The type of the resource group.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_resource_groups_get_request(
            resource_group_name=resource_group_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update(
        self, resource_group_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Updates a resource group.

        Resource groups can be updated through a simple PATCH operation to a group address. The format
        of the request is the same as that for creating a resource group. If a field is unspecified,
        the current value is retained.

        :param resource_group_name: The name of the resource group to update. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :param parameters: Parameters supplied to update a resource group. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The location of the resource group. It cannot be
                      changed after the resource group has been created. It must be one of the
                      supported Azure locations. Required.
                    "id": "str",  # Optional. The ID of the resource group.
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    },
                    "type": "str"  # Optional. The type of the resource group.
                }
        """

    @overload
    def update(
        self, resource_group_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Updates a resource group.

        Resource groups can be updated through a simple PATCH operation to a group address. The format
        of the request is the same as that for creating a resource group. If a field is unspecified,
        the current value is retained.

        :param resource_group_name: The name of the resource group to update. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :param parameters: Parameters supplied to update a resource group. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The location of the resource group. It cannot be
                      changed after the resource group has been created. It must be one of the
                      supported Azure locations. Required.
                    "id": "str",  # Optional. The ID of the resource group.
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    },
                    "type": "str"  # Optional. The type of the resource group.
                }
        """

    @distributed_trace
    def update(self, resource_group_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Updates a resource group.

        Resource groups can be updated through a simple PATCH operation to a group address. The format
        of the request is the same as that for creating a resource group. If a field is unspecified,
        the current value is retained.

        :param resource_group_name: The name of the resource group to update. The name is case
         insensitive. Required.
        :type resource_group_name: str
        :param parameters: Parameters supplied to update a resource group. Is either a JSON type or a
         IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The location of the resource group. It cannot be
                      changed after the resource group has been created. It must be one of the
                      supported Azure locations. Required.
                    "id": "str",  # Optional. The ID of the resource group.
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    },
                    "type": "str"  # Optional. The type of the resource group.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_resource_groups_update_request(
            resource_group_name=resource_group_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _export_template_initial(
        self, resource_group_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_resource_groups_export_template_request(
            resource_group_name=resource_group_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def begin_export_template(
        self, resource_group_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Captures the specified resource group as a template.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param parameters: Parameters for exporting the template. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "options": "str",  # Optional. The export template options. A CSV-formatted
                      list containing zero or more of the following: 'IncludeParameterDefaultValue',
                      'IncludeComments', 'SkipResourceNameParameterization', 'SkipAllParameterization'.
                    "outputFormat": "str",  # Optional. The output format for the exported
                      resources. Known values are: "Json" and "Bicep".
                    "resources": [
                        "str"  # Optional. The IDs of the resources to filter the export by.
                          To export all resources, supply an array with single entry '*'.
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "output": "str",  # Optional. The formatted export content. Used if
                      outputFormat is set to 'Bicep'.
                    "template": {}  # Optional. The template content. Used if outputFormat is
                      empty or set to 'Json'.
                }
        """

    @overload
    def begin_export_template(
        self, resource_group_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Captures the specified resource group as a template.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param parameters: Parameters for exporting the template. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "output": "str",  # Optional. The formatted export content. Used if
                      outputFormat is set to 'Bicep'.
                    "template": {}  # Optional. The template content. Used if outputFormat is
                      empty or set to 'Json'.
                }
        """

    @distributed_trace
    def begin_export_template(
        self, resource_group_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Captures the specified resource group as a template.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param parameters: Parameters for exporting the template. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "options": "str",  # Optional. The export template options. A CSV-formatted
                      list containing zero or more of the following: 'IncludeParameterDefaultValue',
                      'IncludeComments', 'SkipResourceNameParameterization', 'SkipAllParameterization'.
                    "outputFormat": "str",  # Optional. The output format for the exported
                      resources. Known values are: "Json" and "Bicep".
                    "resources": [
                        "str"  # Optional. The IDs of the resources to filter the export by.
                          To export all resources, supply an array with single entry '*'.
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "output": "str",  # Optional. The formatted export content. Used if
                      outputFormat is set to 'Bicep'.
                    "template": {}  # Optional. The template content. Used if outputFormat is
                      empty or set to 'Json'.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._export_template_initial(
                resource_group_name=resource_group_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def list(self, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any) -> Iterable[JSON]:
        """Gets all the resource groups for a subscription.

        :keyword filter: The filter to apply on the operation.:code:`<br>`:code:`<br>`You can filter by
         tag names and values. For example, to filter for a tag name and value, use $filter=tagName eq
         'tag1' and tagValue eq 'Value1'. Default value is None.
        :paramtype filter: str
        :keyword top: The number of results to return. If null is passed, returns all resource groups.
         Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The location of the resource group. It cannot be
                      changed after the resource group has been created. It must be one of the
                      supported Azure locations. Required.
                    "id": "str",  # Optional. The ID of the resource group.
                    "managedBy": "str",  # Optional. The ID of the resource that manages this
                      resource group.
                    "name": "str",  # Optional. The name of the resource group.
                    "properties": {
                        "provisioningState": "str"  # Optional. The provisioning state.
                    },
                    "tags": {
                        "str": "str"  # Optional. The tags attached to the resource group.
                    },
                    "type": "str"  # Optional. The type of the resource group.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_resource_groups_list_request(
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class TagsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~resources.mgmt.ResourceManagementClient`'s
        :attr:`tags` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def delete_value(  # pylint: disable=inconsistent-return-statements
        self, tag_name: str, tag_value: str, **kwargs: Any
    ) -> None:
        """Deletes a predefined tag value for a predefined tag name.

        This operation allows deleting a value from the list of predefined values for an existing
        predefined tag name. The value being deleted must not be in use as a tag value for the given
        tag name for any resource.

        :param tag_name: The name of the tag. Required.
        :type tag_name: str
        :param tag_value: The value of the tag to delete. Required.
        :type tag_value: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_tags_delete_value_request(
            tag_name=tag_name,
            tag_value=tag_value,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def create_or_update_value(self, tag_name: str, tag_value: str, **kwargs: Any) -> JSON:
        """Creates a predefined value for a predefined tag name.

        This operation allows adding a value to the list of predefined values for an existing
        predefined tag name. A tag value can have a maximum of 256 characters.

        :param tag_name: The name of the tag. Required.
        :type tag_name: str
        :param tag_value: The value of the tag to create. Required.
        :type tag_value: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "count": {
                        "type": "str",  # Optional. Type of count.
                        "value": 0  # Optional. Value of count.
                    },
                    "id": "str",  # Optional. The tag value ID.
                    "tagValue": "str"  # Optional. The tag value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_tags_create_or_update_value_request(
            tag_name=tag_name,
            tag_value=tag_value,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def create_or_update(self, tag_name: str, **kwargs: Any) -> JSON:
        """Creates a predefined tag name.

        This operation allows adding a name to the list of predefined tag names for the given
        subscription. A tag name can have a maximum of 512 characters and is case-insensitive. Tag
        names cannot have the following prefixes which are reserved for Azure use: 'microsoft',
        'azure', 'windows'.

        :param tag_name: The name of the tag to create. Required.
        :type tag_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "count": {
                        "type": "str",  # Optional. Type of count.
                        "value": 0  # Optional. Value of count.
                    },
                    "id": "str",  # Optional. The tag name ID.
                    "tagName": "str",  # Optional. The tag name.
                    "values": [
                        {
                            "count": {
                                "type": "str",  # Optional. Type of count.
                                "value": 0  # Optional. Value of count.
                            },
                            "id": "str",  # Optional. The tag value ID.
                            "tagValue": "str"  # Optional. The tag value.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_tags_create_or_update_request(
            tag_name=tag_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, tag_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes a predefined tag name.

        This operation allows deleting a name from the list of predefined tag names for the given
        subscription. The name being deleted must not be in use as a tag name for any resource. All
        predefined values for the given name must have already been deleted.

        :param tag_name: The name of the tag. Required.
        :type tag_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_tags_delete_request(
            tag_name=tag_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """Gets a summary of tag usage under the subscription.

        This operation performs a union of predefined tags, resource tags, resource group tags and
        subscription tags, and returns a summary of usage for each tag name and value under the given
        subscription. In case of a large number of tags, this operation may return a previously cached
        result.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "count": {
                        "type": "str",  # Optional. Type of count.
                        "value": 0  # Optional. Value of count.
                    },
                    "id": "str",  # Optional. The tag name ID.
                    "tagName": "str",  # Optional. The tag name.
                    "values": [
                        {
                            "count": {
                                "type": "str",  # Optional. Type of count.
                                "value": 0  # Optional. Value of count.
                            },
                            "id": "str",  # Optional. The tag value ID.
                            "tagValue": "str"  # Optional. The tag value.
                        }
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_tags_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _create_or_update_at_scope_initial(
        self, scope: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_tags_create_or_update_at_scope_request(
            scope=scope,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_create_or_update_at_scope(
        self, scope: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates or updates the entire set of tags on a resource or subscription.

        This operation allows adding or replacing the entire set of tags on the specified resource or
        subscription. The specified entity can have a maximum of 50 tags.

        :param scope: The resource scope. Required.
        :type scope: str
        :param parameters: Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "tags": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "id": "str",  # Optional. The ID of the tags wrapper resource.
                    "name": "str",  # Optional. The name of the tags wrapper resource.
                    "type": "str"  # Optional. The type of the tags wrapper resource.
                }

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "tags": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "id": "str",  # Optional. The ID of the tags wrapper resource.
                    "name": "str",  # Optional. The name of the tags wrapper resource.
                    "type": "str"  # Optional. The type of the tags wrapper resource.
                }
        """

    @overload
    def begin_create_or_update_at_scope(
        self, scope: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates or updates the entire set of tags on a resource or subscription.

        This operation allows adding or replacing the entire set of tags on the specified resource or
        subscription. The specified entity can have a maximum of 50 tags.

        :param scope: The resource scope. Required.
        :type scope: str
        :param parameters: Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "tags": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "id": "str",  # Optional. The ID of the tags wrapper resource.
                    "name": "str",  # Optional. The name of the tags wrapper resource.
                    "type": "str"  # Optional. The type of the tags wrapper resource.
                }
        """

    @distributed_trace
    def begin_create_or_update_at_scope(
        self, scope: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates or updates the entire set of tags on a resource or subscription.

        This operation allows adding or replacing the entire set of tags on the specified resource or
        subscription. The specified entity can have a maximum of 50 tags.

        :param scope: The resource scope. Required.
        :type scope: str
        :param parameters: Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "tags": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "id": "str",  # Optional. The ID of the tags wrapper resource.
                    "name": "str",  # Optional. The name of the tags wrapper resource.
                    "type": "str"  # Optional. The type of the tags wrapper resource.
                }

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "tags": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "id": "str",  # Optional. The ID of the tags wrapper resource.
                    "name": "str",  # Optional. The name of the tags wrapper resource.
                    "type": "str"  # Optional. The type of the tags wrapper resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_at_scope_initial(
                scope=scope,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_at_scope_initial(self, scope: str, parameters: Union[JSON, IO], **kwargs: Any) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_tags_update_at_scope_request(
            scope=scope,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update_at_scope(
        self, scope: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Selectively updates the set of tags on a resource or subscription.

        This operation allows replacing, merging or selectively deleting tags on the specified resource
        or subscription. The specified entity can have a maximum of 50 tags at the end of the
        operation. The 'replace' option replaces the entire set of existing tags with a new set. The
        'merge' option allows adding tags with new names and updating the values of tags with existing
        names. The 'delete' option allows selectively deleting tags based on given names or name/value
        pairs.

        :param scope: The resource scope. Required.
        :type scope: str
        :param parameters: Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "operation": "str",  # Optional. The operation type for the patch API. Known
                      values are: "Replace", "Merge", and "Delete".
                    "properties": {
                        "tags": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "tags": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "id": "str",  # Optional. The ID of the tags wrapper resource.
                    "name": "str",  # Optional. The name of the tags wrapper resource.
                    "type": "str"  # Optional. The type of the tags wrapper resource.
                }
        """

    @overload
    def begin_update_at_scope(
        self, scope: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Selectively updates the set of tags on a resource or subscription.

        This operation allows replacing, merging or selectively deleting tags on the specified resource
        or subscription. The specified entity can have a maximum of 50 tags at the end of the
        operation. The 'replace' option replaces the entire set of existing tags with a new set. The
        'merge' option allows adding tags with new names and updating the values of tags with existing
        names. The 'delete' option allows selectively deleting tags based on given names or name/value
        pairs.

        :param scope: The resource scope. Required.
        :type scope: str
        :param parameters: Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "tags": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "id": "str",  # Optional. The ID of the tags wrapper resource.
                    "name": "str",  # Optional. The name of the tags wrapper resource.
                    "type": "str"  # Optional. The type of the tags wrapper resource.
                }
        """

    @distributed_trace
    def begin_update_at_scope(self, scope: str, parameters: Union[JSON, IO], **kwargs: Any) -> LROPoller[JSON]:
        """Selectively updates the set of tags on a resource or subscription.

        This operation allows replacing, merging or selectively deleting tags on the specified resource
        or subscription. The specified entity can have a maximum of 50 tags at the end of the
        operation. The 'replace' option replaces the entire set of existing tags with a new set. The
        'merge' option allows adding tags with new names and updating the values of tags with existing
        names. The 'delete' option allows selectively deleting tags based on given names or name/value
        pairs.

        :param scope: The resource scope. Required.
        :type scope: str
        :param parameters: Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "operation": "str",  # Optional. The operation type for the patch API. Known
                      values are: "Replace", "Merge", and "Delete".
                    "properties": {
                        "tags": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    }
                }

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "tags": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "id": "str",  # Optional. The ID of the tags wrapper resource.
                    "name": "str",  # Optional. The name of the tags wrapper resource.
                    "type": "str"  # Optional. The type of the tags wrapper resource.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_at_scope_initial(
                scope=scope,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_at_scope(self, scope: str, **kwargs: Any) -> JSON:
        """Gets the entire set of tags on a resource or subscription.

        Gets the entire set of tags on a resource or subscription.

        :param scope: The resource scope. Required.
        :type scope: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "tags": {
                            "str": "str"  # Optional. Dictionary of :code:`<string>`.
                        }
                    },
                    "id": "str",  # Optional. The ID of the tags wrapper resource.
                    "name": "str",  # Optional. The name of the tags wrapper resource.
                    "type": "str"  # Optional. The type of the tags wrapper resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_tags_get_at_scope_request(
            scope=scope,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _delete_at_scope_initial(  # pylint: disable=inconsistent-return-statements
        self, scope: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_tags_delete_at_scope_request(
            scope=scope,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete_at_scope(self, scope: str, **kwargs: Any) -> LROPoller[None]:
        """Deletes the entire set of tags on a resource or subscription.

        Deletes the entire set of tags on a resource or subscription.

        :param scope: The resource scope. Required.
        :type scope: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_at_scope_initial(  # type: ignore
                scope=scope, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class DeploymentOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~resources.mgmt.ResourceManagementClient`'s
        :attr:`deployment_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_at_scope(self, scope: str, deployment_name: str, operation_id: str, **kwargs: Any) -> JSON:
        """Gets a deployments operation.

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param operation_id: The ID of the operation to get. Required.
        :type operation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Full deployment operation ID.
                    "operationId": "str",  # Optional. Deployment operation ID.
                    "properties": {
                        "duration": "str",  # Optional. The duration of the operation.
                        "provisioningOperation": "str",  # Optional. The name of the current
                          provisioning operation. Known values are: "NotSpecified", "Create", "Delete",
                          "Waiting", "AzureAsyncOperationWaiting", "ResourceCacheWaiting", "Action",
                          "Read", "EvaluateDeploymentOutput", and "DeploymentCleanup".
                        "provisioningState": "str",  # Optional. The state of the
                          provisioning.
                        "request": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "response": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "serviceRequestId": "str",  # Optional. Deployment operation service
                          request id.
                        "statusCode": "str",  # Optional. Operation status code from the
                          resource provider. This property may not be set if a response has not yet
                          been received.
                        "statusMessage": {
                            "error": {
                                "additionalInfo": [
                                    {
                                        "info": {},  # Optional. The
                                          additional info.
                                        "type": "str"  # Optional. The
                                          additional info type.
                                    }
                                ],
                                "code": "str",  # Optional. The error code.
                                "details": [
                                    ...
                                ],
                                "message": "str",  # Optional. The error message.
                                "target": "str"  # Optional. The error target.
                            },
                            "status": "str"  # Optional. Status of the deployment
                              operation.
                        },
                        "targetResource": {
                            "id": "str",  # Optional. The ID of the resource.
                            "resourceName": "str",  # Optional. The name of the resource.
                            "resourceType": "str"  # Optional. The type of the resource.
                        },
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The date and time of
                          the operation.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployment_operations_get_at_scope_request(
            scope=scope,
            deployment_name=deployment_name,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_at_scope(
        self, scope: str, deployment_name: str, *, top: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets all deployments operations for a deployment.

        :param scope: The resource scope. Required.
        :type scope: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :keyword top: The number of results to return. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Full deployment operation ID.
                    "operationId": "str",  # Optional. Deployment operation ID.
                    "properties": {
                        "duration": "str",  # Optional. The duration of the operation.
                        "provisioningOperation": "str",  # Optional. The name of the current
                          provisioning operation. Known values are: "NotSpecified", "Create", "Delete",
                          "Waiting", "AzureAsyncOperationWaiting", "ResourceCacheWaiting", "Action",
                          "Read", "EvaluateDeploymentOutput", and "DeploymentCleanup".
                        "provisioningState": "str",  # Optional. The state of the
                          provisioning.
                        "request": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "response": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "serviceRequestId": "str",  # Optional. Deployment operation service
                          request id.
                        "statusCode": "str",  # Optional. Operation status code from the
                          resource provider. This property may not be set if a response has not yet
                          been received.
                        "statusMessage": {
                            "error": {
                                "additionalInfo": [
                                    {
                                        "info": {},  # Optional. The
                                          additional info.
                                        "type": "str"  # Optional. The
                                          additional info type.
                                    }
                                ],
                                "code": "str",  # Optional. The error code.
                                "details": [
                                    ...
                                ],
                                "message": "str",  # Optional. The error message.
                                "target": "str"  # Optional. The error target.
                            },
                            "status": "str"  # Optional. Status of the deployment
                              operation.
                        },
                        "targetResource": {
                            "id": "str",  # Optional. The ID of the resource.
                            "resourceName": "str",  # Optional. The name of the resource.
                            "resourceType": "str"  # Optional. The type of the resource.
                        },
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The date and time of
                          the operation.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deployment_operations_list_at_scope_request(
                    scope=scope,
                    deployment_name=deployment_name,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_at_tenant_scope(self, deployment_name: str, operation_id: str, **kwargs: Any) -> JSON:
        """Gets a deployments operation.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param operation_id: The ID of the operation to get. Required.
        :type operation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Full deployment operation ID.
                    "operationId": "str",  # Optional. Deployment operation ID.
                    "properties": {
                        "duration": "str",  # Optional. The duration of the operation.
                        "provisioningOperation": "str",  # Optional. The name of the current
                          provisioning operation. Known values are: "NotSpecified", "Create", "Delete",
                          "Waiting", "AzureAsyncOperationWaiting", "ResourceCacheWaiting", "Action",
                          "Read", "EvaluateDeploymentOutput", and "DeploymentCleanup".
                        "provisioningState": "str",  # Optional. The state of the
                          provisioning.
                        "request": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "response": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "serviceRequestId": "str",  # Optional. Deployment operation service
                          request id.
                        "statusCode": "str",  # Optional. Operation status code from the
                          resource provider. This property may not be set if a response has not yet
                          been received.
                        "statusMessage": {
                            "error": {
                                "additionalInfo": [
                                    {
                                        "info": {},  # Optional. The
                                          additional info.
                                        "type": "str"  # Optional. The
                                          additional info type.
                                    }
                                ],
                                "code": "str",  # Optional. The error code.
                                "details": [
                                    ...
                                ],
                                "message": "str",  # Optional. The error message.
                                "target": "str"  # Optional. The error target.
                            },
                            "status": "str"  # Optional. Status of the deployment
                              operation.
                        },
                        "targetResource": {
                            "id": "str",  # Optional. The ID of the resource.
                            "resourceName": "str",  # Optional. The name of the resource.
                            "resourceType": "str"  # Optional. The type of the resource.
                        },
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The date and time of
                          the operation.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployment_operations_get_at_tenant_scope_request(
            deployment_name=deployment_name,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_at_tenant_scope(self, deployment_name: str, *, top: Optional[int] = None, **kwargs: Any) -> Iterable[JSON]:
        """Gets all deployments operations for a deployment.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :keyword top: The number of results to return. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Full deployment operation ID.
                    "operationId": "str",  # Optional. Deployment operation ID.
                    "properties": {
                        "duration": "str",  # Optional. The duration of the operation.
                        "provisioningOperation": "str",  # Optional. The name of the current
                          provisioning operation. Known values are: "NotSpecified", "Create", "Delete",
                          "Waiting", "AzureAsyncOperationWaiting", "ResourceCacheWaiting", "Action",
                          "Read", "EvaluateDeploymentOutput", and "DeploymentCleanup".
                        "provisioningState": "str",  # Optional. The state of the
                          provisioning.
                        "request": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "response": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "serviceRequestId": "str",  # Optional. Deployment operation service
                          request id.
                        "statusCode": "str",  # Optional. Operation status code from the
                          resource provider. This property may not be set if a response has not yet
                          been received.
                        "statusMessage": {
                            "error": {
                                "additionalInfo": [
                                    {
                                        "info": {},  # Optional. The
                                          additional info.
                                        "type": "str"  # Optional. The
                                          additional info type.
                                    }
                                ],
                                "code": "str",  # Optional. The error code.
                                "details": [
                                    ...
                                ],
                                "message": "str",  # Optional. The error message.
                                "target": "str"  # Optional. The error target.
                            },
                            "status": "str"  # Optional. Status of the deployment
                              operation.
                        },
                        "targetResource": {
                            "id": "str",  # Optional. The ID of the resource.
                            "resourceName": "str",  # Optional. The name of the resource.
                            "resourceType": "str"  # Optional. The type of the resource.
                        },
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The date and time of
                          the operation.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deployment_operations_list_at_tenant_scope_request(
                    deployment_name=deployment_name,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_at_management_group_scope(
        self, group_id: str, deployment_name: str, operation_id: str, **kwargs: Any
    ) -> JSON:
        """Gets a deployments operation.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param operation_id: The ID of the operation to get. Required.
        :type operation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Full deployment operation ID.
                    "operationId": "str",  # Optional. Deployment operation ID.
                    "properties": {
                        "duration": "str",  # Optional. The duration of the operation.
                        "provisioningOperation": "str",  # Optional. The name of the current
                          provisioning operation. Known values are: "NotSpecified", "Create", "Delete",
                          "Waiting", "AzureAsyncOperationWaiting", "ResourceCacheWaiting", "Action",
                          "Read", "EvaluateDeploymentOutput", and "DeploymentCleanup".
                        "provisioningState": "str",  # Optional. The state of the
                          provisioning.
                        "request": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "response": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "serviceRequestId": "str",  # Optional. Deployment operation service
                          request id.
                        "statusCode": "str",  # Optional. Operation status code from the
                          resource provider. This property may not be set if a response has not yet
                          been received.
                        "statusMessage": {
                            "error": {
                                "additionalInfo": [
                                    {
                                        "info": {},  # Optional. The
                                          additional info.
                                        "type": "str"  # Optional. The
                                          additional info type.
                                    }
                                ],
                                "code": "str",  # Optional. The error code.
                                "details": [
                                    ...
                                ],
                                "message": "str",  # Optional. The error message.
                                "target": "str"  # Optional. The error target.
                            },
                            "status": "str"  # Optional. Status of the deployment
                              operation.
                        },
                        "targetResource": {
                            "id": "str",  # Optional. The ID of the resource.
                            "resourceName": "str",  # Optional. The name of the resource.
                            "resourceType": "str"  # Optional. The type of the resource.
                        },
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The date and time of
                          the operation.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployment_operations_get_at_management_group_scope_request(
            group_id=group_id,
            deployment_name=deployment_name,
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_at_management_group_scope(
        self, group_id: str, deployment_name: str, *, top: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets all deployments operations for a deployment.

        :param group_id: The management group ID. Required.
        :type group_id: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :keyword top: The number of results to return. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Full deployment operation ID.
                    "operationId": "str",  # Optional. Deployment operation ID.
                    "properties": {
                        "duration": "str",  # Optional. The duration of the operation.
                        "provisioningOperation": "str",  # Optional. The name of the current
                          provisioning operation. Known values are: "NotSpecified", "Create", "Delete",
                          "Waiting", "AzureAsyncOperationWaiting", "ResourceCacheWaiting", "Action",
                          "Read", "EvaluateDeploymentOutput", and "DeploymentCleanup".
                        "provisioningState": "str",  # Optional. The state of the
                          provisioning.
                        "request": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "response": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "serviceRequestId": "str",  # Optional. Deployment operation service
                          request id.
                        "statusCode": "str",  # Optional. Operation status code from the
                          resource provider. This property may not be set if a response has not yet
                          been received.
                        "statusMessage": {
                            "error": {
                                "additionalInfo": [
                                    {
                                        "info": {},  # Optional. The
                                          additional info.
                                        "type": "str"  # Optional. The
                                          additional info type.
                                    }
                                ],
                                "code": "str",  # Optional. The error code.
                                "details": [
                                    ...
                                ],
                                "message": "str",  # Optional. The error message.
                                "target": "str"  # Optional. The error target.
                            },
                            "status": "str"  # Optional. Status of the deployment
                              operation.
                        },
                        "targetResource": {
                            "id": "str",  # Optional. The ID of the resource.
                            "resourceName": "str",  # Optional. The name of the resource.
                            "resourceType": "str"  # Optional. The type of the resource.
                        },
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The date and time of
                          the operation.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deployment_operations_list_at_management_group_scope_request(
                    group_id=group_id,
                    deployment_name=deployment_name,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_at_subscription_scope(self, deployment_name: str, operation_id: str, **kwargs: Any) -> JSON:
        """Gets a deployments operation.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param operation_id: The ID of the operation to get. Required.
        :type operation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Full deployment operation ID.
                    "operationId": "str",  # Optional. Deployment operation ID.
                    "properties": {
                        "duration": "str",  # Optional. The duration of the operation.
                        "provisioningOperation": "str",  # Optional. The name of the current
                          provisioning operation. Known values are: "NotSpecified", "Create", "Delete",
                          "Waiting", "AzureAsyncOperationWaiting", "ResourceCacheWaiting", "Action",
                          "Read", "EvaluateDeploymentOutput", and "DeploymentCleanup".
                        "provisioningState": "str",  # Optional. The state of the
                          provisioning.
                        "request": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "response": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "serviceRequestId": "str",  # Optional. Deployment operation service
                          request id.
                        "statusCode": "str",  # Optional. Operation status code from the
                          resource provider. This property may not be set if a response has not yet
                          been received.
                        "statusMessage": {
                            "error": {
                                "additionalInfo": [
                                    {
                                        "info": {},  # Optional. The
                                          additional info.
                                        "type": "str"  # Optional. The
                                          additional info type.
                                    }
                                ],
                                "code": "str",  # Optional. The error code.
                                "details": [
                                    ...
                                ],
                                "message": "str",  # Optional. The error message.
                                "target": "str"  # Optional. The error target.
                            },
                            "status": "str"  # Optional. Status of the deployment
                              operation.
                        },
                        "targetResource": {
                            "id": "str",  # Optional. The ID of the resource.
                            "resourceName": "str",  # Optional. The name of the resource.
                            "resourceType": "str"  # Optional. The type of the resource.
                        },
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The date and time of
                          the operation.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployment_operations_get_at_subscription_scope_request(
            deployment_name=deployment_name,
            operation_id=operation_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_at_subscription_scope(
        self, deployment_name: str, *, top: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets all deployments operations for a deployment.

        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :keyword top: The number of results to return. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Full deployment operation ID.
                    "operationId": "str",  # Optional. Deployment operation ID.
                    "properties": {
                        "duration": "str",  # Optional. The duration of the operation.
                        "provisioningOperation": "str",  # Optional. The name of the current
                          provisioning operation. Known values are: "NotSpecified", "Create", "Delete",
                          "Waiting", "AzureAsyncOperationWaiting", "ResourceCacheWaiting", "Action",
                          "Read", "EvaluateDeploymentOutput", and "DeploymentCleanup".
                        "provisioningState": "str",  # Optional. The state of the
                          provisioning.
                        "request": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "response": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "serviceRequestId": "str",  # Optional. Deployment operation service
                          request id.
                        "statusCode": "str",  # Optional. Operation status code from the
                          resource provider. This property may not be set if a response has not yet
                          been received.
                        "statusMessage": {
                            "error": {
                                "additionalInfo": [
                                    {
                                        "info": {},  # Optional. The
                                          additional info.
                                        "type": "str"  # Optional. The
                                          additional info type.
                                    }
                                ],
                                "code": "str",  # Optional. The error code.
                                "details": [
                                    ...
                                ],
                                "message": "str",  # Optional. The error message.
                                "target": "str"  # Optional. The error target.
                            },
                            "status": "str"  # Optional. Status of the deployment
                              operation.
                        },
                        "targetResource": {
                            "id": "str",  # Optional. The ID of the resource.
                            "resourceName": "str",  # Optional. The name of the resource.
                            "resourceType": "str"  # Optional. The type of the resource.
                        },
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The date and time of
                          the operation.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deployment_operations_list_at_subscription_scope_request(
                    deployment_name=deployment_name,
                    subscription_id=self._config.subscription_id,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, deployment_name: str, operation_id: str, **kwargs: Any) -> JSON:
        """Gets a deployments operation.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :param operation_id: The ID of the operation to get. Required.
        :type operation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Full deployment operation ID.
                    "operationId": "str",  # Optional. Deployment operation ID.
                    "properties": {
                        "duration": "str",  # Optional. The duration of the operation.
                        "provisioningOperation": "str",  # Optional. The name of the current
                          provisioning operation. Known values are: "NotSpecified", "Create", "Delete",
                          "Waiting", "AzureAsyncOperationWaiting", "ResourceCacheWaiting", "Action",
                          "Read", "EvaluateDeploymentOutput", and "DeploymentCleanup".
                        "provisioningState": "str",  # Optional. The state of the
                          provisioning.
                        "request": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "response": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "serviceRequestId": "str",  # Optional. Deployment operation service
                          request id.
                        "statusCode": "str",  # Optional. Operation status code from the
                          resource provider. This property may not be set if a response has not yet
                          been received.
                        "statusMessage": {
                            "error": {
                                "additionalInfo": [
                                    {
                                        "info": {},  # Optional. The
                                          additional info.
                                        "type": "str"  # Optional. The
                                          additional info type.
                                    }
                                ],
                                "code": "str",  # Optional. The error code.
                                "details": [
                                    ...
                                ],
                                "message": "str",  # Optional. The error message.
                                "target": "str"  # Optional. The error target.
                            },
                            "status": "str"  # Optional. Status of the deployment
                              operation.
                        },
                        "targetResource": {
                            "id": "str",  # Optional. The ID of the resource.
                            "resourceName": "str",  # Optional. The name of the resource.
                            "resourceType": "str"  # Optional. The type of the resource.
                        },
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The date and time of
                          the operation.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deployment_operations_get_request(
            resource_group_name=resource_group_name,
            deployment_name=deployment_name,
            operation_id=operation_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list(
        self, resource_group_name: str, deployment_name: str, *, top: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets all deployments operations for a deployment.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param deployment_name: The name of the deployment. Required.
        :type deployment_name: str
        :keyword top: The number of results to return. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Full deployment operation ID.
                    "operationId": "str",  # Optional. Deployment operation ID.
                    "properties": {
                        "duration": "str",  # Optional. The duration of the operation.
                        "provisioningOperation": "str",  # Optional. The name of the current
                          provisioning operation. Known values are: "NotSpecified", "Create", "Delete",
                          "Waiting", "AzureAsyncOperationWaiting", "ResourceCacheWaiting", "Action",
                          "Read", "EvaluateDeploymentOutput", and "DeploymentCleanup".
                        "provisioningState": "str",  # Optional. The state of the
                          provisioning.
                        "request": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "response": {
                            "content": {}  # Optional. HTTP message content.
                        },
                        "serviceRequestId": "str",  # Optional. Deployment operation service
                          request id.
                        "statusCode": "str",  # Optional. Operation status code from the
                          resource provider. This property may not be set if a response has not yet
                          been received.
                        "statusMessage": {
                            "error": {
                                "additionalInfo": [
                                    {
                                        "info": {},  # Optional. The
                                          additional info.
                                        "type": "str"  # Optional. The
                                          additional info type.
                                    }
                                ],
                                "code": "str",  # Optional. The error code.
                                "details": [
                                    ...
                                ],
                                "message": "str",  # Optional. The error message.
                                "target": "str"  # Optional. The error target.
                            },
                            "status": "str"  # Optional. Status of the deployment
                              operation.
                        },
                        "targetResource": {
                            "id": "str",  # Optional. The ID of the resource.
                            "resourceName": "str",  # Optional. The name of the resource.
                            "resourceType": "str"  # Optional. The type of the resource.
                        },
                        "timestamp": "2020-02-20 00:00:00"  # Optional. The date and time of
                          the operation.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deployment_operations_list_request(
                    resource_group_name=resource_group_name,
                    deployment_name=deployment_name,
                    subscription_id=self._config.subscription_id,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)
