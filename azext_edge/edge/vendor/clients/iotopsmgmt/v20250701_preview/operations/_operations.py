# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, Type, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.IoTOperations/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_list_by_subscription_request(  # pylint: disable=name-too-long
    subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.IoTOperations/instances"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances"
    )
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_get_request(
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_create_or_update_request(
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_update_request(
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_delete_request(
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_connector_template_list_by_instance_resource_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriConnectorTemplates"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_connector_template_get_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, akri_connector_template_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriConnectorTemplates/{akriConnectorTemplateName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "akriConnectorTemplateName": _SERIALIZER.url(
            "akri_connector_template_name",
            akri_connector_template_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_connector_template_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, akri_connector_template_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriConnectorTemplates/{akriConnectorTemplateName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "akriConnectorTemplateName": _SERIALIZER.url(
            "akri_connector_template_name",
            akri_connector_template_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_connector_template_delete_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, akri_connector_template_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriConnectorTemplates/{akriConnectorTemplateName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "akriConnectorTemplateName": _SERIALIZER.url(
            "akri_connector_template_name",
            akri_connector_template_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_connector_list_by_template_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, akri_connector_template_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriConnectorTemplates/{akriConnectorTemplateName}/connectors"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "akriConnectorTemplateName": _SERIALIZER.url(
            "akri_connector_template_name",
            akri_connector_template_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_connector_get_request(
    resource_group_name: str,
    instance_name: str,
    akri_connector_template_name: str,
    connector_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriConnectorTemplates/{akriConnectorTemplateName}/connectors/{connectorName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "akriConnectorTemplateName": _SERIALIZER.url(
            "akri_connector_template_name",
            akri_connector_template_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "connectorName": _SERIALIZER.url(
            "connector_name",
            connector_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_connector_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str,
    instance_name: str,
    akri_connector_template_name: str,
    connector_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriConnectorTemplates/{akriConnectorTemplateName}/connectors/{connectorName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "akriConnectorTemplateName": _SERIALIZER.url(
            "akri_connector_template_name",
            akri_connector_template_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "connectorName": _SERIALIZER.url(
            "connector_name",
            connector_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_connector_delete_request(
    resource_group_name: str,
    instance_name: str,
    akri_connector_template_name: str,
    connector_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriConnectorTemplates/{akriConnectorTemplateName}/connectors/{connectorName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "akriConnectorTemplateName": _SERIALIZER.url(
            "akri_connector_template_name",
            akri_connector_template_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "connectorName": _SERIALIZER.url(
            "connector_name",
            connector_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_discovery_handler_list_by_instance_resource_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriDiscoveryHandlers"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_discovery_handler_get_request(
    resource_group_name: str, instance_name: str, akri_discovery_handler_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriDiscoveryHandlers/{akriDiscoveryHandlerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "akriDiscoveryHandlerName": _SERIALIZER.url(
            "akri_discovery_handler_name",
            akri_discovery_handler_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_discovery_handler_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, akri_discovery_handler_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriDiscoveryHandlers/{akriDiscoveryHandlerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "akriDiscoveryHandlerName": _SERIALIZER.url(
            "akri_discovery_handler_name",
            akri_discovery_handler_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_akri_discovery_handler_delete_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, akri_discovery_handler_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/akriDiscoveryHandlers/{akriDiscoveryHandlerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "akriDiscoveryHandlerName": _SERIALIZER.url(
            "akri_discovery_handler_name",
            akri_discovery_handler_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_get_request(
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_create_or_update_request(
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_delete_request(
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authentication_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authentications"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authentication_get_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authentication_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authentications/{authenticationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authenticationName": _SERIALIZER.url(
            "authentication_name",
            authentication_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authentication_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authentication_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authentications/{authenticationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authenticationName": _SERIALIZER.url(
            "authentication_name",
            authentication_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authentication_delete_request(  # pylint: disable=name-too-long
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authentication_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authentications/{authenticationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authenticationName": _SERIALIZER.url(
            "authentication_name",
            authentication_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authorization_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authorizations"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authorization_get_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authorization_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authorizations/{authorizationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authorizationName": _SERIALIZER.url(
            "authorization_name",
            authorization_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authorization_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authorization_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authorizations/{authorizationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authorizationName": _SERIALIZER.url(
            "authorization_name",
            authorization_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authorization_delete_request(  # pylint: disable=name-too-long
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authorization_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authorizations/{authorizationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authorizationName": _SERIALIZER.url(
            "authorization_name",
            authorization_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_listener_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/listeners"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_listener_get_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    listener_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/listeners/{listenerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "listenerName": _SERIALIZER.url(
            "listener_name", listener_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_listener_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    listener_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/listeners/{listenerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "listenerName": _SERIALIZER.url(
            "listener_name", listener_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_listener_delete_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    listener_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/brokers/{brokerName}/listeners/{listenerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "listenerName": _SERIALIZER.url(
            "listener_name", listener_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_endpoint_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowEndpoints"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_endpoint_get_request(
    resource_group_name: str, instance_name: str, dataflow_endpoint_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowEndpoints/{dataflowEndpointName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowEndpointName": _SERIALIZER.url(
            "dataflow_endpoint_name",
            dataflow_endpoint_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_endpoint_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, dataflow_endpoint_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowEndpoints/{dataflowEndpointName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowEndpointName": _SERIALIZER.url(
            "dataflow_endpoint_name",
            dataflow_endpoint_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_endpoint_delete_request(
    resource_group_name: str, instance_name: str, dataflow_endpoint_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowEndpoints/{dataflowEndpointName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowEndpointName": _SERIALIZER.url(
            "dataflow_endpoint_name",
            dataflow_endpoint_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_profile_list_by_resource_group_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_profile_get_request(
    resource_group_name: str, instance_name: str, dataflow_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles/{dataflowProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowProfileName": _SERIALIZER.url(
            "dataflow_profile_name",
            dataflow_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_profile_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, dataflow_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles/{dataflowProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowProfileName": _SERIALIZER.url(
            "dataflow_profile_name",
            dataflow_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_profile_delete_request(
    resource_group_name: str, instance_name: str, dataflow_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles/{dataflowProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowProfileName": _SERIALIZER.url(
            "dataflow_profile_name",
            dataflow_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_graph_list_by_dataflow_profile_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, dataflow_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles/{dataflowProfileName}/dataflowGraphs"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowProfileName": _SERIALIZER.url(
            "dataflow_profile_name",
            dataflow_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_graph_get_request(
    resource_group_name: str,
    instance_name: str,
    dataflow_profile_name: str,
    dataflow_graph_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles/{dataflowProfileName}/dataflowGraphs/{dataflowGraphName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowProfileName": _SERIALIZER.url(
            "dataflow_profile_name",
            dataflow_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "dataflowGraphName": _SERIALIZER.url(
            "dataflow_graph_name",
            dataflow_graph_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_graph_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str,
    instance_name: str,
    dataflow_profile_name: str,
    dataflow_graph_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles/{dataflowProfileName}/dataflowGraphs/{dataflowGraphName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowProfileName": _SERIALIZER.url(
            "dataflow_profile_name",
            dataflow_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "dataflowGraphName": _SERIALIZER.url(
            "dataflow_graph_name",
            dataflow_graph_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_graph_delete_request(
    resource_group_name: str,
    instance_name: str,
    dataflow_profile_name: str,
    dataflow_graph_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles/{dataflowProfileName}/dataflowGraphs/{dataflowGraphName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowProfileName": _SERIALIZER.url(
            "dataflow_profile_name",
            dataflow_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "dataflowGraphName": _SERIALIZER.url(
            "dataflow_graph_name",
            dataflow_graph_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_list_by_profile_resource_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, dataflow_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles/{dataflowProfileName}/dataflows"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowProfileName": _SERIALIZER.url(
            "dataflow_profile_name",
            dataflow_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_get_request(
    resource_group_name: str,
    instance_name: str,
    dataflow_profile_name: str,
    dataflow_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles/{dataflowProfileName}/dataflows/{dataflowName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowProfileName": _SERIALIZER.url(
            "dataflow_profile_name",
            dataflow_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "dataflowName": _SERIALIZER.url(
            "dataflow_name", dataflow_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_create_or_update_request(
    resource_group_name: str,
    instance_name: str,
    dataflow_profile_name: str,
    dataflow_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles/{dataflowProfileName}/dataflows/{dataflowName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowProfileName": _SERIALIZER.url(
            "dataflow_profile_name",
            dataflow_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "dataflowName": _SERIALIZER.url(
            "dataflow_name", dataflow_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_dataflow_delete_request(
    resource_group_name: str,
    instance_name: str,
    dataflow_profile_name: str,
    dataflow_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/dataflowProfiles/{dataflowProfileName}/dataflows/{dataflowName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "dataflowProfileName": _SERIALIZER.url(
            "dataflow_profile_name",
            dataflow_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "dataflowName": _SERIALIZER.url(
            "dataflow_name", dataflow_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_registry_endpoint_list_by_instance_resource_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/registryEndpoints"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_registry_endpoint_get_request(
    resource_group_name: str, instance_name: str, registry_endpoint_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/registryEndpoints/{registryEndpointName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "registryEndpointName": _SERIALIZER.url(
            "registry_endpoint_name",
            registry_endpoint_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_registry_endpoint_create_or_update_request(  # pylint: disable=name-too-long
    resource_group_name: str, instance_name: str, registry_endpoint_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/registryEndpoints/{registryEndpointName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "registryEndpointName": _SERIALIZER.url(
            "registry_endpoint_name",
            registry_endpoint_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_registry_endpoint_delete_request(
    resource_group_name: str, instance_name: str, registry_endpoint_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTOperations/instances/{instanceName}/registryEndpoints/{registryEndpointName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "registryEndpointName": _SERIALIZER.url(
            "registry_endpoint_name",
            registry_endpoint_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List the operations for the provider.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actionType": "str",  # Optional. Enum. Indicates the action type. "Internal"
                      refers to actions that are for internal only APIs. "Internal"
                    "display": {
                        "description": "str",  # Optional. The short, localized friendly
                          description of the operation; suitable for tool tips and detailed views.
                        "operation": "str",  # Optional. The concise, localized friendly name
                          for the operation; suitable for dropdowns. E.g. "Create or Update Virtual
                          Machine", "Restart Virtual Machine".
                        "provider": "str",  # Optional. The localized friendly form of the
                          resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft
                          Compute".
                        "resource": "str"  # Optional. The localized friendly name of the
                          resource type related to this operation. E.g. "Virtual Machines" or "Job
                          Schedule Collections".
                    },
                    "isDataAction": bool,  # Optional. Whether the operation applies to
                      data-plane. This is "true" for data-plane operations and "false" for
                      ARM/control-plane operations.
                    "name": "str",  # Optional. The name of the operation, as per Resource-Based
                      Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write",
                      "Microsoft.Compute/virtualMachines/capture/action".
                    "origin": "str"  # Optional. The intended executor of the operation; as in
                      Resource Based Access Control (RBAC) and audit logs UX. Default value is
                      "user,system". Known values are: "user", "system", and "user,system".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class InstanceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`instance` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List InstanceResource resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaRegistryRef": {
                            "resourceId": "str"  # The resource ID of the Schema
                              Registry. Required.
                        },
                        "adrNamespaceRef": {
                            "resourceId": "str"  # The resource ID of the Azure Device
                              Registry Namespace. Required.
                        },
                        "defaultSecretProviderClassRef": {
                            "resourceId": "str"  # The resource ID of the AIO Secret
                              provider class. Required.
                        },
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "features": {
                            "str": {
                                "mode": "str",  # Optional. The state of the feature.
                                  Known values are: "Stable", "Preview", and "Disabled".
                                "settings": {
                                    "str": "str"  # Optional. The settings of the
                                      feature.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_instance_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List InstanceResource resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaRegistryRef": {
                            "resourceId": "str"  # The resource ID of the Schema
                              Registry. Required.
                        },
                        "adrNamespaceRef": {
                            "resourceId": "str"  # The resource ID of the Azure Device
                              Registry Namespace. Required.
                        },
                        "defaultSecretProviderClassRef": {
                            "resourceId": "str"  # The resource ID of the AIO Secret
                              provider class. Required.
                        },
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "features": {
                            "str": {
                                "mode": "str",  # Optional. The state of the feature.
                                  Known values are: "Stable", "Preview", and "Disabled".
                                "settings": {
                                    "str": "str"  # Optional. The settings of the
                                      feature.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_instance_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, instance_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaRegistryRef": {
                            "resourceId": "str"  # The resource ID of the Schema
                              Registry. Required.
                        },
                        "adrNamespaceRef": {
                            "resourceId": "str"  # The resource ID of the Azure Device
                              Registry Namespace. Required.
                        },
                        "defaultSecretProviderClassRef": {
                            "resourceId": "str"  # The resource ID of the AIO Secret
                              provider class. Required.
                        },
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "features": {
                            "str": {
                                "mode": "str",  # Optional. The state of the feature.
                                  Known values are: "Stable", "Preview", and "Disabled".
                                "settings": {
                                    "str": "str"  # Optional. The settings of the
                                      feature.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_instance_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self, resource_group_name: str, instance_name: str, resource: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_instance_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaRegistryRef": {
                            "resourceId": "str"  # The resource ID of the Schema
                              Registry. Required.
                        },
                        "adrNamespaceRef": {
                            "resourceId": "str"  # The resource ID of the Azure Device
                              Registry Namespace. Required.
                        },
                        "defaultSecretProviderClassRef": {
                            "resourceId": "str"  # The resource ID of the AIO Secret
                              provider class. Required.
                        },
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "features": {
                            "str": {
                                "mode": "str",  # Optional. The state of the feature.
                                  Known values are: "Stable", "Preview", and "Disabled".
                                "settings": {
                                    "str": "str"  # Optional. The settings of the
                                      feature.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaRegistryRef": {
                            "resourceId": "str"  # The resource ID of the Schema
                              Registry. Required.
                        },
                        "adrNamespaceRef": {
                            "resourceId": "str"  # The resource ID of the Azure Device
                              Registry Namespace. Required.
                        },
                        "defaultSecretProviderClassRef": {
                            "resourceId": "str"  # The resource ID of the AIO Secret
                              provider class. Required.
                        },
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "features": {
                            "str": {
                                "mode": "str",  # Optional. The state of the feature.
                                  Known values are: "Stable", "Preview", and "Disabled".
                                "settings": {
                                    "str": "str"  # Optional. The settings of the
                                      feature.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaRegistryRef": {
                            "resourceId": "str"  # The resource ID of the Schema
                              Registry. Required.
                        },
                        "adrNamespaceRef": {
                            "resourceId": "str"  # The resource ID of the Azure Device
                              Registry Namespace. Required.
                        },
                        "defaultSecretProviderClassRef": {
                            "resourceId": "str"  # The resource ID of the AIO Secret
                              provider class. Required.
                        },
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "features": {
                            "str": {
                                "mode": "str",  # Optional. The state of the feature.
                                  Known values are: "Stable", "Preview", and "Disabled".
                                "settings": {
                                    "str": "str"  # Optional. The settings of the
                                      feature.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self, resource_group_name: str, instance_name: str, resource: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaRegistryRef": {
                            "resourceId": "str"  # The resource ID of the Schema
                              Registry. Required.
                        },
                        "adrNamespaceRef": {
                            "resourceId": "str"  # The resource ID of the Azure Device
                              Registry Namespace. Required.
                        },
                        "defaultSecretProviderClassRef": {
                            "resourceId": "str"  # The resource ID of the AIO Secret
                              provider class. Required.
                        },
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "features": {
                            "str": {
                                "mode": "str",  # Optional. The state of the feature.
                                  Known values are: "Stable", "Preview", and "Disabled".
                                "settings": {
                                    "str": "str"  # Optional. The settings of the
                                      feature.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaRegistryRef": {
                            "resourceId": "str"  # The resource ID of the Schema
                              Registry. Required.
                        },
                        "adrNamespaceRef": {
                            "resourceId": "str"  # The resource ID of the Azure Device
                              Registry Namespace. Required.
                        },
                        "defaultSecretProviderClassRef": {
                            "resourceId": "str"  # The resource ID of the AIO Secret
                              provider class. Required.
                        },
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "features": {
                            "str": {
                                "mode": "str",  # Optional. The state of the feature.
                                  Known values are: "Stable", "Preview", and "Disabled".
                                "settings": {
                                    "str": "str"  # Optional. The settings of the
                                      feature.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Update a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaRegistryRef": {
                            "resourceId": "str"  # The resource ID of the Schema
                              Registry. Required.
                        },
                        "adrNamespaceRef": {
                            "resourceId": "str"  # The resource ID of the Azure Device
                              Registry Namespace. Required.
                        },
                        "defaultSecretProviderClassRef": {
                            "resourceId": "str"  # The resource ID of the AIO Secret
                              provider class. Required.
                        },
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "features": {
                            "str": {
                                "mode": "str",  # Optional. The state of the feature.
                                  Known values are: "Stable", "Preview", and "Disabled".
                                "settings": {
                                    "str": "str"  # Optional. The settings of the
                                      feature.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        properties: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Update a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaRegistryRef": {
                            "resourceId": "str"  # The resource ID of the Schema
                              Registry. Required.
                        },
                        "adrNamespaceRef": {
                            "resourceId": "str"  # The resource ID of the Azure Device
                              Registry Namespace. Required.
                        },
                        "defaultSecretProviderClassRef": {
                            "resourceId": "str"  # The resource ID of the AIO Secret
                              provider class. Required.
                        },
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "features": {
                            "str": {
                                "mode": "str",  # Optional. The state of the feature.
                                  Known values are: "Stable", "Preview", and "Disabled".
                                "settings": {
                                    "str": "str"  # Optional. The settings of the
                                      feature.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def update(
        self, resource_group_name: str, instance_name: str, properties: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Update a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO[bytes]
         type. Required.
        :type properties: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (where both
                          SystemAssigned and UserAssigned types are allowed). Required. Known values
                          are: "None", "SystemAssigned", "UserAssigned", and
                          "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str",  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  assigned identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the assigned identity.
                            }
                        }
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaRegistryRef": {
                            "resourceId": "str"  # The resource ID of the Schema
                              Registry. Required.
                        },
                        "adrNamespaceRef": {
                            "resourceId": "str"  # The resource ID of the Azure Device
                              Registry Namespace. Required.
                        },
                        "defaultSecretProviderClassRef": {
                            "resourceId": "str"  # The resource ID of the AIO Secret
                              provider class. Required.
                        },
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "features": {
                            "str": {
                                "mode": "str",  # Optional. The state of the feature.
                                  Known values are: "Stable", "Preview", and "Disabled".
                                "settings": {
                                    "str": "str"  # Optional. The settings of the
                                      feature.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        _request = build_instance_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_instance_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(self, resource_group_name: str, instance_name: str, **kwargs: Any) -> LROPoller[None]:
        """Delete a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class AkriConnectorTemplateOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`akri_connector_template` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_instance_resource(self, resource_group_name: str, instance_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List AkriConnectorTemplateResource resources by InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "runtimeConfigurationType":

                # JSON input template for discriminator value "HelmConfiguration":
                akri_connector_template_runtime_configuration = {
                    "helmConfigurationSettings": {
                        "releaseName": "str",  # The release name of the Helm chart.
                          Required.
                        "repositoryName": "str",  # The name of the repository. Required.
                        "version": "str",  # The version of the Helm chart. Required.
                        "advancedConfiguration": {
                            "delete": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "install": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "upgrade": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            }
                        },
                        "registrySettings": akri_connector_template_helm_registry_settings,
                        "values": {
                            "str": "str"  # Optional. A map of values to pass to the helm
                              chart.
                        }
                    },
                    "runtimeConfigurationType": "HelmConfiguration"
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connector_template_helm_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The registry to use for the Helm chart.
                          Required.
                        "authSecretRef": {
                            "passwordKey": "str",  # The key of the password in the
                              secret. Required.
                            "secretRef": "str",  # The name of the secret. Required.
                            "usernameKey": "str"  # The key of the username in the
                              secret. Required.
                        }
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connector_template_helm_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "ManagedConfiguration":
                akri_connector_template_runtime_configuration = {
                    "managedConfigurationSettings":
                      akri_connector_template_managed_configuration_settings,
                    "runtimeConfigurationType": "ManagedConfiguration"
                }

                # JSON input template for discriminator value "ImageConfiguration":
                akri_connector_template_managed_configuration_settings = {
                    "imageConfigurationSettings": {
                        "imageName": "str",  # The image name without any registry reference,
                          tag or digest. Required.
                        "imagePullPolicy": "str",  # Optional. The pull policy of the image.
                          Known values are: "Always", "IfNotPresent", and "Never".
                        "registrySettings": akri_connectors_registry_settings,
                        "replicas": 0,  # Optional. The number of replicas to be set up.
                        "tagDigestSettings": akri_connectors_tag_digest_settings
                    },
                    "managedConfigurationType": "ImageConfiguration",
                    "additionalConfiguration": {
                        "str": "str"  # Optional. Additional configuration for the image of
                          the managed configuration.
                    },
                    "allocation": akri_connector_template_allocation,
                    "persistentVolumeClaimTemplates": [
                        {
                            "str": {}  # Optional. The persistent volume claim templates
                              for the managed configuration. See
                              https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
                        }
                    ],
                    "persistentVolumeClaims": [
                        {
                            "claimName": "str",  # The name of the persistent volume
                              claim. Required.
                            "mountPath": "str"  # The mount path for the persistent
                              volume claim. Required.
                        }
                    ],
                    "secrets": [
                        {
                            "secretAlias": "str",  # The application-defined alias for
                              the secret. Required.
                            "secretKey": "str",  # The key in the secret to be mounted.
                              Required.
                            "secretRef": "str"  # The name of the secret to be mounted.
                              Required.
                        }
                    ],
                    "trustSettings": {
                        "trustListSecretRef": "str"  # The secret reference for certificates
                          to trust. Required.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceInboundEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the device
                                  inbound endpoint. Required.
                                "version": "str",  # The version of the device
                                  inbound endpoint. Required.
                                "configurationSchemaRefs": {
                                    "additionalConfigSchemaRef": "str",  #
                                      Optional. The additional configuration schema reference.
                                    "defaultDatasetConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for
                                      datasets.
                                    "defaultEventsConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for events.
                                    "defaultProcessControlConfigSchemaRef":
                                      "str",  # Optional. The default configuration schema reference
                                      for process control.
                                    "defaultStreamsConfigSchemaRef": "str"  #
                                      Optional. The default configuration schema reference for streams.
                                },
                                "description": "str"  # Optional. A description of
                                  the device inbound endpoint.
                            }
                        ],
                        "runtimeConfiguration":
                          akri_connector_template_runtime_configuration,
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_akri_connector_template_list_by_instance_resource_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self, resource_group_name: str, instance_name: str, akri_connector_template_name: str, **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get a AkriConnectorTemplateResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_connector_template_name: Name of AkriConnectorTemplate resource. Required.
        :type akri_connector_template_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "runtimeConfigurationType":

                # JSON input template for discriminator value "HelmConfiguration":
                akri_connector_template_runtime_configuration = {
                    "helmConfigurationSettings": {
                        "releaseName": "str",  # The release name of the Helm chart.
                          Required.
                        "repositoryName": "str",  # The name of the repository. Required.
                        "version": "str",  # The version of the Helm chart. Required.
                        "advancedConfiguration": {
                            "delete": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "install": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "upgrade": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            }
                        },
                        "registrySettings": akri_connector_template_helm_registry_settings,
                        "values": {
                            "str": "str"  # Optional. A map of values to pass to the helm
                              chart.
                        }
                    },
                    "runtimeConfigurationType": "HelmConfiguration"
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connector_template_helm_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The registry to use for the Helm chart.
                          Required.
                        "authSecretRef": {
                            "passwordKey": "str",  # The key of the password in the
                              secret. Required.
                            "secretRef": "str",  # The name of the secret. Required.
                            "usernameKey": "str"  # The key of the username in the
                              secret. Required.
                        }
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connector_template_helm_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "ManagedConfiguration":
                akri_connector_template_runtime_configuration = {
                    "managedConfigurationSettings":
                      akri_connector_template_managed_configuration_settings,
                    "runtimeConfigurationType": "ManagedConfiguration"
                }

                # JSON input template for discriminator value "ImageConfiguration":
                akri_connector_template_managed_configuration_settings = {
                    "imageConfigurationSettings": {
                        "imageName": "str",  # The image name without any registry reference,
                          tag or digest. Required.
                        "imagePullPolicy": "str",  # Optional. The pull policy of the image.
                          Known values are: "Always", "IfNotPresent", and "Never".
                        "registrySettings": akri_connectors_registry_settings,
                        "replicas": 0,  # Optional. The number of replicas to be set up.
                        "tagDigestSettings": akri_connectors_tag_digest_settings
                    },
                    "managedConfigurationType": "ImageConfiguration",
                    "additionalConfiguration": {
                        "str": "str"  # Optional. Additional configuration for the image of
                          the managed configuration.
                    },
                    "allocation": akri_connector_template_allocation,
                    "persistentVolumeClaimTemplates": [
                        {
                            "str": {}  # Optional. The persistent volume claim templates
                              for the managed configuration. See
                              https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
                        }
                    ],
                    "persistentVolumeClaims": [
                        {
                            "claimName": "str",  # The name of the persistent volume
                              claim. Required.
                            "mountPath": "str"  # The mount path for the persistent
                              volume claim. Required.
                        }
                    ],
                    "secrets": [
                        {
                            "secretAlias": "str",  # The application-defined alias for
                              the secret. Required.
                            "secretKey": "str",  # The key in the secret to be mounted.
                              Required.
                            "secretRef": "str"  # The name of the secret to be mounted.
                              Required.
                        }
                    ],
                    "trustSettings": {
                        "trustListSecretRef": "str"  # The secret reference for certificates
                          to trust. Required.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceInboundEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the device
                                  inbound endpoint. Required.
                                "version": "str",  # The version of the device
                                  inbound endpoint. Required.
                                "configurationSchemaRefs": {
                                    "additionalConfigSchemaRef": "str",  #
                                      Optional. The additional configuration schema reference.
                                    "defaultDatasetConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for
                                      datasets.
                                    "defaultEventsConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for events.
                                    "defaultProcessControlConfigSchemaRef":
                                      "str",  # Optional. The default configuration schema reference
                                      for process control.
                                    "defaultStreamsConfigSchemaRef": "str"  #
                                      Optional. The default configuration schema reference for streams.
                                },
                                "description": "str"  # Optional. A description of
                                  the device inbound endpoint.
                            }
                        ],
                        "runtimeConfiguration":
                          akri_connector_template_runtime_configuration,
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_akri_connector_template_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            akri_connector_template_name=akri_connector_template_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_connector_template_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_akri_connector_template_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            akri_connector_template_name=akri_connector_template_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_connector_template_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a AkriConnectorTemplateResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_connector_template_name: Name of AkriConnectorTemplate resource. Required.
        :type akri_connector_template_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "runtimeConfigurationType":

                # JSON input template for discriminator value "HelmConfiguration":
                akri_connector_template_runtime_configuration = {
                    "helmConfigurationSettings": {
                        "releaseName": "str",  # The release name of the Helm chart.
                          Required.
                        "repositoryName": "str",  # The name of the repository. Required.
                        "version": "str",  # The version of the Helm chart. Required.
                        "advancedConfiguration": {
                            "delete": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "install": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "upgrade": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            }
                        },
                        "registrySettings": akri_connector_template_helm_registry_settings,
                        "values": {
                            "str": "str"  # Optional. A map of values to pass to the helm
                              chart.
                        }
                    },
                    "runtimeConfigurationType": "HelmConfiguration"
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connector_template_helm_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The registry to use for the Helm chart.
                          Required.
                        "authSecretRef": {
                            "passwordKey": "str",  # The key of the password in the
                              secret. Required.
                            "secretRef": "str",  # The name of the secret. Required.
                            "usernameKey": "str"  # The key of the username in the
                              secret. Required.
                        }
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connector_template_helm_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "ManagedConfiguration":
                akri_connector_template_runtime_configuration = {
                    "managedConfigurationSettings":
                      akri_connector_template_managed_configuration_settings,
                    "runtimeConfigurationType": "ManagedConfiguration"
                }

                # JSON input template for discriminator value "ImageConfiguration":
                akri_connector_template_managed_configuration_settings = {
                    "imageConfigurationSettings": {
                        "imageName": "str",  # The image name without any registry reference,
                          tag or digest. Required.
                        "imagePullPolicy": "str",  # Optional. The pull policy of the image.
                          Known values are: "Always", "IfNotPresent", and "Never".
                        "registrySettings": akri_connectors_registry_settings,
                        "replicas": 0,  # Optional. The number of replicas to be set up.
                        "tagDigestSettings": akri_connectors_tag_digest_settings
                    },
                    "managedConfigurationType": "ImageConfiguration",
                    "additionalConfiguration": {
                        "str": "str"  # Optional. Additional configuration for the image of
                          the managed configuration.
                    },
                    "allocation": akri_connector_template_allocation,
                    "persistentVolumeClaimTemplates": [
                        {
                            "str": {}  # Optional. The persistent volume claim templates
                              for the managed configuration. See
                              https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
                        }
                    ],
                    "persistentVolumeClaims": [
                        {
                            "claimName": "str",  # The name of the persistent volume
                              claim. Required.
                            "mountPath": "str"  # The mount path for the persistent
                              volume claim. Required.
                        }
                    ],
                    "secrets": [
                        {
                            "secretAlias": "str",  # The application-defined alias for
                              the secret. Required.
                            "secretKey": "str",  # The key in the secret to be mounted.
                              Required.
                            "secretRef": "str"  # The name of the secret to be mounted.
                              Required.
                        }
                    ],
                    "trustSettings": {
                        "trustListSecretRef": "str"  # The secret reference for certificates
                          to trust. Required.
                    }
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceInboundEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the device
                                  inbound endpoint. Required.
                                "version": "str",  # The version of the device
                                  inbound endpoint. Required.
                                "configurationSchemaRefs": {
                                    "additionalConfigSchemaRef": "str",  #
                                      Optional. The additional configuration schema reference.
                                    "defaultDatasetConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for
                                      datasets.
                                    "defaultEventsConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for events.
                                    "defaultProcessControlConfigSchemaRef":
                                      "str",  # Optional. The default configuration schema reference
                                      for process control.
                                    "defaultStreamsConfigSchemaRef": "str"  #
                                      Optional. The default configuration schema reference for streams.
                                },
                                "description": "str"  # Optional. A description of
                                  the device inbound endpoint.
                            }
                        ],
                        "runtimeConfiguration":
                          akri_connector_template_runtime_configuration,
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "runtimeConfigurationType":

                # JSON input template for discriminator value "HelmConfiguration":
                akri_connector_template_runtime_configuration = {
                    "helmConfigurationSettings": {
                        "releaseName": "str",  # The release name of the Helm chart.
                          Required.
                        "repositoryName": "str",  # The name of the repository. Required.
                        "version": "str",  # The version of the Helm chart. Required.
                        "advancedConfiguration": {
                            "delete": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "install": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "upgrade": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            }
                        },
                        "registrySettings": akri_connector_template_helm_registry_settings,
                        "values": {
                            "str": "str"  # Optional. A map of values to pass to the helm
                              chart.
                        }
                    },
                    "runtimeConfigurationType": "HelmConfiguration"
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connector_template_helm_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The registry to use for the Helm chart.
                          Required.
                        "authSecretRef": {
                            "passwordKey": "str",  # The key of the password in the
                              secret. Required.
                            "secretRef": "str",  # The name of the secret. Required.
                            "usernameKey": "str"  # The key of the username in the
                              secret. Required.
                        }
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connector_template_helm_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "ManagedConfiguration":
                akri_connector_template_runtime_configuration = {
                    "managedConfigurationSettings":
                      akri_connector_template_managed_configuration_settings,
                    "runtimeConfigurationType": "ManagedConfiguration"
                }

                # JSON input template for discriminator value "ImageConfiguration":
                akri_connector_template_managed_configuration_settings = {
                    "imageConfigurationSettings": {
                        "imageName": "str",  # The image name without any registry reference,
                          tag or digest. Required.
                        "imagePullPolicy": "str",  # Optional. The pull policy of the image.
                          Known values are: "Always", "IfNotPresent", and "Never".
                        "registrySettings": akri_connectors_registry_settings,
                        "replicas": 0,  # Optional. The number of replicas to be set up.
                        "tagDigestSettings": akri_connectors_tag_digest_settings
                    },
                    "managedConfigurationType": "ImageConfiguration",
                    "additionalConfiguration": {
                        "str": "str"  # Optional. Additional configuration for the image of
                          the managed configuration.
                    },
                    "allocation": akri_connector_template_allocation,
                    "persistentVolumeClaimTemplates": [
                        {
                            "str": {}  # Optional. The persistent volume claim templates
                              for the managed configuration. See
                              https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
                        }
                    ],
                    "persistentVolumeClaims": [
                        {
                            "claimName": "str",  # The name of the persistent volume
                              claim. Required.
                            "mountPath": "str"  # The mount path for the persistent
                              volume claim. Required.
                        }
                    ],
                    "secrets": [
                        {
                            "secretAlias": "str",  # The application-defined alias for
                              the secret. Required.
                            "secretKey": "str",  # The key in the secret to be mounted.
                              Required.
                            "secretRef": "str"  # The name of the secret to be mounted.
                              Required.
                        }
                    ],
                    "trustSettings": {
                        "trustListSecretRef": "str"  # The secret reference for certificates
                          to trust. Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "runtimeConfigurationType":

                # JSON input template for discriminator value "HelmConfiguration":
                akri_connector_template_runtime_configuration = {
                    "helmConfigurationSettings": {
                        "releaseName": "str",  # The release name of the Helm chart.
                          Required.
                        "repositoryName": "str",  # The name of the repository. Required.
                        "version": "str",  # The version of the Helm chart. Required.
                        "advancedConfiguration": {
                            "delete": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "install": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "upgrade": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            }
                        },
                        "registrySettings": akri_connector_template_helm_registry_settings,
                        "values": {
                            "str": "str"  # Optional. A map of values to pass to the helm
                              chart.
                        }
                    },
                    "runtimeConfigurationType": "HelmConfiguration"
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connector_template_helm_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The registry to use for the Helm chart.
                          Required.
                        "authSecretRef": {
                            "passwordKey": "str",  # The key of the password in the
                              secret. Required.
                            "secretRef": "str",  # The name of the secret. Required.
                            "usernameKey": "str"  # The key of the username in the
                              secret. Required.
                        }
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connector_template_helm_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "ManagedConfiguration":
                akri_connector_template_runtime_configuration = {
                    "managedConfigurationSettings":
                      akri_connector_template_managed_configuration_settings,
                    "runtimeConfigurationType": "ManagedConfiguration"
                }

                # JSON input template for discriminator value "ImageConfiguration":
                akri_connector_template_managed_configuration_settings = {
                    "imageConfigurationSettings": {
                        "imageName": "str",  # The image name without any registry reference,
                          tag or digest. Required.
                        "imagePullPolicy": "str",  # Optional. The pull policy of the image.
                          Known values are: "Always", "IfNotPresent", and "Never".
                        "registrySettings": akri_connectors_registry_settings,
                        "replicas": 0,  # Optional. The number of replicas to be set up.
                        "tagDigestSettings": akri_connectors_tag_digest_settings
                    },
                    "managedConfigurationType": "ImageConfiguration",
                    "additionalConfiguration": {
                        "str": "str"  # Optional. Additional configuration for the image of
                          the managed configuration.
                    },
                    "allocation": akri_connector_template_allocation,
                    "persistentVolumeClaimTemplates": [
                        {
                            "str": {}  # Optional. The persistent volume claim templates
                              for the managed configuration. See
                              https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
                        }
                    ],
                    "persistentVolumeClaims": [
                        {
                            "claimName": "str",  # The name of the persistent volume
                              claim. Required.
                            "mountPath": "str"  # The mount path for the persistent
                              volume claim. Required.
                        }
                    ],
                    "secrets": [
                        {
                            "secretAlias": "str",  # The application-defined alias for
                              the secret. Required.
                            "secretKey": "str",  # The key in the secret to be mounted.
                              Required.
                            "secretRef": "str"  # The name of the secret to be mounted.
                              Required.
                        }
                    ],
                    "trustSettings": {
                        "trustListSecretRef": "str"  # The secret reference for certificates
                          to trust. Required.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceInboundEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the device
                                  inbound endpoint. Required.
                                "version": "str",  # The version of the device
                                  inbound endpoint. Required.
                                "configurationSchemaRefs": {
                                    "additionalConfigSchemaRef": "str",  #
                                      Optional. The additional configuration schema reference.
                                    "defaultDatasetConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for
                                      datasets.
                                    "defaultEventsConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for events.
                                    "defaultProcessControlConfigSchemaRef":
                                      "str",  # Optional. The default configuration schema reference
                                      for process control.
                                    "defaultStreamsConfigSchemaRef": "str"  #
                                      Optional. The default configuration schema reference for streams.
                                },
                                "description": "str"  # Optional. A description of
                                  the device inbound endpoint.
                            }
                        ],
                        "runtimeConfiguration":
                          akri_connector_template_runtime_configuration,
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_connector_template_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a AkriConnectorTemplateResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_connector_template_name: Name of AkriConnectorTemplate resource. Required.
        :type akri_connector_template_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "runtimeConfigurationType":

                # JSON input template for discriminator value "HelmConfiguration":
                akri_connector_template_runtime_configuration = {
                    "helmConfigurationSettings": {
                        "releaseName": "str",  # The release name of the Helm chart.
                          Required.
                        "repositoryName": "str",  # The name of the repository. Required.
                        "version": "str",  # The version of the Helm chart. Required.
                        "advancedConfiguration": {
                            "delete": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "install": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "upgrade": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            }
                        },
                        "registrySettings": akri_connector_template_helm_registry_settings,
                        "values": {
                            "str": "str"  # Optional. A map of values to pass to the helm
                              chart.
                        }
                    },
                    "runtimeConfigurationType": "HelmConfiguration"
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connector_template_helm_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The registry to use for the Helm chart.
                          Required.
                        "authSecretRef": {
                            "passwordKey": "str",  # The key of the password in the
                              secret. Required.
                            "secretRef": "str",  # The name of the secret. Required.
                            "usernameKey": "str"  # The key of the username in the
                              secret. Required.
                        }
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connector_template_helm_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "ManagedConfiguration":
                akri_connector_template_runtime_configuration = {
                    "managedConfigurationSettings":
                      akri_connector_template_managed_configuration_settings,
                    "runtimeConfigurationType": "ManagedConfiguration"
                }

                # JSON input template for discriminator value "ImageConfiguration":
                akri_connector_template_managed_configuration_settings = {
                    "imageConfigurationSettings": {
                        "imageName": "str",  # The image name without any registry reference,
                          tag or digest. Required.
                        "imagePullPolicy": "str",  # Optional. The pull policy of the image.
                          Known values are: "Always", "IfNotPresent", and "Never".
                        "registrySettings": akri_connectors_registry_settings,
                        "replicas": 0,  # Optional. The number of replicas to be set up.
                        "tagDigestSettings": akri_connectors_tag_digest_settings
                    },
                    "managedConfigurationType": "ImageConfiguration",
                    "additionalConfiguration": {
                        "str": "str"  # Optional. Additional configuration for the image of
                          the managed configuration.
                    },
                    "allocation": akri_connector_template_allocation,
                    "persistentVolumeClaimTemplates": [
                        {
                            "str": {}  # Optional. The persistent volume claim templates
                              for the managed configuration. See
                              https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
                        }
                    ],
                    "persistentVolumeClaims": [
                        {
                            "claimName": "str",  # The name of the persistent volume
                              claim. Required.
                            "mountPath": "str"  # The mount path for the persistent
                              volume claim. Required.
                        }
                    ],
                    "secrets": [
                        {
                            "secretAlias": "str",  # The application-defined alias for
                              the secret. Required.
                            "secretKey": "str",  # The key in the secret to be mounted.
                              Required.
                            "secretRef": "str"  # The name of the secret to be mounted.
                              Required.
                        }
                    ],
                    "trustSettings": {
                        "trustListSecretRef": "str"  # The secret reference for certificates
                          to trust. Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "runtimeConfigurationType":

                # JSON input template for discriminator value "HelmConfiguration":
                akri_connector_template_runtime_configuration = {
                    "helmConfigurationSettings": {
                        "releaseName": "str",  # The release name of the Helm chart.
                          Required.
                        "repositoryName": "str",  # The name of the repository. Required.
                        "version": "str",  # The version of the Helm chart. Required.
                        "advancedConfiguration": {
                            "delete": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "install": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "upgrade": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            }
                        },
                        "registrySettings": akri_connector_template_helm_registry_settings,
                        "values": {
                            "str": "str"  # Optional. A map of values to pass to the helm
                              chart.
                        }
                    },
                    "runtimeConfigurationType": "HelmConfiguration"
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connector_template_helm_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The registry to use for the Helm chart.
                          Required.
                        "authSecretRef": {
                            "passwordKey": "str",  # The key of the password in the
                              secret. Required.
                            "secretRef": "str",  # The name of the secret. Required.
                            "usernameKey": "str"  # The key of the username in the
                              secret. Required.
                        }
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connector_template_helm_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "ManagedConfiguration":
                akri_connector_template_runtime_configuration = {
                    "managedConfigurationSettings":
                      akri_connector_template_managed_configuration_settings,
                    "runtimeConfigurationType": "ManagedConfiguration"
                }

                # JSON input template for discriminator value "ImageConfiguration":
                akri_connector_template_managed_configuration_settings = {
                    "imageConfigurationSettings": {
                        "imageName": "str",  # The image name without any registry reference,
                          tag or digest. Required.
                        "imagePullPolicy": "str",  # Optional. The pull policy of the image.
                          Known values are: "Always", "IfNotPresent", and "Never".
                        "registrySettings": akri_connectors_registry_settings,
                        "replicas": 0,  # Optional. The number of replicas to be set up.
                        "tagDigestSettings": akri_connectors_tag_digest_settings
                    },
                    "managedConfigurationType": "ImageConfiguration",
                    "additionalConfiguration": {
                        "str": "str"  # Optional. Additional configuration for the image of
                          the managed configuration.
                    },
                    "allocation": akri_connector_template_allocation,
                    "persistentVolumeClaimTemplates": [
                        {
                            "str": {}  # Optional. The persistent volume claim templates
                              for the managed configuration. See
                              https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
                        }
                    ],
                    "persistentVolumeClaims": [
                        {
                            "claimName": "str",  # The name of the persistent volume
                              claim. Required.
                            "mountPath": "str"  # The mount path for the persistent
                              volume claim. Required.
                        }
                    ],
                    "secrets": [
                        {
                            "secretAlias": "str",  # The application-defined alias for
                              the secret. Required.
                            "secretKey": "str",  # The key in the secret to be mounted.
                              Required.
                            "secretRef": "str"  # The name of the secret to be mounted.
                              Required.
                        }
                    ],
                    "trustSettings": {
                        "trustListSecretRef": "str"  # The secret reference for certificates
                          to trust. Required.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceInboundEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the device
                                  inbound endpoint. Required.
                                "version": "str",  # The version of the device
                                  inbound endpoint. Required.
                                "configurationSchemaRefs": {
                                    "additionalConfigSchemaRef": "str",  #
                                      Optional. The additional configuration schema reference.
                                    "defaultDatasetConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for
                                      datasets.
                                    "defaultEventsConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for events.
                                    "defaultProcessControlConfigSchemaRef":
                                      "str",  # Optional. The default configuration schema reference
                                      for process control.
                                    "defaultStreamsConfigSchemaRef": "str"  #
                                      Optional. The default configuration schema reference for streams.
                                },
                                "description": "str"  # Optional. A description of
                                  the device inbound endpoint.
                            }
                        ],
                        "runtimeConfiguration":
                          akri_connector_template_runtime_configuration,
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_connector_template_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a AkriConnectorTemplateResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_connector_template_name: Name of AkriConnectorTemplate resource. Required.
        :type akri_connector_template_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "runtimeConfigurationType":

                # JSON input template for discriminator value "HelmConfiguration":
                akri_connector_template_runtime_configuration = {
                    "helmConfigurationSettings": {
                        "releaseName": "str",  # The release name of the Helm chart.
                          Required.
                        "repositoryName": "str",  # The name of the repository. Required.
                        "version": "str",  # The version of the Helm chart. Required.
                        "advancedConfiguration": {
                            "delete": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "install": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "upgrade": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            }
                        },
                        "registrySettings": akri_connector_template_helm_registry_settings,
                        "values": {
                            "str": "str"  # Optional. A map of values to pass to the helm
                              chart.
                        }
                    },
                    "runtimeConfigurationType": "HelmConfiguration"
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connector_template_helm_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The registry to use for the Helm chart.
                          Required.
                        "authSecretRef": {
                            "passwordKey": "str",  # The key of the password in the
                              secret. Required.
                            "secretRef": "str",  # The name of the secret. Required.
                            "usernameKey": "str"  # The key of the username in the
                              secret. Required.
                        }
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connector_template_helm_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "ManagedConfiguration":
                akri_connector_template_runtime_configuration = {
                    "managedConfigurationSettings":
                      akri_connector_template_managed_configuration_settings,
                    "runtimeConfigurationType": "ManagedConfiguration"
                }

                # JSON input template for discriminator value "ImageConfiguration":
                akri_connector_template_managed_configuration_settings = {
                    "imageConfigurationSettings": {
                        "imageName": "str",  # The image name without any registry reference,
                          tag or digest. Required.
                        "imagePullPolicy": "str",  # Optional. The pull policy of the image.
                          Known values are: "Always", "IfNotPresent", and "Never".
                        "registrySettings": akri_connectors_registry_settings,
                        "replicas": 0,  # Optional. The number of replicas to be set up.
                        "tagDigestSettings": akri_connectors_tag_digest_settings
                    },
                    "managedConfigurationType": "ImageConfiguration",
                    "additionalConfiguration": {
                        "str": "str"  # Optional. Additional configuration for the image of
                          the managed configuration.
                    },
                    "allocation": akri_connector_template_allocation,
                    "persistentVolumeClaimTemplates": [
                        {
                            "str": {}  # Optional. The persistent volume claim templates
                              for the managed configuration. See
                              https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
                        }
                    ],
                    "persistentVolumeClaims": [
                        {
                            "claimName": "str",  # The name of the persistent volume
                              claim. Required.
                            "mountPath": "str"  # The mount path for the persistent
                              volume claim. Required.
                        }
                    ],
                    "secrets": [
                        {
                            "secretAlias": "str",  # The application-defined alias for
                              the secret. Required.
                            "secretKey": "str",  # The key in the secret to be mounted.
                              Required.
                            "secretRef": "str"  # The name of the secret to be mounted.
                              Required.
                        }
                    ],
                    "trustSettings": {
                        "trustListSecretRef": "str"  # The secret reference for certificates
                          to trust. Required.
                    }
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceInboundEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the device
                                  inbound endpoint. Required.
                                "version": "str",  # The version of the device
                                  inbound endpoint. Required.
                                "configurationSchemaRefs": {
                                    "additionalConfigSchemaRef": "str",  #
                                      Optional. The additional configuration schema reference.
                                    "defaultDatasetConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for
                                      datasets.
                                    "defaultEventsConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for events.
                                    "defaultProcessControlConfigSchemaRef":
                                      "str",  # Optional. The default configuration schema reference
                                      for process control.
                                    "defaultStreamsConfigSchemaRef": "str"  #
                                      Optional. The default configuration schema reference for streams.
                                },
                                "description": "str"  # Optional. A description of
                                  the device inbound endpoint.
                            }
                        ],
                        "runtimeConfiguration":
                          akri_connector_template_runtime_configuration,
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "runtimeConfigurationType":

                # JSON input template for discriminator value "HelmConfiguration":
                akri_connector_template_runtime_configuration = {
                    "helmConfigurationSettings": {
                        "releaseName": "str",  # The release name of the Helm chart.
                          Required.
                        "repositoryName": "str",  # The name of the repository. Required.
                        "version": "str",  # The version of the Helm chart. Required.
                        "advancedConfiguration": {
                            "delete": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "install": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "upgrade": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            }
                        },
                        "registrySettings": akri_connector_template_helm_registry_settings,
                        "values": {
                            "str": "str"  # Optional. A map of values to pass to the helm
                              chart.
                        }
                    },
                    "runtimeConfigurationType": "HelmConfiguration"
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connector_template_helm_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The registry to use for the Helm chart.
                          Required.
                        "authSecretRef": {
                            "passwordKey": "str",  # The key of the password in the
                              secret. Required.
                            "secretRef": "str",  # The name of the secret. Required.
                            "usernameKey": "str"  # The key of the username in the
                              secret. Required.
                        }
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connector_template_helm_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "ManagedConfiguration":
                akri_connector_template_runtime_configuration = {
                    "managedConfigurationSettings":
                      akri_connector_template_managed_configuration_settings,
                    "runtimeConfigurationType": "ManagedConfiguration"
                }

                # JSON input template for discriminator value "ImageConfiguration":
                akri_connector_template_managed_configuration_settings = {
                    "imageConfigurationSettings": {
                        "imageName": "str",  # The image name without any registry reference,
                          tag or digest. Required.
                        "imagePullPolicy": "str",  # Optional. The pull policy of the image.
                          Known values are: "Always", "IfNotPresent", and "Never".
                        "registrySettings": akri_connectors_registry_settings,
                        "replicas": 0,  # Optional. The number of replicas to be set up.
                        "tagDigestSettings": akri_connectors_tag_digest_settings
                    },
                    "managedConfigurationType": "ImageConfiguration",
                    "additionalConfiguration": {
                        "str": "str"  # Optional. Additional configuration for the image of
                          the managed configuration.
                    },
                    "allocation": akri_connector_template_allocation,
                    "persistentVolumeClaimTemplates": [
                        {
                            "str": {}  # Optional. The persistent volume claim templates
                              for the managed configuration. See
                              https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
                        }
                    ],
                    "persistentVolumeClaims": [
                        {
                            "claimName": "str",  # The name of the persistent volume
                              claim. Required.
                            "mountPath": "str"  # The mount path for the persistent
                              volume claim. Required.
                        }
                    ],
                    "secrets": [
                        {
                            "secretAlias": "str",  # The application-defined alias for
                              the secret. Required.
                            "secretKey": "str",  # The key in the secret to be mounted.
                              Required.
                            "secretRef": "str"  # The name of the secret to be mounted.
                              Required.
                        }
                    ],
                    "trustSettings": {
                        "trustListSecretRef": "str"  # The secret reference for certificates
                          to trust. Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "runtimeConfigurationType":

                # JSON input template for discriminator value "HelmConfiguration":
                akri_connector_template_runtime_configuration = {
                    "helmConfigurationSettings": {
                        "releaseName": "str",  # The release name of the Helm chart.
                          Required.
                        "repositoryName": "str",  # The name of the repository. Required.
                        "version": "str",  # The version of the Helm chart. Required.
                        "advancedConfiguration": {
                            "delete": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "install": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            },
                            "upgrade": {
                                "atomic": bool,  # Optional. Atomic flag for the
                                  operation.
                                "disableHooks": bool,  # Optional. Disable hooks flag
                                  for the operation.
                                "timeout": 0,  # Optional. The timeout for the
                                  operation in seconds.
                                "wait": bool,  # Optional. The wait flag for the
                                  operation.
                                "waitForJobs": bool  # Optional. The wait for jobs
                                  flag.
                            }
                        },
                        "registrySettings": akri_connector_template_helm_registry_settings,
                        "values": {
                            "str": "str"  # Optional. A map of values to pass to the helm
                              chart.
                        }
                    },
                    "runtimeConfigurationType": "HelmConfiguration"
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connector_template_helm_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The registry to use for the Helm chart.
                          Required.
                        "authSecretRef": {
                            "passwordKey": "str",  # The key of the password in the
                              secret. Required.
                            "secretRef": "str",  # The name of the secret. Required.
                            "usernameKey": "str"  # The key of the username in the
                              secret. Required.
                        }
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connector_template_helm_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "ManagedConfiguration":
                akri_connector_template_runtime_configuration = {
                    "managedConfigurationSettings":
                      akri_connector_template_managed_configuration_settings,
                    "runtimeConfigurationType": "ManagedConfiguration"
                }

                # JSON input template for discriminator value "ImageConfiguration":
                akri_connector_template_managed_configuration_settings = {
                    "imageConfigurationSettings": {
                        "imageName": "str",  # The image name without any registry reference,
                          tag or digest. Required.
                        "imagePullPolicy": "str",  # Optional. The pull policy of the image.
                          Known values are: "Always", "IfNotPresent", and "Never".
                        "registrySettings": akri_connectors_registry_settings,
                        "replicas": 0,  # Optional. The number of replicas to be set up.
                        "tagDigestSettings": akri_connectors_tag_digest_settings
                    },
                    "managedConfigurationType": "ImageConfiguration",
                    "additionalConfiguration": {
                        "str": "str"  # Optional. Additional configuration for the image of
                          the managed configuration.
                    },
                    "allocation": akri_connector_template_allocation,
                    "persistentVolumeClaimTemplates": [
                        {
                            "str": {}  # Optional. The persistent volume claim templates
                              for the managed configuration. See
                              https://raw.githubusercontent.com/kubernetes/kubernetes/refs/heads/master/api/openapi-spec/v3/apis__apps__v1_openapi.json.
                        }
                    ],
                    "persistentVolumeClaims": [
                        {
                            "claimName": "str",  # The name of the persistent volume
                              claim. Required.
                            "mountPath": "str"  # The mount path for the persistent
                              volume claim. Required.
                        }
                    ],
                    "secrets": [
                        {
                            "secretAlias": "str",  # The application-defined alias for
                              the secret. Required.
                            "secretKey": "str",  # The key in the secret to be mounted.
                              Required.
                            "secretRef": "str"  # The name of the secret to be mounted.
                              Required.
                        }
                    ],
                    "trustSettings": {
                        "trustListSecretRef": "str"  # The secret reference for certificates
                          to trust. Required.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceInboundEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the device
                                  inbound endpoint. Required.
                                "version": "str",  # The version of the device
                                  inbound endpoint. Required.
                                "configurationSchemaRefs": {
                                    "additionalConfigSchemaRef": "str",  #
                                      Optional. The additional configuration schema reference.
                                    "defaultDatasetConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for
                                      datasets.
                                    "defaultEventsConfigSchemaRef": "str",  #
                                      Optional. The default configuration schema reference for events.
                                    "defaultProcessControlConfigSchemaRef":
                                      "str",  # Optional. The default configuration schema reference
                                      for process control.
                                    "defaultStreamsConfigSchemaRef": "str"  #
                                      Optional. The default configuration schema reference for streams.
                                },
                                "description": "str"  # Optional. A description of
                                  the device inbound endpoint.
                            }
                        ],
                        "runtimeConfiguration":
                          akri_connector_template_runtime_configuration,
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                akri_connector_template_name=akri_connector_template_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, akri_connector_template_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_akri_connector_template_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            akri_connector_template_name=akri_connector_template_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, akri_connector_template_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a AkriConnectorTemplateResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_connector_template_name: Name of AkriConnectorTemplate resource. Required.
        :type akri_connector_template_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                akri_connector_template_name=akri_connector_template_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class AkriConnectorOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`akri_connector` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_template(
        self, resource_group_name: str, instance_name: str, akri_connector_template_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List AkriConnectorResource resources by AkriConnectorTemplateResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_connector_template_name: Name of AkriConnectorTemplate resource. Required.
        :type akri_connector_template_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_akri_connector_list_by_template_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    akri_connector_template_name=akri_connector_template_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_connector_template_name: str,
        connector_name: str,
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get a AkriConnectorResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_connector_template_name: Name of AkriConnectorTemplate resource. Required.
        :type akri_connector_template_name: str
        :param connector_name: Name of AkriConnector resource. Required.
        :type connector_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_akri_connector_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            akri_connector_template_name=akri_connector_template_name,
            connector_name=connector_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_connector_template_name: str,
        connector_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_akri_connector_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            akri_connector_template_name=akri_connector_template_name,
            connector_name=connector_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_connector_template_name: str,
        connector_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a AkriConnectorResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_connector_template_name: Name of AkriConnectorTemplate resource. Required.
        :type akri_connector_template_name: str
        :param connector_name: Name of AkriConnector resource. Required.
        :type connector_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_connector_template_name: str,
        connector_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a AkriConnectorResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_connector_template_name: Name of AkriConnectorTemplate resource. Required.
        :type akri_connector_template_name: str
        :param connector_name: Name of AkriConnector resource. Required.
        :type connector_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_connector_template_name: str,
        connector_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a AkriConnectorResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_connector_template_name: Name of AkriConnectorTemplate resource. Required.
        :type akri_connector_template_name: str
        :param connector_name: Name of AkriConnector resource. Required.
        :type connector_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                akri_connector_template_name=akri_connector_template_name,
                connector_name=connector_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        instance_name: str,
        akri_connector_template_name: str,
        connector_name: str,
        **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_akri_connector_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            akri_connector_template_name=akri_connector_template_name,
            connector_name=connector_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_connector_template_name: str,
        connector_name: str,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a AkriConnectorResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_connector_template_name: Name of AkriConnectorTemplate resource. Required.
        :type akri_connector_template_name: str
        :param connector_name: Name of AkriConnector resource. Required.
        :type connector_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                akri_connector_template_name=akri_connector_template_name,
                connector_name=connector_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class AkriDiscoveryHandlerOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`akri_discovery_handler` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_instance_resource(self, resource_group_name: str, instance_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List AkriDiscoveryHandlerResource resources by InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "ServiceAccountToken":
                akri_connectors_mqtt_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # The audience for the service account token.
                          Required.
                    }
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connectors_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The container registry to use for the artifact.
                          Required.
                        "imagePullSecrets": [
                            {
                                "secretRef": "str"  # The name of the image pull
                                  secret. Required.
                            }
                        ]
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connectors_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "Digest":
                akri_connectors_tag_digest_settings = {
                    "digest": "str",  # The digest of the image. Required.
                    "tagDigestType": "Digest"
                }

                # JSON input template for discriminator value "Tag":
                akri_connectors_tag_digest_settings = {
                    "tag": "str",  # The tag of the image. Required.
                    "tagDigestType": "Tag"
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoverableDeviceEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the endpoint.
                                  Required.
                                "version": "str"  # The version of the endpoint.
                                  Required.
                            }
                        ],
                        "imageConfiguration": {
                            "imageName": "str",  # The image name without any registry
                              reference, tag or digest. Required.
                            "imagePullPolicy": "str",  # Optional. The pull policy of the
                              image. Known values are: "Always", "IfNotPresent", and "Never".
                            "registrySettings": akri_connectors_registry_settings,
                            "replicas": 0,  # Optional. The number of replicas to be set
                              up.
                            "tagDigestSettings": akri_connectors_tag_digest_settings
                        },
                        "schedule": akri_discovery_handler_schedule,
                        "additionalConfiguration": {
                            "str": "str"  # Optional. Additional configuration for the
                              AkriDiscoveryHandler.
                        },
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mode": "str",  # Optional. Mode of the AkriDiscoveryHandler. Known
                          values are: "Enabled" and "Disabled".
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "secrets": [
                            {
                                "secretAlias": "str",  # The application-defined
                                  alias for the secret. Required.
                                "secretKey": "str",  # The key in the secret to be
                                  mounted. Required.
                                "secretRef": "str"  # The name of the secret to be
                                  mounted. Required.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_akri_discovery_handler_list_by_instance_resource_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self, resource_group_name: str, instance_name: str, akri_discovery_handler_name: str, **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get a AkriDiscoveryHandlerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_discovery_handler_name: Name of AkriDiscoveryHandler resource. Required.
        :type akri_discovery_handler_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "ServiceAccountToken":
                akri_connectors_mqtt_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # The audience for the service account token.
                          Required.
                    }
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connectors_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The container registry to use for the artifact.
                          Required.
                        "imagePullSecrets": [
                            {
                                "secretRef": "str"  # The name of the image pull
                                  secret. Required.
                            }
                        ]
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connectors_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "Digest":
                akri_connectors_tag_digest_settings = {
                    "digest": "str",  # The digest of the image. Required.
                    "tagDigestType": "Digest"
                }

                # JSON input template for discriminator value "Tag":
                akri_connectors_tag_digest_settings = {
                    "tag": "str",  # The tag of the image. Required.
                    "tagDigestType": "Tag"
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoverableDeviceEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the endpoint.
                                  Required.
                                "version": "str"  # The version of the endpoint.
                                  Required.
                            }
                        ],
                        "imageConfiguration": {
                            "imageName": "str",  # The image name without any registry
                              reference, tag or digest. Required.
                            "imagePullPolicy": "str",  # Optional. The pull policy of the
                              image. Known values are: "Always", "IfNotPresent", and "Never".
                            "registrySettings": akri_connectors_registry_settings,
                            "replicas": 0,  # Optional. The number of replicas to be set
                              up.
                            "tagDigestSettings": akri_connectors_tag_digest_settings
                        },
                        "schedule": akri_discovery_handler_schedule,
                        "additionalConfiguration": {
                            "str": "str"  # Optional. Additional configuration for the
                              AkriDiscoveryHandler.
                        },
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mode": "str",  # Optional. Mode of the AkriDiscoveryHandler. Known
                          values are: "Enabled" and "Disabled".
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "secrets": [
                            {
                                "secretAlias": "str",  # The application-defined
                                  alias for the secret. Required.
                                "secretKey": "str",  # The key in the secret to be
                                  mounted. Required.
                                "secretRef": "str"  # The name of the secret to be
                                  mounted. Required.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_akri_discovery_handler_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            akri_discovery_handler_name=akri_discovery_handler_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_discovery_handler_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_akri_discovery_handler_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            akri_discovery_handler_name=akri_discovery_handler_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_discovery_handler_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a AkriDiscoveryHandlerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_discovery_handler_name: Name of AkriDiscoveryHandler resource. Required.
        :type akri_discovery_handler_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "method":

                # JSON input template for discriminator value "ServiceAccountToken":
                akri_connectors_mqtt_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # The audience for the service account token.
                          Required.
                    }
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connectors_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The container registry to use for the artifact.
                          Required.
                        "imagePullSecrets": [
                            {
                                "secretRef": "str"  # The name of the image pull
                                  secret. Required.
                            }
                        ]
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connectors_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "Digest":
                akri_connectors_tag_digest_settings = {
                    "digest": "str",  # The digest of the image. Required.
                    "tagDigestType": "Digest"
                }

                # JSON input template for discriminator value "Tag":
                akri_connectors_tag_digest_settings = {
                    "tag": "str",  # The tag of the image. Required.
                    "tagDigestType": "Tag"
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoverableDeviceEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the endpoint.
                                  Required.
                                "version": "str"  # The version of the endpoint.
                                  Required.
                            }
                        ],
                        "imageConfiguration": {
                            "imageName": "str",  # The image name without any registry
                              reference, tag or digest. Required.
                            "imagePullPolicy": "str",  # Optional. The pull policy of the
                              image. Known values are: "Always", "IfNotPresent", and "Never".
                            "registrySettings": akri_connectors_registry_settings,
                            "replicas": 0,  # Optional. The number of replicas to be set
                              up.
                            "tagDigestSettings": akri_connectors_tag_digest_settings
                        },
                        "schedule": akri_discovery_handler_schedule,
                        "additionalConfiguration": {
                            "str": "str"  # Optional. Additional configuration for the
                              AkriDiscoveryHandler.
                        },
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mode": "str",  # Optional. Mode of the AkriDiscoveryHandler. Known
                          values are: "Enabled" and "Disabled".
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "secrets": [
                            {
                                "secretAlias": "str",  # The application-defined
                                  alias for the secret. Required.
                                "secretKey": "str",  # The key in the secret to be
                                  mounted. Required.
                                "secretRef": "str"  # The name of the secret to be
                                  mounted. Required.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "ServiceAccountToken":
                akri_connectors_mqtt_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # The audience for the service account token.
                          Required.
                    }
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connectors_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The container registry to use for the artifact.
                          Required.
                        "imagePullSecrets": [
                            {
                                "secretRef": "str"  # The name of the image pull
                                  secret. Required.
                            }
                        ]
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connectors_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "Digest":
                akri_connectors_tag_digest_settings = {
                    "digest": "str",  # The digest of the image. Required.
                    "tagDigestType": "Digest"
                }

                # JSON input template for discriminator value "Tag":
                akri_connectors_tag_digest_settings = {
                    "tag": "str",  # The tag of the image. Required.
                    "tagDigestType": "Tag"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "ServiceAccountToken":
                akri_connectors_mqtt_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # The audience for the service account token.
                          Required.
                    }
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connectors_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The container registry to use for the artifact.
                          Required.
                        "imagePullSecrets": [
                            {
                                "secretRef": "str"  # The name of the image pull
                                  secret. Required.
                            }
                        ]
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connectors_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "Digest":
                akri_connectors_tag_digest_settings = {
                    "digest": "str",  # The digest of the image. Required.
                    "tagDigestType": "Digest"
                }

                # JSON input template for discriminator value "Tag":
                akri_connectors_tag_digest_settings = {
                    "tag": "str",  # The tag of the image. Required.
                    "tagDigestType": "Tag"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoverableDeviceEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the endpoint.
                                  Required.
                                "version": "str"  # The version of the endpoint.
                                  Required.
                            }
                        ],
                        "imageConfiguration": {
                            "imageName": "str",  # The image name without any registry
                              reference, tag or digest. Required.
                            "imagePullPolicy": "str",  # Optional. The pull policy of the
                              image. Known values are: "Always", "IfNotPresent", and "Never".
                            "registrySettings": akri_connectors_registry_settings,
                            "replicas": 0,  # Optional. The number of replicas to be set
                              up.
                            "tagDigestSettings": akri_connectors_tag_digest_settings
                        },
                        "schedule": akri_discovery_handler_schedule,
                        "additionalConfiguration": {
                            "str": "str"  # Optional. Additional configuration for the
                              AkriDiscoveryHandler.
                        },
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mode": "str",  # Optional. Mode of the AkriDiscoveryHandler. Known
                          values are: "Enabled" and "Disabled".
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "secrets": [
                            {
                                "secretAlias": "str",  # The application-defined
                                  alias for the secret. Required.
                                "secretKey": "str",  # The key in the secret to be
                                  mounted. Required.
                                "secretRef": "str"  # The name of the secret to be
                                  mounted. Required.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_discovery_handler_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a AkriDiscoveryHandlerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_discovery_handler_name: Name of AkriDiscoveryHandler resource. Required.
        :type akri_discovery_handler_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "ServiceAccountToken":
                akri_connectors_mqtt_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # The audience for the service account token.
                          Required.
                    }
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connectors_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The container registry to use for the artifact.
                          Required.
                        "imagePullSecrets": [
                            {
                                "secretRef": "str"  # The name of the image pull
                                  secret. Required.
                            }
                        ]
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connectors_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "Digest":
                akri_connectors_tag_digest_settings = {
                    "digest": "str",  # The digest of the image. Required.
                    "tagDigestType": "Digest"
                }

                # JSON input template for discriminator value "Tag":
                akri_connectors_tag_digest_settings = {
                    "tag": "str",  # The tag of the image. Required.
                    "tagDigestType": "Tag"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "ServiceAccountToken":
                akri_connectors_mqtt_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # The audience for the service account token.
                          Required.
                    }
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connectors_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The container registry to use for the artifact.
                          Required.
                        "imagePullSecrets": [
                            {
                                "secretRef": "str"  # The name of the image pull
                                  secret. Required.
                            }
                        ]
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connectors_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "Digest":
                akri_connectors_tag_digest_settings = {
                    "digest": "str",  # The digest of the image. Required.
                    "tagDigestType": "Digest"
                }

                # JSON input template for discriminator value "Tag":
                akri_connectors_tag_digest_settings = {
                    "tag": "str",  # The tag of the image. Required.
                    "tagDigestType": "Tag"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoverableDeviceEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the endpoint.
                                  Required.
                                "version": "str"  # The version of the endpoint.
                                  Required.
                            }
                        ],
                        "imageConfiguration": {
                            "imageName": "str",  # The image name without any registry
                              reference, tag or digest. Required.
                            "imagePullPolicy": "str",  # Optional. The pull policy of the
                              image. Known values are: "Always", "IfNotPresent", and "Never".
                            "registrySettings": akri_connectors_registry_settings,
                            "replicas": 0,  # Optional. The number of replicas to be set
                              up.
                            "tagDigestSettings": akri_connectors_tag_digest_settings
                        },
                        "schedule": akri_discovery_handler_schedule,
                        "additionalConfiguration": {
                            "str": "str"  # Optional. Additional configuration for the
                              AkriDiscoveryHandler.
                        },
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mode": "str",  # Optional. Mode of the AkriDiscoveryHandler. Known
                          values are: "Enabled" and "Disabled".
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "secrets": [
                            {
                                "secretAlias": "str",  # The application-defined
                                  alias for the secret. Required.
                                "secretKey": "str",  # The key in the secret to be
                                  mounted. Required.
                                "secretRef": "str"  # The name of the secret to be
                                  mounted. Required.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        akri_discovery_handler_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a AkriDiscoveryHandlerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_discovery_handler_name: Name of AkriDiscoveryHandler resource. Required.
        :type akri_discovery_handler_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "method":

                # JSON input template for discriminator value "ServiceAccountToken":
                akri_connectors_mqtt_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # The audience for the service account token.
                          Required.
                    }
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connectors_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The container registry to use for the artifact.
                          Required.
                        "imagePullSecrets": [
                            {
                                "secretRef": "str"  # The name of the image pull
                                  secret. Required.
                            }
                        ]
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connectors_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "Digest":
                akri_connectors_tag_digest_settings = {
                    "digest": "str",  # The digest of the image. Required.
                    "tagDigestType": "Digest"
                }

                # JSON input template for discriminator value "Tag":
                akri_connectors_tag_digest_settings = {
                    "tag": "str",  # The tag of the image. Required.
                    "tagDigestType": "Tag"
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoverableDeviceEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the endpoint.
                                  Required.
                                "version": "str"  # The version of the endpoint.
                                  Required.
                            }
                        ],
                        "imageConfiguration": {
                            "imageName": "str",  # The image name without any registry
                              reference, tag or digest. Required.
                            "imagePullPolicy": "str",  # Optional. The pull policy of the
                              image. Known values are: "Always", "IfNotPresent", and "Never".
                            "registrySettings": akri_connectors_registry_settings,
                            "replicas": 0,  # Optional. The number of replicas to be set
                              up.
                            "tagDigestSettings": akri_connectors_tag_digest_settings
                        },
                        "schedule": akri_discovery_handler_schedule,
                        "additionalConfiguration": {
                            "str": "str"  # Optional. Additional configuration for the
                              AkriDiscoveryHandler.
                        },
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mode": "str",  # Optional. Mode of the AkriDiscoveryHandler. Known
                          values are: "Enabled" and "Disabled".
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "secrets": [
                            {
                                "secretAlias": "str",  # The application-defined
                                  alias for the secret. Required.
                                "secretKey": "str",  # The key in the secret to be
                                  mounted. Required.
                                "secretRef": "str"  # The name of the secret to be
                                  mounted. Required.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "ServiceAccountToken":
                akri_connectors_mqtt_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # The audience for the service account token.
                          Required.
                    }
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connectors_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The container registry to use for the artifact.
                          Required.
                        "imagePullSecrets": [
                            {
                                "secretRef": "str"  # The name of the image pull
                                  secret. Required.
                            }
                        ]
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connectors_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "Digest":
                akri_connectors_tag_digest_settings = {
                    "digest": "str",  # The digest of the image. Required.
                    "tagDigestType": "Digest"
                }

                # JSON input template for discriminator value "Tag":
                akri_connectors_tag_digest_settings = {
                    "tag": "str",  # The tag of the image. Required.
                    "tagDigestType": "Tag"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "ServiceAccountToken":
                akri_connectors_mqtt_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # The audience for the service account token.
                          Required.
                    }
                }

                # JSON input template for discriminator value "ContainerRegistry":
                akri_connectors_registry_settings = {
                    "containerRegistrySettings": {
                        "registry": "str",  # The container registry to use for the artifact.
                          Required.
                        "imagePullSecrets": [
                            {
                                "secretRef": "str"  # The name of the image pull
                                  secret. Required.
                            }
                        ]
                    },
                    "registrySettingsType": "ContainerRegistry"
                }

                # JSON input template for discriminator value "RegistryEndpointRef":
                akri_connectors_registry_settings = {
                    "registryEndpointRef": "str",  # The name of the registry endpoint. Required.
                    "registrySettingsType": "RegistryEndpointRef"
                }

                # JSON input template for discriminator value "Digest":
                akri_connectors_tag_digest_settings = {
                    "digest": "str",  # The digest of the image. Required.
                    "tagDigestType": "Digest"
                }

                # JSON input template for discriminator value "Tag":
                akri_connectors_tag_digest_settings = {
                    "tag": "str",  # The tag of the image. Required.
                    "tagDigestType": "Tag"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoverableDeviceEndpointTypes": [
                            {
                                "endpointType": "str",  # The type of the endpoint.
                                  Required.
                                "version": "str"  # The version of the endpoint.
                                  Required.
                            }
                        ],
                        "imageConfiguration": {
                            "imageName": "str",  # The image name without any registry
                              reference, tag or digest. Required.
                            "imagePullPolicy": "str",  # Optional. The pull policy of the
                              image. Known values are: "Always", "IfNotPresent", and "Never".
                            "registrySettings": akri_connectors_registry_settings,
                            "replicas": 0,  # Optional. The number of replicas to be set
                              up.
                            "tagDigestSettings": akri_connectors_tag_digest_settings
                        },
                        "schedule": akri_discovery_handler_schedule,
                        "additionalConfiguration": {
                            "str": "str"  # Optional. Additional configuration for the
                              AkriDiscoveryHandler.
                        },
                        "aioMetadata": {
                            "aioMaxVersion": "str",  # Optional. The maximum version of
                              AIO required for the connector.
                            "aioMinVersion": "str"  # Optional. The minimum version of
                              AIO required for the connector.
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            }
                        },
                        "mode": "str",  # Optional. Mode of the AkriDiscoveryHandler. Known
                          values are: "Enabled" and "Disabled".
                        "mqttConnectionConfiguration": {
                            "authentication": akri_connectors_mqtt_authentication,
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`.
                            "keepAliveSeconds": 0,  # Optional. KeepAlive for connection
                              in seconds.
                            "maxInflightMessages": 0,  # Optional. The max number of
                              messages to keep in flight. For subscribe, this is the receive maximum.
                              For publish, this is the maximum number of messages to send before
                              waiting for an ack.
                            "protocol": "str",  # Optional. The protocol to use for the
                              connection. Currently only ``mqtt`` is supported. "Mqtt"
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "secrets": [
                            {
                                "secretAlias": "str",  # The application-defined
                                  alias for the secret. Required.
                                "secretKey": "str",  # The key in the secret to be
                                  mounted. Required.
                                "secretRef": "str"  # The name of the secret to be
                                  mounted. Required.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                akri_discovery_handler_name=akri_discovery_handler_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, akri_discovery_handler_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_akri_discovery_handler_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            akri_discovery_handler_name=akri_discovery_handler_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, akri_discovery_handler_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a AkriDiscoveryHandlerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param akri_discovery_handler_name: Name of AkriDiscoveryHandler resource. Required.
        :type akri_discovery_handler_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                akri_discovery_handler_name=akri_discovery_handler_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class BrokerOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`broker` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, instance_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List BrokerResource resources by InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "mode":

                # JSON input template for discriminator value "Custom":
                broker_retain_messages_policy = {
                    "mode": "Custom",
                    "retainSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerRetainMessagesCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "topics": [
                            "str"  # Optional. List of topics under which retained
                              messages would be persisted to disk. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_state_store_policy = {
                    "mode": "Custom",
                    "stateStoreSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the BrokerStateStoreCustomPolicy.
                              Required. Known values are: "Enabled" and "Disabled".
                        },
                        "stateStoreResources": [
                            {
                                "keyType": "str",  # The key to persist to disk.
                                  Required. Known values are: "Pattern", "String", and "Binary".
                                "keys": [
                                    "str"  # List of keys to persist to disk,
                                      required. Required.
                                ]
                            }
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_subscriber_queue_policy = {
                    "mode": "Custom",
                    "subscriberQueueSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerSubscriberQueueCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "subscriberClientIds": [
                            "str"  # Optional. List of client IDs of the subscribers,
                              wildcard * supported.
                        ],
                        "topics": [
                            "str"  # Optional. List of topics under which messages would
                              be persisted to disk for each subscriber. Wildcards # and + supported.
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxPacketSizeBytes": 0,  # Optional. Max message
                                  size for a packet in Bytes.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "persistence": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using persistentVolumeClaimSpec Then
                              this size is used as the request and limit sizes of that template. If a
                              PVC template isn't specified Then local-path provisioner is requested
                              with this size limit. Required. Required.
                            "dynamicSettings": {
                                "userPropertyKey": "str",  # The user property key to
                                  enable persistence. Required.
                                "userPropertyValue": "str"  # The user property value
                                  to enable persistence. Required.
                            },
                            "encryption": {
                                "mode": "str"  # Determines if encryption is enabled.
                                  Required. Known values are: "Enabled" and "Disabled".
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "retain": broker_retain_messages_policy,
                            "stateStore": broker_state_store_policy,
                            "subscriberQueue": broker_subscriber_queue_policy
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_broker_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "mode":

                # JSON input template for discriminator value "Custom":
                broker_retain_messages_policy = {
                    "mode": "Custom",
                    "retainSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerRetainMessagesCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "topics": [
                            "str"  # Optional. List of topics under which retained
                              messages would be persisted to disk. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_state_store_policy = {
                    "mode": "Custom",
                    "stateStoreSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the BrokerStateStoreCustomPolicy.
                              Required. Known values are: "Enabled" and "Disabled".
                        },
                        "stateStoreResources": [
                            {
                                "keyType": "str",  # The key to persist to disk.
                                  Required. Known values are: "Pattern", "String", and "Binary".
                                "keys": [
                                    "str"  # List of keys to persist to disk,
                                      required. Required.
                                ]
                            }
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_subscriber_queue_policy = {
                    "mode": "Custom",
                    "subscriberQueueSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerSubscriberQueueCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "subscriberClientIds": [
                            "str"  # Optional. List of client IDs of the subscribers,
                              wildcard * supported.
                        ],
                        "topics": [
                            "str"  # Optional. List of topics under which messages would
                              be persisted to disk for each subscriber. Wildcards # and + supported.
                        ]
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxPacketSizeBytes": 0,  # Optional. Max message
                                  size for a packet in Bytes.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "persistence": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using persistentVolumeClaimSpec Then
                              this size is used as the request and limit sizes of that template. If a
                              PVC template isn't specified Then local-path provisioner is requested
                              with this size limit. Required. Required.
                            "dynamicSettings": {
                                "userPropertyKey": "str",  # The user property key to
                                  enable persistence. Required.
                                "userPropertyValue": "str"  # The user property value
                                  to enable persistence. Required.
                            },
                            "encryption": {
                                "mode": "str"  # Determines if encryption is enabled.
                                  Required. Known values are: "Enabled" and "Disabled".
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "retain": broker_retain_messages_policy,
                            "stateStore": broker_state_store_policy,
                            "subscriberQueue": broker_subscriber_queue_policy
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_broker_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_broker_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "mode":

                # JSON input template for discriminator value "Custom":
                broker_retain_messages_policy = {
                    "mode": "Custom",
                    "retainSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerRetainMessagesCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "topics": [
                            "str"  # Optional. List of topics under which retained
                              messages would be persisted to disk. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_state_store_policy = {
                    "mode": "Custom",
                    "stateStoreSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the BrokerStateStoreCustomPolicy.
                              Required. Known values are: "Enabled" and "Disabled".
                        },
                        "stateStoreResources": [
                            {
                                "keyType": "str",  # The key to persist to disk.
                                  Required. Known values are: "Pattern", "String", and "Binary".
                                "keys": [
                                    "str"  # List of keys to persist to disk,
                                      required. Required.
                                ]
                            }
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_subscriber_queue_policy = {
                    "mode": "Custom",
                    "subscriberQueueSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerSubscriberQueueCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "subscriberClientIds": [
                            "str"  # Optional. List of client IDs of the subscribers,
                              wildcard * supported.
                        ],
                        "topics": [
                            "str"  # Optional. List of topics under which messages would
                              be persisted to disk for each subscriber. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxPacketSizeBytes": 0,  # Optional. Max message
                                  size for a packet in Bytes.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "persistence": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using persistentVolumeClaimSpec Then
                              this size is used as the request and limit sizes of that template. If a
                              PVC template isn't specified Then local-path provisioner is requested
                              with this size limit. Required. Required.
                            "dynamicSettings": {
                                "userPropertyKey": "str",  # The user property key to
                                  enable persistence. Required.
                                "userPropertyValue": "str"  # The user property value
                                  to enable persistence. Required.
                            },
                            "encryption": {
                                "mode": "str"  # Determines if encryption is enabled.
                                  Required. Known values are: "Enabled" and "Disabled".
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "retain": broker_retain_messages_policy,
                            "stateStore": broker_state_store_policy,
                            "subscriberQueue": broker_subscriber_queue_policy
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "mode":

                # JSON input template for discriminator value "Custom":
                broker_retain_messages_policy = {
                    "mode": "Custom",
                    "retainSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerRetainMessagesCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "topics": [
                            "str"  # Optional. List of topics under which retained
                              messages would be persisted to disk. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_state_store_policy = {
                    "mode": "Custom",
                    "stateStoreSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the BrokerStateStoreCustomPolicy.
                              Required. Known values are: "Enabled" and "Disabled".
                        },
                        "stateStoreResources": [
                            {
                                "keyType": "str",  # The key to persist to disk.
                                  Required. Known values are: "Pattern", "String", and "Binary".
                                "keys": [
                                    "str"  # List of keys to persist to disk,
                                      required. Required.
                                ]
                            }
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_subscriber_queue_policy = {
                    "mode": "Custom",
                    "subscriberQueueSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerSubscriberQueueCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "subscriberClientIds": [
                            "str"  # Optional. List of client IDs of the subscribers,
                              wildcard * supported.
                        ],
                        "topics": [
                            "str"  # Optional. List of topics under which messages would
                              be persisted to disk for each subscriber. Wildcards # and + supported.
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "mode":

                # JSON input template for discriminator value "Custom":
                broker_retain_messages_policy = {
                    "mode": "Custom",
                    "retainSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerRetainMessagesCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "topics": [
                            "str"  # Optional. List of topics under which retained
                              messages would be persisted to disk. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_state_store_policy = {
                    "mode": "Custom",
                    "stateStoreSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the BrokerStateStoreCustomPolicy.
                              Required. Known values are: "Enabled" and "Disabled".
                        },
                        "stateStoreResources": [
                            {
                                "keyType": "str",  # The key to persist to disk.
                                  Required. Known values are: "Pattern", "String", and "Binary".
                                "keys": [
                                    "str"  # List of keys to persist to disk,
                                      required. Required.
                                ]
                            }
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_subscriber_queue_policy = {
                    "mode": "Custom",
                    "subscriberQueueSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerSubscriberQueueCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "subscriberClientIds": [
                            "str"  # Optional. List of client IDs of the subscribers,
                              wildcard * supported.
                        ],
                        "topics": [
                            "str"  # Optional. List of topics under which messages would
                              be persisted to disk for each subscriber. Wildcards # and + supported.
                        ]
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxPacketSizeBytes": 0,  # Optional. Max message
                                  size for a packet in Bytes.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "persistence": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using persistentVolumeClaimSpec Then
                              this size is used as the request and limit sizes of that template. If a
                              PVC template isn't specified Then local-path provisioner is requested
                              with this size limit. Required. Required.
                            "dynamicSettings": {
                                "userPropertyKey": "str",  # The user property key to
                                  enable persistence. Required.
                                "userPropertyValue": "str"  # The user property value
                                  to enable persistence. Required.
                            },
                            "encryption": {
                                "mode": "str"  # Determines if encryption is enabled.
                                  Required. Known values are: "Enabled" and "Disabled".
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "retain": broker_retain_messages_policy,
                            "stateStore": broker_state_store_policy,
                            "subscriberQueue": broker_subscriber_queue_policy
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "mode":

                # JSON input template for discriminator value "Custom":
                broker_retain_messages_policy = {
                    "mode": "Custom",
                    "retainSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerRetainMessagesCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "topics": [
                            "str"  # Optional. List of topics under which retained
                              messages would be persisted to disk. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_state_store_policy = {
                    "mode": "Custom",
                    "stateStoreSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the BrokerStateStoreCustomPolicy.
                              Required. Known values are: "Enabled" and "Disabled".
                        },
                        "stateStoreResources": [
                            {
                                "keyType": "str",  # The key to persist to disk.
                                  Required. Known values are: "Pattern", "String", and "Binary".
                                "keys": [
                                    "str"  # List of keys to persist to disk,
                                      required. Required.
                                ]
                            }
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_subscriber_queue_policy = {
                    "mode": "Custom",
                    "subscriberQueueSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerSubscriberQueueCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "subscriberClientIds": [
                            "str"  # Optional. List of client IDs of the subscribers,
                              wildcard * supported.
                        ],
                        "topics": [
                            "str"  # Optional. List of topics under which messages would
                              be persisted to disk for each subscriber. Wildcards # and + supported.
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "mode":

                # JSON input template for discriminator value "Custom":
                broker_retain_messages_policy = {
                    "mode": "Custom",
                    "retainSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerRetainMessagesCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "topics": [
                            "str"  # Optional. List of topics under which retained
                              messages would be persisted to disk. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_state_store_policy = {
                    "mode": "Custom",
                    "stateStoreSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the BrokerStateStoreCustomPolicy.
                              Required. Known values are: "Enabled" and "Disabled".
                        },
                        "stateStoreResources": [
                            {
                                "keyType": "str",  # The key to persist to disk.
                                  Required. Known values are: "Pattern", "String", and "Binary".
                                "keys": [
                                    "str"  # List of keys to persist to disk,
                                      required. Required.
                                ]
                            }
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_subscriber_queue_policy = {
                    "mode": "Custom",
                    "subscriberQueueSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerSubscriberQueueCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "subscriberClientIds": [
                            "str"  # Optional. List of client IDs of the subscribers,
                              wildcard * supported.
                        ],
                        "topics": [
                            "str"  # Optional. List of topics under which messages would
                              be persisted to disk for each subscriber. Wildcards # and + supported.
                        ]
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxPacketSizeBytes": 0,  # Optional. Max message
                                  size for a packet in Bytes.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "persistence": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using persistentVolumeClaimSpec Then
                              this size is used as the request and limit sizes of that template. If a
                              PVC template isn't specified Then local-path provisioner is requested
                              with this size limit. Required. Required.
                            "dynamicSettings": {
                                "userPropertyKey": "str",  # The user property key to
                                  enable persistence. Required.
                                "userPropertyValue": "str"  # The user property value
                                  to enable persistence. Required.
                            },
                            "encryption": {
                                "mode": "str"  # Determines if encryption is enabled.
                                  Required. Known values are: "Enabled" and "Disabled".
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "retain": broker_retain_messages_policy,
                            "stateStore": broker_state_store_policy,
                            "subscriberQueue": broker_subscriber_queue_policy
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "mode":

                # JSON input template for discriminator value "Custom":
                broker_retain_messages_policy = {
                    "mode": "Custom",
                    "retainSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerRetainMessagesCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "topics": [
                            "str"  # Optional. List of topics under which retained
                              messages would be persisted to disk. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_state_store_policy = {
                    "mode": "Custom",
                    "stateStoreSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the BrokerStateStoreCustomPolicy.
                              Required. Known values are: "Enabled" and "Disabled".
                        },
                        "stateStoreResources": [
                            {
                                "keyType": "str",  # The key to persist to disk.
                                  Required. Known values are: "Pattern", "String", and "Binary".
                                "keys": [
                                    "str"  # List of keys to persist to disk,
                                      required. Required.
                                ]
                            }
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_subscriber_queue_policy = {
                    "mode": "Custom",
                    "subscriberQueueSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerSubscriberQueueCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "subscriberClientIds": [
                            "str"  # Optional. List of client IDs of the subscribers,
                              wildcard * supported.
                        ],
                        "topics": [
                            "str"  # Optional. List of topics under which messages would
                              be persisted to disk for each subscriber. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxPacketSizeBytes": 0,  # Optional. Max message
                                  size for a packet in Bytes.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "persistence": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using persistentVolumeClaimSpec Then
                              this size is used as the request and limit sizes of that template. If a
                              PVC template isn't specified Then local-path provisioner is requested
                              with this size limit. Required. Required.
                            "dynamicSettings": {
                                "userPropertyKey": "str",  # The user property key to
                                  enable persistence. Required.
                                "userPropertyValue": "str"  # The user property value
                                  to enable persistence. Required.
                            },
                            "encryption": {
                                "mode": "str"  # Determines if encryption is enabled.
                                  Required. Known values are: "Enabled" and "Disabled".
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "retain": broker_retain_messages_policy,
                            "stateStore": broker_state_store_policy,
                            "subscriberQueue": broker_subscriber_queue_policy
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "mode":

                # JSON input template for discriminator value "Custom":
                broker_retain_messages_policy = {
                    "mode": "Custom",
                    "retainSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerRetainMessagesCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "topics": [
                            "str"  # Optional. List of topics under which retained
                              messages would be persisted to disk. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_state_store_policy = {
                    "mode": "Custom",
                    "stateStoreSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the BrokerStateStoreCustomPolicy.
                              Required. Known values are: "Enabled" and "Disabled".
                        },
                        "stateStoreResources": [
                            {
                                "keyType": "str",  # The key to persist to disk.
                                  Required. Known values are: "Pattern", "String", and "Binary".
                                "keys": [
                                    "str"  # List of keys to persist to disk,
                                      required. Required.
                                ]
                            }
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_subscriber_queue_policy = {
                    "mode": "Custom",
                    "subscriberQueueSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerSubscriberQueueCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "subscriberClientIds": [
                            "str"  # Optional. List of client IDs of the subscribers,
                              wildcard * supported.
                        ],
                        "topics": [
                            "str"  # Optional. List of topics under which messages would
                              be persisted to disk for each subscriber. Wildcards # and + supported.
                        ]
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "mode":

                # JSON input template for discriminator value "Custom":
                broker_retain_messages_policy = {
                    "mode": "Custom",
                    "retainSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerRetainMessagesCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "topics": [
                            "str"  # Optional. List of topics under which retained
                              messages would be persisted to disk. Wildcards # and + supported.
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_state_store_policy = {
                    "mode": "Custom",
                    "stateStoreSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the BrokerStateStoreCustomPolicy.
                              Required. Known values are: "Enabled" and "Disabled".
                        },
                        "stateStoreResources": [
                            {
                                "keyType": "str",  # The key to persist to disk.
                                  Required. Known values are: "Pattern", "String", and "Binary".
                                "keys": [
                                    "str"  # List of keys to persist to disk,
                                      required. Required.
                                ]
                            }
                        ]
                    }
                }

                # JSON input template for discriminator value "Custom":
                broker_subscriber_queue_policy = {
                    "mode": "Custom",
                    "subscriberQueueSettings": {
                        "dynamic": {
                            "mode": "str"  # Mode of the
                              BrokerSubscriberQueueCustomPolicy. Required. Known values are: "Enabled"
                              and "Disabled".
                        },
                        "subscriberClientIds": [
                            "str"  # Optional. List of client IDs of the subscribers,
                              wildcard * supported.
                        ],
                        "topics": [
                            "str"  # Optional. List of topics under which messages would
                              be persisted to disk for each subscriber. Wildcards # and + supported.
                        ]
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxPacketSizeBytes": 0,  # Optional. Max message
                                  size for a packet in Bytes.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "persistence": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using persistentVolumeClaimSpec Then
                              this size is used as the request and limit sizes of that template. If a
                              PVC template isn't specified Then local-path provisioner is requested
                              with this size limit. Required. Required.
                            "dynamicSettings": {
                                "userPropertyKey": "str",  # The user property key to
                                  enable persistence. Required.
                                "userPropertyValue": "str"  # The user property value
                                  to enable persistence. Required.
                            },
                            "encryption": {
                                "mode": "str"  # Determines if encryption is enabled.
                                  Required. Known values are: "Enabled" and "Disabled".
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str",  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                    "namespace": "str"  # Optional. Namespace is
                                      the namespace of the resource being referenced. This field is
                                      required when the resource has a namespace.
                                },
                                "resources": {
                                    "claims": [
                                        {
                                            "name": "str"  # Name of the
                                              resource. This must match the name of a resource in
                                              spec.resourceClaims. Required.
                                        }
                                    ],
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "retain": broker_retain_messages_policy,
                            "stateStore": broker_state_store_policy,
                            "subscriberQueue": broker_subscriber_queue_policy
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_broker_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class BrokerAuthenticationOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`broker_authentication` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(
        self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List BrokerAuthenticationResource resources by BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "method": "str",  # Custom authentication
                                  configuration. Required. Known values are: "Custom",
                                  "ServiceAccountToken", and "X509".
                                "customSettings": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretRef": "str"  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "serviceAccountTokenSettings": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509Settings": {
                                    "additionalValidation": "str",  # Optional.
                                      X509 authentication attributes properties. Known values are:
                                      "None" and "AzureDeviceRegistry".
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_broker_authentication_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    broker_name=broker_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self, resource_group_name: str, instance_name: str, broker_name: str, authentication_name: str, **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "method": "str",  # Custom authentication
                                  configuration. Required. Known values are: "Custom",
                                  "ServiceAccountToken", and "X509".
                                "customSettings": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretRef": "str"  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "serviceAccountTokenSettings": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509Settings": {
                                    "additionalValidation": "str",  # Optional.
                                      X509 authentication attributes properties. Known values are:
                                      "None" and "AzureDeviceRegistry".
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_broker_authentication_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authentication_name=authentication_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authentication_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_broker_authentication_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authentication_name=authentication_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authentication_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "method": "str",  # Custom authentication
                                  configuration. Required. Known values are: "Custom",
                                  "ServiceAccountToken", and "X509".
                                "customSettings": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretRef": "str"  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "serviceAccountTokenSettings": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509Settings": {
                                    "additionalValidation": "str",  # Optional.
                                      X509 authentication attributes properties. Known values are:
                                      "None" and "AzureDeviceRegistry".
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "method": "str",  # Custom authentication
                                  configuration. Required. Known values are: "Custom",
                                  "ServiceAccountToken", and "X509".
                                "customSettings": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretRef": "str"  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "serviceAccountTokenSettings": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509Settings": {
                                    "additionalValidation": "str",  # Optional.
                                      X509 authentication attributes properties. Known values are:
                                      "None" and "AzureDeviceRegistry".
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authentication_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "method": "str",  # Custom authentication
                                  configuration. Required. Known values are: "Custom",
                                  "ServiceAccountToken", and "X509".
                                "customSettings": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretRef": "str"  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "serviceAccountTokenSettings": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509Settings": {
                                    "additionalValidation": "str",  # Optional.
                                      X509 authentication attributes properties. Known values are:
                                      "None" and "AzureDeviceRegistry".
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authentication_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "method": "str",  # Custom authentication
                                  configuration. Required. Known values are: "Custom",
                                  "ServiceAccountToken", and "X509".
                                "customSettings": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretRef": "str"  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "serviceAccountTokenSettings": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509Settings": {
                                    "additionalValidation": "str",  # Optional.
                                      X509 authentication attributes properties. Known values are:
                                      "None" and "AzureDeviceRegistry".
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "method": "str",  # Custom authentication
                                  configuration. Required. Known values are: "Custom",
                                  "ServiceAccountToken", and "X509".
                                "customSettings": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretRef": "str"  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "serviceAccountTokenSettings": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509Settings": {
                                    "additionalValidation": "str",  # Optional.
                                      X509 authentication attributes properties. Known values are:
                                      "None" and "AzureDeviceRegistry".
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                authentication_name=authentication_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, broker_name: str, authentication_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_broker_authentication_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authentication_name=authentication_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, broker_name: str, authentication_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                authentication_name=authentication_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class BrokerAuthorizationOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`broker_authorization` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(
        self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List BrokerAuthorizationResource resources by BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a Broker method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "clientIds": [
                                                "str"  # Optional. A
                                                  list of client IDs that match the clients. The client
                                                  IDs are case-sensitive and must match the client IDs
                                                  provided by the clients during connection. This
                                                  subfield may be set if the method is Connect.
                                            ],
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_broker_authorization_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    broker_name=broker_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self, resource_group_name: str, instance_name: str, broker_name: str, authorization_name: str, **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a Broker method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "clientIds": [
                                                "str"  # Optional. A
                                                  list of client IDs that match the clients. The client
                                                  IDs are case-sensitive and must match the client IDs
                                                  provided by the clients during connection. This
                                                  subfield may be set if the method is Connect.
                                            ],
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_broker_authorization_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authorization_name=authorization_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authorization_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_broker_authorization_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authorization_name=authorization_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authorization_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a Broker method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "clientIds": [
                                                "str"  # Optional. A
                                                  list of client IDs that match the clients. The client
                                                  IDs are case-sensitive and must match the client IDs
                                                  provided by the clients during connection. This
                                                  subfield may be set if the method is Connect.
                                            ],
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a Broker method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "clientIds": [
                                                "str"  # Optional. A
                                                  list of client IDs that match the clients. The client
                                                  IDs are case-sensitive and must match the client IDs
                                                  provided by the clients during connection. This
                                                  subfield may be set if the method is Connect.
                                            ],
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authorization_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a Broker method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "clientIds": [
                                                "str"  # Optional. A
                                                  list of client IDs that match the clients. The client
                                                  IDs are case-sensitive and must match the client IDs
                                                  provided by the clients during connection. This
                                                  subfield may be set if the method is Connect.
                                            ],
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authorization_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a Broker method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "clientIds": [
                                                "str"  # Optional. A
                                                  list of client IDs that match the clients. The client
                                                  IDs are case-sensitive and must match the client IDs
                                                  provided by the clients during connection. This
                                                  subfield may be set if the method is Connect.
                                            ],
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a Broker method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "clientIds": [
                                                "str"  # Optional. A
                                                  list of client IDs that match the clients. The client
                                                  IDs are case-sensitive and must match the client IDs
                                                  provided by the clients during connection. This
                                                  subfield may be set if the method is Connect.
                                            ],
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                authorization_name=authorization_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, broker_name: str, authorization_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_broker_authorization_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authorization_name=authorization_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, broker_name: str, authorization_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                authorization_name=authorization_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class BrokerListenerOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`broker_listener` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(
        self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List BrokerListenerResource resources by BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "mode": "str",  # Mode of TLS server
                                      certificate management. Required. Known values are: "Automatic"
                                      and "Manual".
                                    "certManagerCertificateSpec": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str"  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                    },
                                    "manual": {
                                        "secretRef": "str"  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "str",  # Optional. Kubernetes Service name of this
                          listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_broker_listener_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    broker_name=broker_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self, resource_group_name: str, instance_name: str, broker_name: str, listener_name: str, **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "mode": "str",  # Mode of TLS server
                                      certificate management. Required. Known values are: "Automatic"
                                      and "Manual".
                                    "certManagerCertificateSpec": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str"  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                    },
                                    "manual": {
                                        "secretRef": "str"  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "str",  # Optional. Kubernetes Service name of this
                          listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_broker_listener_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            listener_name=listener_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        listener_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_broker_listener_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            listener_name=listener_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        listener_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "mode": "str",  # Mode of TLS server
                                      certificate management. Required. Known values are: "Automatic"
                                      and "Manual".
                                    "certManagerCertificateSpec": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str"  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                    },
                                    "manual": {
                                        "secretRef": "str"  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "str",  # Optional. Kubernetes Service name of this
                          listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "mode": "str",  # Mode of TLS server
                                      certificate management. Required. Known values are: "Automatic"
                                      and "Manual".
                                    "certManagerCertificateSpec": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str"  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                    },
                                    "manual": {
                                        "secretRef": "str"  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "str",  # Optional. Kubernetes Service name of this
                          listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        listener_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "mode": "str",  # Mode of TLS server
                                      certificate management. Required. Known values are: "Automatic"
                                      and "Manual".
                                    "certManagerCertificateSpec": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str"  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                    },
                                    "manual": {
                                        "secretRef": "str"  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "str",  # Optional. Kubernetes Service name of this
                          listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        listener_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "mode": "str",  # Mode of TLS server
                                      certificate management. Required. Known values are: "Automatic"
                                      and "Manual".
                                    "certManagerCertificateSpec": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str"  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                    },
                                    "manual": {
                                        "secretRef": "str"  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "str",  # Optional. Kubernetes Service name of this
                          listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "mode": "str",  # Mode of TLS server
                                      certificate management. Required. Known values are: "Automatic"
                                      and "Manual".
                                    "certManagerCertificateSpec": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str"  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                    },
                                    "manual": {
                                        "secretRef": "str"  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "str",  # Optional. Kubernetes Service name of this
                          listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                listener_name=listener_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, broker_name: str, listener_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_broker_listener_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            listener_name=listener_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, broker_name: str, listener_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                listener_name=listener_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class DataflowEndpointOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`dataflow_endpoint` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, instance_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List DataflowEndpointResource resources by InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                dataflow_open_telemetry_authentication = {
                    "anonymousSettings": {},  # Settings for the anonymous connection. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ServiceAccountToken":
                dataflow_open_telemetry_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # Audience of the service account. Optional,
                          defaults to the broker internal service account audience. Required.
                    }
                }

                # JSON input template for discriminator value "X509Certificate":
                dataflow_open_telemetry_authentication = {
                    "method": "X509Certificate",
                    "x509CertificateSettings": {
                        "secretRef": "str"  # Secret reference of the X.509 certificate.
                          Required.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointType": "str",  # Endpoint Type. Required. Known values are:
                          "DataExplorer", "DataLakeStorage", "FabricOneLake", "Kafka", "LocalStorage",
                          "Mqtt", and "OpenTelemetry".
                        "dataExplorerSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "database": "str",  # Database name. Required.
                            "host": "str",  # Host of the Azure Data Explorer in the form
                              of :code:`<cluster>`.:code:`<region>`.kusto.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "dataLakeStorageSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", and "AccessToken".
                                "accessTokenSettings": {
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Azure Data Lake in the form of
                              :code:`<account>`.blob.core.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "fabricOneLakeSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Microsoft Fabric in the form of
                              https://:code:`<host>`.fabric.microsoft.com. Required.
                            "names": {
                                "lakehouseName": "str",  # Lakehouse name. Required.
                                "workspaceName": "str"  # Workspace name. Required.
                            },
                            "oneLakePathType": "str",  # Type of location of the data in
                              the workspace. Can be either tables or files. Required. Known values are:
                              "Files" and "Tables".
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "hostType": "str",  # Optional. The type of the Kafka host. E.g
                          FabricRT, EventGrid. Known values are: "FabricRT", "EventGrid",
                          "LocalBroker", "Eventhub", "CustomMqtt", and "CustomKafka".
                        "kafkaSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "Sasl", "X509Certificate", and
                                  "Anonymous".
                                "saslSettings": {
                                    "saslType": "str",  # Type of SASL
                                      authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
                                      Required. Known values are: "Plain", "ScramSha256", and
                                      "ScramSha512".
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "host": "str",  # Kafka endpoint host. Required.
                            "batching": {
                                "latencyMs": 5,  # Optional. Default value is 5.
                                  Batching latency in milliseconds.
                                "maxBytes": 1000000,  # Optional. Default value is
                                  1000000. Maximum number of bytes in a batch.
                                "maxMessages": 100000,  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                                "mode": "str"  # Optional. Mode for batching. Known
                                  values are: "Enabled" and "Disabled".
                            },
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "compression": "str",  # Optional. Compression. Can be none,
                              gzip, lz4, or snappy. No effect if the endpoint is used as a source.
                              Known values are: "None", "Gzip", "Snappy", and "Lz4".
                            "consumerGroupId": "str",  # Optional. Consumer group ID.
                            "copyMqttProperties": "str",  # Optional. Copy Broker
                              properties. No effect if the endpoint is used as a source or if the
                              dataflow doesn't have an Broker source. Known values are: "Enabled" and
                              "Disabled".
                            "kafkaAcks": "str",  # Optional. Kafka acks. Can be all, one,
                              or zero. No effect if the endpoint is used as a source. Known values are:
                              "Zero", "One", and "All".
                            "partitionStrategy": "str",  # Optional. Partition handling
                              strategy. Can be default or static. No effect if the endpoint is used as
                              a source. Known values are: "Default", "Static", "Topic", and "Property".
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "localStorageSettings": {
                            "persistentVolumeClaimRef": "str"  # Persistent volume claim
                              name. Required.
                        },
                        "mqttSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "ServiceAccountToken",
                                  "X509Certificate", and "Anonymous".
                                "serviceAccountTokenSettings": {
                                    "audience": "str"  # Audience of the service
                                      account. Optional, defaults to the broker internal service
                                      account audience. Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "clientIdPrefix": "str",  # Optional. Client ID prefix.
                              Client ID generated by the dataflow is :code:`<prefix>`-TBD. Optional; no
                              prefix if omitted.
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`. Optional; connects to Broker if
                              omitted.
                            "keepAliveSeconds": 60,  # Optional. Default value is 60.
                              Broker KeepAlive for connection in seconds.
                            "maxInflightMessages": 100,  # Optional. Default value is
                              100. The max number of messages to keep in flight. For subscribe, this is
                              the receive maximum. For publish, this is the maximum number of messages
                              to send before waiting for an ack.
                            "protocol": "str",  # Optional. Enable or disable websockets.
                              Known values are: "Mqtt" and "WebSockets".
                            "qos": 1,  # Optional. Default value is 1. Qos for Broker
                              connection.
                            "retain": "str",  # Optional. Whether or not to keep the
                              retain setting. Known values are: "Keep" and "Never".
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "openTelemetrySettings": {
                            "authentication": dataflow_open_telemetry_authentication,
                            "host": "str",  # Host of the OpenTelemetry in the form of
                              :code:`<host>`::code:`<port>`. Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            },
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_dataflow_endpoint_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, instance_name: str, dataflow_endpoint_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a DataflowEndpointResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_endpoint_name: Name of Instance dataflowEndpoint resource. Required.
        :type dataflow_endpoint_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                dataflow_open_telemetry_authentication = {
                    "anonymousSettings": {},  # Settings for the anonymous connection. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ServiceAccountToken":
                dataflow_open_telemetry_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # Audience of the service account. Optional,
                          defaults to the broker internal service account audience. Required.
                    }
                }

                # JSON input template for discriminator value "X509Certificate":
                dataflow_open_telemetry_authentication = {
                    "method": "X509Certificate",
                    "x509CertificateSettings": {
                        "secretRef": "str"  # Secret reference of the X.509 certificate.
                          Required.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointType": "str",  # Endpoint Type. Required. Known values are:
                          "DataExplorer", "DataLakeStorage", "FabricOneLake", "Kafka", "LocalStorage",
                          "Mqtt", and "OpenTelemetry".
                        "dataExplorerSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "database": "str",  # Database name. Required.
                            "host": "str",  # Host of the Azure Data Explorer in the form
                              of :code:`<cluster>`.:code:`<region>`.kusto.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "dataLakeStorageSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", and "AccessToken".
                                "accessTokenSettings": {
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Azure Data Lake in the form of
                              :code:`<account>`.blob.core.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "fabricOneLakeSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Microsoft Fabric in the form of
                              https://:code:`<host>`.fabric.microsoft.com. Required.
                            "names": {
                                "lakehouseName": "str",  # Lakehouse name. Required.
                                "workspaceName": "str"  # Workspace name. Required.
                            },
                            "oneLakePathType": "str",  # Type of location of the data in
                              the workspace. Can be either tables or files. Required. Known values are:
                              "Files" and "Tables".
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "hostType": "str",  # Optional. The type of the Kafka host. E.g
                          FabricRT, EventGrid. Known values are: "FabricRT", "EventGrid",
                          "LocalBroker", "Eventhub", "CustomMqtt", and "CustomKafka".
                        "kafkaSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "Sasl", "X509Certificate", and
                                  "Anonymous".
                                "saslSettings": {
                                    "saslType": "str",  # Type of SASL
                                      authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
                                      Required. Known values are: "Plain", "ScramSha256", and
                                      "ScramSha512".
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "host": "str",  # Kafka endpoint host. Required.
                            "batching": {
                                "latencyMs": 5,  # Optional. Default value is 5.
                                  Batching latency in milliseconds.
                                "maxBytes": 1000000,  # Optional. Default value is
                                  1000000. Maximum number of bytes in a batch.
                                "maxMessages": 100000,  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                                "mode": "str"  # Optional. Mode for batching. Known
                                  values are: "Enabled" and "Disabled".
                            },
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "compression": "str",  # Optional. Compression. Can be none,
                              gzip, lz4, or snappy. No effect if the endpoint is used as a source.
                              Known values are: "None", "Gzip", "Snappy", and "Lz4".
                            "consumerGroupId": "str",  # Optional. Consumer group ID.
                            "copyMqttProperties": "str",  # Optional. Copy Broker
                              properties. No effect if the endpoint is used as a source or if the
                              dataflow doesn't have an Broker source. Known values are: "Enabled" and
                              "Disabled".
                            "kafkaAcks": "str",  # Optional. Kafka acks. Can be all, one,
                              or zero. No effect if the endpoint is used as a source. Known values are:
                              "Zero", "One", and "All".
                            "partitionStrategy": "str",  # Optional. Partition handling
                              strategy. Can be default or static. No effect if the endpoint is used as
                              a source. Known values are: "Default", "Static", "Topic", and "Property".
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "localStorageSettings": {
                            "persistentVolumeClaimRef": "str"  # Persistent volume claim
                              name. Required.
                        },
                        "mqttSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "ServiceAccountToken",
                                  "X509Certificate", and "Anonymous".
                                "serviceAccountTokenSettings": {
                                    "audience": "str"  # Audience of the service
                                      account. Optional, defaults to the broker internal service
                                      account audience. Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "clientIdPrefix": "str",  # Optional. Client ID prefix.
                              Client ID generated by the dataflow is :code:`<prefix>`-TBD. Optional; no
                              prefix if omitted.
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`. Optional; connects to Broker if
                              omitted.
                            "keepAliveSeconds": 60,  # Optional. Default value is 60.
                              Broker KeepAlive for connection in seconds.
                            "maxInflightMessages": 100,  # Optional. Default value is
                              100. The max number of messages to keep in flight. For subscribe, this is
                              the receive maximum. For publish, this is the maximum number of messages
                              to send before waiting for an ack.
                            "protocol": "str",  # Optional. Enable or disable websockets.
                              Known values are: "Mqtt" and "WebSockets".
                            "qos": 1,  # Optional. Default value is 1. Qos for Broker
                              connection.
                            "retain": "str",  # Optional. Whether or not to keep the
                              retain setting. Known values are: "Keep" and "Never".
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "openTelemetrySettings": {
                            "authentication": dataflow_open_telemetry_authentication,
                            "host": "str",  # Host of the OpenTelemetry in the form of
                              :code:`<host>`::code:`<port>`. Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            },
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflow_endpoint_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_endpoint_name=dataflow_endpoint_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_endpoint_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_dataflow_endpoint_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_endpoint_name=dataflow_endpoint_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_endpoint_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowEndpointResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_endpoint_name: Name of Instance dataflowEndpoint resource. Required.
        :type dataflow_endpoint_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                dataflow_open_telemetry_authentication = {
                    "anonymousSettings": {},  # Settings for the anonymous connection. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ServiceAccountToken":
                dataflow_open_telemetry_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # Audience of the service account. Optional,
                          defaults to the broker internal service account audience. Required.
                    }
                }

                # JSON input template for discriminator value "X509Certificate":
                dataflow_open_telemetry_authentication = {
                    "method": "X509Certificate",
                    "x509CertificateSettings": {
                        "secretRef": "str"  # Secret reference of the X.509 certificate.
                          Required.
                    }
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointType": "str",  # Endpoint Type. Required. Known values are:
                          "DataExplorer", "DataLakeStorage", "FabricOneLake", "Kafka", "LocalStorage",
                          "Mqtt", and "OpenTelemetry".
                        "dataExplorerSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "database": "str",  # Database name. Required.
                            "host": "str",  # Host of the Azure Data Explorer in the form
                              of :code:`<cluster>`.:code:`<region>`.kusto.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "dataLakeStorageSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", and "AccessToken".
                                "accessTokenSettings": {
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Azure Data Lake in the form of
                              :code:`<account>`.blob.core.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "fabricOneLakeSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Microsoft Fabric in the form of
                              https://:code:`<host>`.fabric.microsoft.com. Required.
                            "names": {
                                "lakehouseName": "str",  # Lakehouse name. Required.
                                "workspaceName": "str"  # Workspace name. Required.
                            },
                            "oneLakePathType": "str",  # Type of location of the data in
                              the workspace. Can be either tables or files. Required. Known values are:
                              "Files" and "Tables".
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "hostType": "str",  # Optional. The type of the Kafka host. E.g
                          FabricRT, EventGrid. Known values are: "FabricRT", "EventGrid",
                          "LocalBroker", "Eventhub", "CustomMqtt", and "CustomKafka".
                        "kafkaSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "Sasl", "X509Certificate", and
                                  "Anonymous".
                                "saslSettings": {
                                    "saslType": "str",  # Type of SASL
                                      authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
                                      Required. Known values are: "Plain", "ScramSha256", and
                                      "ScramSha512".
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "host": "str",  # Kafka endpoint host. Required.
                            "batching": {
                                "latencyMs": 5,  # Optional. Default value is 5.
                                  Batching latency in milliseconds.
                                "maxBytes": 1000000,  # Optional. Default value is
                                  1000000. Maximum number of bytes in a batch.
                                "maxMessages": 100000,  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                                "mode": "str"  # Optional. Mode for batching. Known
                                  values are: "Enabled" and "Disabled".
                            },
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "compression": "str",  # Optional. Compression. Can be none,
                              gzip, lz4, or snappy. No effect if the endpoint is used as a source.
                              Known values are: "None", "Gzip", "Snappy", and "Lz4".
                            "consumerGroupId": "str",  # Optional. Consumer group ID.
                            "copyMqttProperties": "str",  # Optional. Copy Broker
                              properties. No effect if the endpoint is used as a source or if the
                              dataflow doesn't have an Broker source. Known values are: "Enabled" and
                              "Disabled".
                            "kafkaAcks": "str",  # Optional. Kafka acks. Can be all, one,
                              or zero. No effect if the endpoint is used as a source. Known values are:
                              "Zero", "One", and "All".
                            "partitionStrategy": "str",  # Optional. Partition handling
                              strategy. Can be default or static. No effect if the endpoint is used as
                              a source. Known values are: "Default", "Static", "Topic", and "Property".
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "localStorageSettings": {
                            "persistentVolumeClaimRef": "str"  # Persistent volume claim
                              name. Required.
                        },
                        "mqttSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "ServiceAccountToken",
                                  "X509Certificate", and "Anonymous".
                                "serviceAccountTokenSettings": {
                                    "audience": "str"  # Audience of the service
                                      account. Optional, defaults to the broker internal service
                                      account audience. Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "clientIdPrefix": "str",  # Optional. Client ID prefix.
                              Client ID generated by the dataflow is :code:`<prefix>`-TBD. Optional; no
                              prefix if omitted.
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`. Optional; connects to Broker if
                              omitted.
                            "keepAliveSeconds": 60,  # Optional. Default value is 60.
                              Broker KeepAlive for connection in seconds.
                            "maxInflightMessages": 100,  # Optional. Default value is
                              100. The max number of messages to keep in flight. For subscribe, this is
                              the receive maximum. For publish, this is the maximum number of messages
                              to send before waiting for an ack.
                            "protocol": "str",  # Optional. Enable or disable websockets.
                              Known values are: "Mqtt" and "WebSockets".
                            "qos": 1,  # Optional. Default value is 1. Qos for Broker
                              connection.
                            "retain": "str",  # Optional. Whether or not to keep the
                              retain setting. Known values are: "Keep" and "Never".
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "openTelemetrySettings": {
                            "authentication": dataflow_open_telemetry_authentication,
                            "host": "str",  # Host of the OpenTelemetry in the form of
                              :code:`<host>`::code:`<port>`. Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            },
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                dataflow_open_telemetry_authentication = {
                    "anonymousSettings": {},  # Settings for the anonymous connection. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ServiceAccountToken":
                dataflow_open_telemetry_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # Audience of the service account. Optional,
                          defaults to the broker internal service account audience. Required.
                    }
                }

                # JSON input template for discriminator value "X509Certificate":
                dataflow_open_telemetry_authentication = {
                    "method": "X509Certificate",
                    "x509CertificateSettings": {
                        "secretRef": "str"  # Secret reference of the X.509 certificate.
                          Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                dataflow_open_telemetry_authentication = {
                    "anonymousSettings": {},  # Settings for the anonymous connection. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ServiceAccountToken":
                dataflow_open_telemetry_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # Audience of the service account. Optional,
                          defaults to the broker internal service account audience. Required.
                    }
                }

                # JSON input template for discriminator value "X509Certificate":
                dataflow_open_telemetry_authentication = {
                    "method": "X509Certificate",
                    "x509CertificateSettings": {
                        "secretRef": "str"  # Secret reference of the X.509 certificate.
                          Required.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointType": "str",  # Endpoint Type. Required. Known values are:
                          "DataExplorer", "DataLakeStorage", "FabricOneLake", "Kafka", "LocalStorage",
                          "Mqtt", and "OpenTelemetry".
                        "dataExplorerSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "database": "str",  # Database name. Required.
                            "host": "str",  # Host of the Azure Data Explorer in the form
                              of :code:`<cluster>`.:code:`<region>`.kusto.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "dataLakeStorageSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", and "AccessToken".
                                "accessTokenSettings": {
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Azure Data Lake in the form of
                              :code:`<account>`.blob.core.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "fabricOneLakeSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Microsoft Fabric in the form of
                              https://:code:`<host>`.fabric.microsoft.com. Required.
                            "names": {
                                "lakehouseName": "str",  # Lakehouse name. Required.
                                "workspaceName": "str"  # Workspace name. Required.
                            },
                            "oneLakePathType": "str",  # Type of location of the data in
                              the workspace. Can be either tables or files. Required. Known values are:
                              "Files" and "Tables".
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "hostType": "str",  # Optional. The type of the Kafka host. E.g
                          FabricRT, EventGrid. Known values are: "FabricRT", "EventGrid",
                          "LocalBroker", "Eventhub", "CustomMqtt", and "CustomKafka".
                        "kafkaSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "Sasl", "X509Certificate", and
                                  "Anonymous".
                                "saslSettings": {
                                    "saslType": "str",  # Type of SASL
                                      authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
                                      Required. Known values are: "Plain", "ScramSha256", and
                                      "ScramSha512".
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "host": "str",  # Kafka endpoint host. Required.
                            "batching": {
                                "latencyMs": 5,  # Optional. Default value is 5.
                                  Batching latency in milliseconds.
                                "maxBytes": 1000000,  # Optional. Default value is
                                  1000000. Maximum number of bytes in a batch.
                                "maxMessages": 100000,  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                                "mode": "str"  # Optional. Mode for batching. Known
                                  values are: "Enabled" and "Disabled".
                            },
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "compression": "str",  # Optional. Compression. Can be none,
                              gzip, lz4, or snappy. No effect if the endpoint is used as a source.
                              Known values are: "None", "Gzip", "Snappy", and "Lz4".
                            "consumerGroupId": "str",  # Optional. Consumer group ID.
                            "copyMqttProperties": "str",  # Optional. Copy Broker
                              properties. No effect if the endpoint is used as a source or if the
                              dataflow doesn't have an Broker source. Known values are: "Enabled" and
                              "Disabled".
                            "kafkaAcks": "str",  # Optional. Kafka acks. Can be all, one,
                              or zero. No effect if the endpoint is used as a source. Known values are:
                              "Zero", "One", and "All".
                            "partitionStrategy": "str",  # Optional. Partition handling
                              strategy. Can be default or static. No effect if the endpoint is used as
                              a source. Known values are: "Default", "Static", "Topic", and "Property".
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "localStorageSettings": {
                            "persistentVolumeClaimRef": "str"  # Persistent volume claim
                              name. Required.
                        },
                        "mqttSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "ServiceAccountToken",
                                  "X509Certificate", and "Anonymous".
                                "serviceAccountTokenSettings": {
                                    "audience": "str"  # Audience of the service
                                      account. Optional, defaults to the broker internal service
                                      account audience. Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "clientIdPrefix": "str",  # Optional. Client ID prefix.
                              Client ID generated by the dataflow is :code:`<prefix>`-TBD. Optional; no
                              prefix if omitted.
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`. Optional; connects to Broker if
                              omitted.
                            "keepAliveSeconds": 60,  # Optional. Default value is 60.
                              Broker KeepAlive for connection in seconds.
                            "maxInflightMessages": 100,  # Optional. Default value is
                              100. The max number of messages to keep in flight. For subscribe, this is
                              the receive maximum. For publish, this is the maximum number of messages
                              to send before waiting for an ack.
                            "protocol": "str",  # Optional. Enable or disable websockets.
                              Known values are: "Mqtt" and "WebSockets".
                            "qos": 1,  # Optional. Default value is 1. Qos for Broker
                              connection.
                            "retain": "str",  # Optional. Whether or not to keep the
                              retain setting. Known values are: "Keep" and "Never".
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "openTelemetrySettings": {
                            "authentication": dataflow_open_telemetry_authentication,
                            "host": "str",  # Host of the OpenTelemetry in the form of
                              :code:`<host>`::code:`<port>`. Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            },
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_endpoint_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowEndpointResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_endpoint_name: Name of Instance dataflowEndpoint resource. Required.
        :type dataflow_endpoint_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                dataflow_open_telemetry_authentication = {
                    "anonymousSettings": {},  # Settings for the anonymous connection. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ServiceAccountToken":
                dataflow_open_telemetry_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # Audience of the service account. Optional,
                          defaults to the broker internal service account audience. Required.
                    }
                }

                # JSON input template for discriminator value "X509Certificate":
                dataflow_open_telemetry_authentication = {
                    "method": "X509Certificate",
                    "x509CertificateSettings": {
                        "secretRef": "str"  # Secret reference of the X.509 certificate.
                          Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                dataflow_open_telemetry_authentication = {
                    "anonymousSettings": {},  # Settings for the anonymous connection. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ServiceAccountToken":
                dataflow_open_telemetry_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # Audience of the service account. Optional,
                          defaults to the broker internal service account audience. Required.
                    }
                }

                # JSON input template for discriminator value "X509Certificate":
                dataflow_open_telemetry_authentication = {
                    "method": "X509Certificate",
                    "x509CertificateSettings": {
                        "secretRef": "str"  # Secret reference of the X.509 certificate.
                          Required.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointType": "str",  # Endpoint Type. Required. Known values are:
                          "DataExplorer", "DataLakeStorage", "FabricOneLake", "Kafka", "LocalStorage",
                          "Mqtt", and "OpenTelemetry".
                        "dataExplorerSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "database": "str",  # Database name. Required.
                            "host": "str",  # Host of the Azure Data Explorer in the form
                              of :code:`<cluster>`.:code:`<region>`.kusto.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "dataLakeStorageSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", and "AccessToken".
                                "accessTokenSettings": {
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Azure Data Lake in the form of
                              :code:`<account>`.blob.core.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "fabricOneLakeSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Microsoft Fabric in the form of
                              https://:code:`<host>`.fabric.microsoft.com. Required.
                            "names": {
                                "lakehouseName": "str",  # Lakehouse name. Required.
                                "workspaceName": "str"  # Workspace name. Required.
                            },
                            "oneLakePathType": "str",  # Type of location of the data in
                              the workspace. Can be either tables or files. Required. Known values are:
                              "Files" and "Tables".
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "hostType": "str",  # Optional. The type of the Kafka host. E.g
                          FabricRT, EventGrid. Known values are: "FabricRT", "EventGrid",
                          "LocalBroker", "Eventhub", "CustomMqtt", and "CustomKafka".
                        "kafkaSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "Sasl", "X509Certificate", and
                                  "Anonymous".
                                "saslSettings": {
                                    "saslType": "str",  # Type of SASL
                                      authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
                                      Required. Known values are: "Plain", "ScramSha256", and
                                      "ScramSha512".
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "host": "str",  # Kafka endpoint host. Required.
                            "batching": {
                                "latencyMs": 5,  # Optional. Default value is 5.
                                  Batching latency in milliseconds.
                                "maxBytes": 1000000,  # Optional. Default value is
                                  1000000. Maximum number of bytes in a batch.
                                "maxMessages": 100000,  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                                "mode": "str"  # Optional. Mode for batching. Known
                                  values are: "Enabled" and "Disabled".
                            },
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "compression": "str",  # Optional. Compression. Can be none,
                              gzip, lz4, or snappy. No effect if the endpoint is used as a source.
                              Known values are: "None", "Gzip", "Snappy", and "Lz4".
                            "consumerGroupId": "str",  # Optional. Consumer group ID.
                            "copyMqttProperties": "str",  # Optional. Copy Broker
                              properties. No effect if the endpoint is used as a source or if the
                              dataflow doesn't have an Broker source. Known values are: "Enabled" and
                              "Disabled".
                            "kafkaAcks": "str",  # Optional. Kafka acks. Can be all, one,
                              or zero. No effect if the endpoint is used as a source. Known values are:
                              "Zero", "One", and "All".
                            "partitionStrategy": "str",  # Optional. Partition handling
                              strategy. Can be default or static. No effect if the endpoint is used as
                              a source. Known values are: "Default", "Static", "Topic", and "Property".
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "localStorageSettings": {
                            "persistentVolumeClaimRef": "str"  # Persistent volume claim
                              name. Required.
                        },
                        "mqttSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "ServiceAccountToken",
                                  "X509Certificate", and "Anonymous".
                                "serviceAccountTokenSettings": {
                                    "audience": "str"  # Audience of the service
                                      account. Optional, defaults to the broker internal service
                                      account audience. Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "clientIdPrefix": "str",  # Optional. Client ID prefix.
                              Client ID generated by the dataflow is :code:`<prefix>`-TBD. Optional; no
                              prefix if omitted.
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`. Optional; connects to Broker if
                              omitted.
                            "keepAliveSeconds": 60,  # Optional. Default value is 60.
                              Broker KeepAlive for connection in seconds.
                            "maxInflightMessages": 100,  # Optional. Default value is
                              100. The max number of messages to keep in flight. For subscribe, this is
                              the receive maximum. For publish, this is the maximum number of messages
                              to send before waiting for an ack.
                            "protocol": "str",  # Optional. Enable or disable websockets.
                              Known values are: "Mqtt" and "WebSockets".
                            "qos": 1,  # Optional. Default value is 1. Qos for Broker
                              connection.
                            "retain": "str",  # Optional. Whether or not to keep the
                              retain setting. Known values are: "Keep" and "Never".
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "openTelemetrySettings": {
                            "authentication": dataflow_open_telemetry_authentication,
                            "host": "str",  # Host of the OpenTelemetry in the form of
                              :code:`<host>`::code:`<port>`. Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            },
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_endpoint_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowEndpointResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_endpoint_name: Name of Instance dataflowEndpoint resource. Required.
        :type dataflow_endpoint_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                dataflow_open_telemetry_authentication = {
                    "anonymousSettings": {},  # Settings for the anonymous connection. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ServiceAccountToken":
                dataflow_open_telemetry_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # Audience of the service account. Optional,
                          defaults to the broker internal service account audience. Required.
                    }
                }

                # JSON input template for discriminator value "X509Certificate":
                dataflow_open_telemetry_authentication = {
                    "method": "X509Certificate",
                    "x509CertificateSettings": {
                        "secretRef": "str"  # Secret reference of the X.509 certificate.
                          Required.
                    }
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointType": "str",  # Endpoint Type. Required. Known values are:
                          "DataExplorer", "DataLakeStorage", "FabricOneLake", "Kafka", "LocalStorage",
                          "Mqtt", and "OpenTelemetry".
                        "dataExplorerSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "database": "str",  # Database name. Required.
                            "host": "str",  # Host of the Azure Data Explorer in the form
                              of :code:`<cluster>`.:code:`<region>`.kusto.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "dataLakeStorageSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", and "AccessToken".
                                "accessTokenSettings": {
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Azure Data Lake in the form of
                              :code:`<account>`.blob.core.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "fabricOneLakeSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Microsoft Fabric in the form of
                              https://:code:`<host>`.fabric.microsoft.com. Required.
                            "names": {
                                "lakehouseName": "str",  # Lakehouse name. Required.
                                "workspaceName": "str"  # Workspace name. Required.
                            },
                            "oneLakePathType": "str",  # Type of location of the data in
                              the workspace. Can be either tables or files. Required. Known values are:
                              "Files" and "Tables".
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "hostType": "str",  # Optional. The type of the Kafka host. E.g
                          FabricRT, EventGrid. Known values are: "FabricRT", "EventGrid",
                          "LocalBroker", "Eventhub", "CustomMqtt", and "CustomKafka".
                        "kafkaSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "Sasl", "X509Certificate", and
                                  "Anonymous".
                                "saslSettings": {
                                    "saslType": "str",  # Type of SASL
                                      authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
                                      Required. Known values are: "Plain", "ScramSha256", and
                                      "ScramSha512".
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "host": "str",  # Kafka endpoint host. Required.
                            "batching": {
                                "latencyMs": 5,  # Optional. Default value is 5.
                                  Batching latency in milliseconds.
                                "maxBytes": 1000000,  # Optional. Default value is
                                  1000000. Maximum number of bytes in a batch.
                                "maxMessages": 100000,  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                                "mode": "str"  # Optional. Mode for batching. Known
                                  values are: "Enabled" and "Disabled".
                            },
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "compression": "str",  # Optional. Compression. Can be none,
                              gzip, lz4, or snappy. No effect if the endpoint is used as a source.
                              Known values are: "None", "Gzip", "Snappy", and "Lz4".
                            "consumerGroupId": "str",  # Optional. Consumer group ID.
                            "copyMqttProperties": "str",  # Optional. Copy Broker
                              properties. No effect if the endpoint is used as a source or if the
                              dataflow doesn't have an Broker source. Known values are: "Enabled" and
                              "Disabled".
                            "kafkaAcks": "str",  # Optional. Kafka acks. Can be all, one,
                              or zero. No effect if the endpoint is used as a source. Known values are:
                              "Zero", "One", and "All".
                            "partitionStrategy": "str",  # Optional. Partition handling
                              strategy. Can be default or static. No effect if the endpoint is used as
                              a source. Known values are: "Default", "Static", "Topic", and "Property".
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "localStorageSettings": {
                            "persistentVolumeClaimRef": "str"  # Persistent volume claim
                              name. Required.
                        },
                        "mqttSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "ServiceAccountToken",
                                  "X509Certificate", and "Anonymous".
                                "serviceAccountTokenSettings": {
                                    "audience": "str"  # Audience of the service
                                      account. Optional, defaults to the broker internal service
                                      account audience. Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "clientIdPrefix": "str",  # Optional. Client ID prefix.
                              Client ID generated by the dataflow is :code:`<prefix>`-TBD. Optional; no
                              prefix if omitted.
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`. Optional; connects to Broker if
                              omitted.
                            "keepAliveSeconds": 60,  # Optional. Default value is 60.
                              Broker KeepAlive for connection in seconds.
                            "maxInflightMessages": 100,  # Optional. Default value is
                              100. The max number of messages to keep in flight. For subscribe, this is
                              the receive maximum. For publish, this is the maximum number of messages
                              to send before waiting for an ack.
                            "protocol": "str",  # Optional. Enable or disable websockets.
                              Known values are: "Mqtt" and "WebSockets".
                            "qos": 1,  # Optional. Default value is 1. Qos for Broker
                              connection.
                            "retain": "str",  # Optional. Whether or not to keep the
                              retain setting. Known values are: "Keep" and "Never".
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "openTelemetrySettings": {
                            "authentication": dataflow_open_telemetry_authentication,
                            "host": "str",  # Host of the OpenTelemetry in the form of
                              :code:`<host>`::code:`<port>`. Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            },
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                dataflow_open_telemetry_authentication = {
                    "anonymousSettings": {},  # Settings for the anonymous connection. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ServiceAccountToken":
                dataflow_open_telemetry_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # Audience of the service account. Optional,
                          defaults to the broker internal service account audience. Required.
                    }
                }

                # JSON input template for discriminator value "X509Certificate":
                dataflow_open_telemetry_authentication = {
                    "method": "X509Certificate",
                    "x509CertificateSettings": {
                        "secretRef": "str"  # Secret reference of the X.509 certificate.
                          Required.
                    }
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                dataflow_open_telemetry_authentication = {
                    "anonymousSettings": {},  # Settings for the anonymous connection. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ServiceAccountToken":
                dataflow_open_telemetry_authentication = {
                    "method": "ServiceAccountToken",
                    "serviceAccountTokenSettings": {
                        "audience": "str"  # Audience of the service account. Optional,
                          defaults to the broker internal service account audience. Required.
                    }
                }

                # JSON input template for discriminator value "X509Certificate":
                dataflow_open_telemetry_authentication = {
                    "method": "X509Certificate",
                    "x509CertificateSettings": {
                        "secretRef": "str"  # Secret reference of the X.509 certificate.
                          Required.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointType": "str",  # Endpoint Type. Required. Known values are:
                          "DataExplorer", "DataLakeStorage", "FabricOneLake", "Kafka", "LocalStorage",
                          "Mqtt", and "OpenTelemetry".
                        "dataExplorerSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "database": "str",  # Database name. Required.
                            "host": "str",  # Host of the Azure Data Explorer in the form
                              of :code:`<cluster>`.:code:`<region>`.kusto.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "dataLakeStorageSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", and "AccessToken".
                                "accessTokenSettings": {
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Azure Data Lake in the form of
                              :code:`<account>`.blob.core.windows.net . Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "fabricOneLakeSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity" and
                                  "UserAssignedManagedIdentity".
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                }
                            },
                            "host": "str",  # Host of the Microsoft Fabric in the form of
                              https://:code:`<host>`.fabric.microsoft.com. Required.
                            "names": {
                                "lakehouseName": "str",  # Lakehouse name. Required.
                                "workspaceName": "str"  # Workspace name. Required.
                            },
                            "oneLakePathType": "str",  # Type of location of the data in
                              the workspace. Can be either tables or files. Required. Known values are:
                              "Files" and "Tables".
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            }
                        },
                        "hostType": "str",  # Optional. The type of the Kafka host. E.g
                          FabricRT, EventGrid. Known values are: "FabricRT", "EventGrid",
                          "LocalBroker", "Eventhub", "CustomMqtt", and "CustomKafka".
                        "kafkaSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "Sasl", "X509Certificate", and
                                  "Anonymous".
                                "saslSettings": {
                                    "saslType": "str",  # Type of SASL
                                      authentication. Can be PLAIN, SCRAM-SHA-256, or SCRAM-SHA-512.
                                      Required. Known values are: "Plain", "ScramSha256", and
                                      "ScramSha512".
                                    "secretRef": "str"  # Token secret name.
                                      Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "host": "str",  # Kafka endpoint host. Required.
                            "batching": {
                                "latencyMs": 5,  # Optional. Default value is 5.
                                  Batching latency in milliseconds.
                                "maxBytes": 1000000,  # Optional. Default value is
                                  1000000. Maximum number of bytes in a batch.
                                "maxMessages": 100000,  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                                "mode": "str"  # Optional. Mode for batching. Known
                                  values are: "Enabled" and "Disabled".
                            },
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "compression": "str",  # Optional. Compression. Can be none,
                              gzip, lz4, or snappy. No effect if the endpoint is used as a source.
                              Known values are: "None", "Gzip", "Snappy", and "Lz4".
                            "consumerGroupId": "str",  # Optional. Consumer group ID.
                            "copyMqttProperties": "str",  # Optional. Copy Broker
                              properties. No effect if the endpoint is used as a source or if the
                              dataflow doesn't have an Broker source. Known values are: "Enabled" and
                              "Disabled".
                            "kafkaAcks": "str",  # Optional. Kafka acks. Can be all, one,
                              or zero. No effect if the endpoint is used as a source. Known values are:
                              "Zero", "One", and "All".
                            "partitionStrategy": "str",  # Optional. Partition handling
                              strategy. Can be default or static. No effect if the endpoint is used as
                              a source. Known values are: "Default", "Static", "Topic", and "Property".
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "localStorageSettings": {
                            "persistentVolumeClaimRef": "str"  # Persistent volume claim
                              name. Required.
                        },
                        "mqttSettings": {
                            "authentication": {
                                "method": "str",  # Mode of Authentication. Required.
                                  Known values are: "SystemAssignedManagedIdentity",
                                  "UserAssignedManagedIdentity", "ServiceAccountToken",
                                  "X509Certificate", and "Anonymous".
                                "serviceAccountTokenSettings": {
                                    "audience": "str"  # Audience of the service
                                      account. Optional, defaults to the broker internal service
                                      account audience. Required.
                                },
                                "systemAssignedManagedIdentitySettings": {
                                    "audience": "str"  # Optional. Audience of
                                      the service to authenticate against. Optional; defaults to the
                                      audience for Service host configuration.
                                },
                                "userAssignedManagedIdentitySettings": {
                                    "clientId": "str",  # Client ID for the
                                      user-assigned managed identity. Required.
                                    "tenantId": "str",  # Tenant ID. Required.
                                    "scope": "str"  # Optional. Resource
                                      identifier (application ID URI) of the resource, affixed with the
                                      .default suffix.
                                },
                                "x509CertificateSettings": {
                                    "secretRef": "str"  # Secret reference of the
                                      X.509 certificate. Required.
                                }
                            },
                            "clientIdPrefix": "str",  # Optional. Client ID prefix.
                              Client ID generated by the dataflow is :code:`<prefix>`-TBD. Optional; no
                              prefix if omitted.
                            "cloudEventAttributes": "str",  # Optional. Cloud event
                              mapping config. Known values are: "Propagate" and "CreateOrRemap".
                            "host": "str",  # Optional. Host of the Broker in the form of
                              :code:`<hostname>`::code:`<port>`. Optional; connects to Broker if
                              omitted.
                            "keepAliveSeconds": 60,  # Optional. Default value is 60.
                              Broker KeepAlive for connection in seconds.
                            "maxInflightMessages": 100,  # Optional. Default value is
                              100. The max number of messages to keep in flight. For subscribe, this is
                              the receive maximum. For publish, this is the maximum number of messages
                              to send before waiting for an ack.
                            "protocol": "str",  # Optional. Enable or disable websockets.
                              Known values are: "Mqtt" and "WebSockets".
                            "qos": 1,  # Optional. Default value is 1. Qos for Broker
                              connection.
                            "retain": "str",  # Optional. Whether or not to keep the
                              retain setting. Known values are: "Keep" and "Never".
                            "sessionExpirySeconds": 0,  # Optional. Session expiry in
                              seconds.
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "openTelemetrySettings": {
                            "authentication": dataflow_open_telemetry_authentication,
                            "host": "str",  # Host of the OpenTelemetry in the form of
                              :code:`<host>`::code:`<port>`. Required.
                            "batching": {
                                "latencySeconds": 60,  # Optional. Default value is
                                  60. Batching latency in seconds.
                                "maxMessages": 100000  # Optional. Default value is
                                  100000. Maximum number of messages in a batch.
                            },
                            "tls": {
                                "mode": "str",  # Optional. Mode for TLS. Known
                                  values are: "Enabled" and "Disabled".
                                "trustedCaCertificateConfigMapRef": "str"  #
                                  Optional. Trusted CA certificate config map.
                            }
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                dataflow_endpoint_name=dataflow_endpoint_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, dataflow_endpoint_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_dataflow_endpoint_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_endpoint_name=dataflow_endpoint_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, dataflow_endpoint_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a DataflowEndpointResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_endpoint_name: Name of Instance dataflowEndpoint resource. Required.
        :type dataflow_endpoint_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                dataflow_endpoint_name=dataflow_endpoint_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class DataflowProfileOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`dataflow_profile` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, instance_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List DataflowProfileResource resources by InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            }
                        },
                        "instanceCount": 1,  # Optional. Default value is 1. To manually
                          scale the dataflow profile, specify the maximum number of instances you want
                          to run.
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_dataflow_profile_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, instance_name: str, dataflow_profile_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a DataflowProfileResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            }
                        },
                        "instanceCount": 1,  # Optional. Default value is 1. To manually
                          scale the dataflow profile, specify the maximum number of instances you want
                          to run.
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflow_profile_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_profile_name=dataflow_profile_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_dataflow_profile_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_profile_name=dataflow_profile_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowProfileResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            }
                        },
                        "instanceCount": 1,  # Optional. Default value is 1. To manually
                          scale the dataflow profile, specify the maximum number of instances you want
                          to run.
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            }
                        },
                        "instanceCount": 1,  # Optional. Default value is 1. To manually
                          scale the dataflow profile, specify the maximum number of instances you want
                          to run.
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowProfileResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            }
                        },
                        "instanceCount": 1,  # Optional. Default value is 1. To manually
                          scale the dataflow profile, specify the maximum number of instances you want
                          to run.
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowProfileResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            }
                        },
                        "instanceCount": 1,  # Optional. Default value is 1. To manually
                          scale the dataflow profile, specify the maximum number of instances you want
                          to run.
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "diagnostics": {
                            "logs": {
                                "level": "info"  # Optional. Default value is "info".
                                  The log level. Examples - 'debug', 'info', 'warn', 'error', 'trace'.
                            },
                            "metrics": {
                                "prometheusPort": 9600  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                            }
                        },
                        "instanceCount": 1,  # Optional. Default value is 1. To manually
                          scale the dataflow profile, specify the maximum number of instances you want
                          to run.
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                dataflow_profile_name=dataflow_profile_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, dataflow_profile_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_dataflow_profile_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_profile_name=dataflow_profile_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, dataflow_profile_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a DataflowProfileResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                dataflow_profile_name=dataflow_profile_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class DataflowGraphOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`dataflow_graph` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_dataflow_profile(
        self, resource_group_name: str, instance_name: str, dataflow_profile_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List DataflowGraphResource resources by DataflowProfileResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "nodeConnections": [
                            {
                                "from": {
                                    "name": "str",  # Name of the input node.
                                      Required.
                                    "schema": {
                                        "schemaRef": "str",  # Optional.
                                          Reference to the schema that describes the output of the
                                          transformation.
                                        "serializationFormat": "str"  #
                                          Optional. Output serialization format. Known values are:
                                          "Delta", "Json", "Parquet", and "Avro".
                                    }
                                },
                                "to": {
                                    "name": "str"  # Name of the destination
                                      node. Required.
                                }
                            }
                        ],
                        "nodes": [
                            dataflow_graph_node
                        ],
                        "mode": "str",  # Optional. The mode of the dataflow graph. Known
                          values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the dataflow graph. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_dataflow_graph_list_by_dataflow_profile_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    dataflow_profile_name=dataflow_profile_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_graph_name: str,
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get a DataflowGraphResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param dataflow_graph_name: Name of Instance dataflowEndpoint resource. Required.
        :type dataflow_graph_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "nodeConnections": [
                            {
                                "from": {
                                    "name": "str",  # Name of the input node.
                                      Required.
                                    "schema": {
                                        "schemaRef": "str",  # Optional.
                                          Reference to the schema that describes the output of the
                                          transformation.
                                        "serializationFormat": "str"  #
                                          Optional. Output serialization format. Known values are:
                                          "Delta", "Json", "Parquet", and "Avro".
                                    }
                                },
                                "to": {
                                    "name": "str"  # Name of the destination
                                      node. Required.
                                }
                            }
                        ],
                        "nodes": [
                            dataflow_graph_node
                        ],
                        "mode": "str",  # Optional. The mode of the dataflow graph. Known
                          values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the dataflow graph. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflow_graph_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_profile_name=dataflow_profile_name,
            dataflow_graph_name=dataflow_graph_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_graph_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_dataflow_graph_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_profile_name=dataflow_profile_name,
            dataflow_graph_name=dataflow_graph_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_graph_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowGraphResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param dataflow_graph_name: Name of Instance dataflowEndpoint resource. Required.
        :type dataflow_graph_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "nodeConnections": [
                            {
                                "from": {
                                    "name": "str",  # Name of the input node.
                                      Required.
                                    "schema": {
                                        "schemaRef": "str",  # Optional.
                                          Reference to the schema that describes the output of the
                                          transformation.
                                        "serializationFormat": "str"  #
                                          Optional. Output serialization format. Known values are:
                                          "Delta", "Json", "Parquet", and "Avro".
                                    }
                                },
                                "to": {
                                    "name": "str"  # Name of the destination
                                      node. Required.
                                }
                            }
                        ],
                        "nodes": [
                            dataflow_graph_node
                        ],
                        "mode": "str",  # Optional. The mode of the dataflow graph. Known
                          values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the dataflow graph. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "nodeConnections": [
                            {
                                "from": {
                                    "name": "str",  # Name of the input node.
                                      Required.
                                    "schema": {
                                        "schemaRef": "str",  # Optional.
                                          Reference to the schema that describes the output of the
                                          transformation.
                                        "serializationFormat": "str"  #
                                          Optional. Output serialization format. Known values are:
                                          "Delta", "Json", "Parquet", and "Avro".
                                    }
                                },
                                "to": {
                                    "name": "str"  # Name of the destination
                                      node. Required.
                                }
                            }
                        ],
                        "nodes": [
                            dataflow_graph_node
                        ],
                        "mode": "str",  # Optional. The mode of the dataflow graph. Known
                          values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the dataflow graph. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_graph_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowGraphResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param dataflow_graph_name: Name of Instance dataflowEndpoint resource. Required.
        :type dataflow_graph_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "nodeConnections": [
                            {
                                "from": {
                                    "name": "str",  # Name of the input node.
                                      Required.
                                    "schema": {
                                        "schemaRef": "str",  # Optional.
                                          Reference to the schema that describes the output of the
                                          transformation.
                                        "serializationFormat": "str"  #
                                          Optional. Output serialization format. Known values are:
                                          "Delta", "Json", "Parquet", and "Avro".
                                    }
                                },
                                "to": {
                                    "name": "str"  # Name of the destination
                                      node. Required.
                                }
                            }
                        ],
                        "nodes": [
                            dataflow_graph_node
                        ],
                        "mode": "str",  # Optional. The mode of the dataflow graph. Known
                          values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the dataflow graph. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_graph_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowGraphResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param dataflow_graph_name: Name of Instance dataflowEndpoint resource. Required.
        :type dataflow_graph_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "nodeConnections": [
                            {
                                "from": {
                                    "name": "str",  # Name of the input node.
                                      Required.
                                    "schema": {
                                        "schemaRef": "str",  # Optional.
                                          Reference to the schema that describes the output of the
                                          transformation.
                                        "serializationFormat": "str"  #
                                          Optional. Output serialization format. Known values are:
                                          "Delta", "Json", "Parquet", and "Avro".
                                    }
                                },
                                "to": {
                                    "name": "str"  # Name of the destination
                                      node. Required.
                                }
                            }
                        ],
                        "nodes": [
                            dataflow_graph_node
                        ],
                        "mode": "str",  # Optional. The mode of the dataflow graph. Known
                          values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the dataflow graph. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "nodeConnections": [
                            {
                                "from": {
                                    "name": "str",  # Name of the input node.
                                      Required.
                                    "schema": {
                                        "schemaRef": "str",  # Optional.
                                          Reference to the schema that describes the output of the
                                          transformation.
                                        "serializationFormat": "str"  #
                                          Optional. Output serialization format. Known values are:
                                          "Delta", "Json", "Parquet", and "Avro".
                                    }
                                },
                                "to": {
                                    "name": "str"  # Name of the destination
                                      node. Required.
                                }
                            }
                        ],
                        "nodes": [
                            dataflow_graph_node
                        ],
                        "mode": "str",  # Optional. The mode of the dataflow graph. Known
                          values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The provisioning state of
                          the dataflow graph. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                dataflow_profile_name=dataflow_profile_name,
                dataflow_graph_name=dataflow_graph_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_graph_name: str,
        **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_dataflow_graph_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_profile_name=dataflow_profile_name,
            dataflow_graph_name=dataflow_graph_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_graph_name: str,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a DataflowGraphResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param dataflow_graph_name: Name of Instance dataflowEndpoint resource. Required.
        :type dataflow_graph_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                dataflow_profile_name=dataflow_profile_name,
                dataflow_graph_name=dataflow_graph_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class DataflowOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`dataflow` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_profile_resource(
        self, resource_group_name: str, instance_name: str, dataflow_profile_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List DataflowResource resources by DataflowProfileResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "operations": [
                            {
                                "operationType": "str",  # Type of operation.
                                  Required. Known values are: "Source", "Destination", and
                                  "BuiltInTransformation".
                                "builtInTransformationSettings": {
                                    "datasets": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for enriching from the Broker State Store.
                                                  Required.
                                            ],
                                            "key": "str",  # The key of
                                              the dataset. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              dataset.
                                            "expression": "str",  #
                                              Optional. Condition to enrich data from Broker State
                                              Store. Example: $1 < 0 || $1 > $2 (Assuming inputs
                                              section $1 and $2 are provided).
                                            "schemaRef": "str"  #
                                              Optional. The reference to the schema that describes the
                                              dataset. Allowed: JSON Schema/draft-7.
                                        }
                                    ],
                                    "filter": [
                                        {
                                            "expression": "str",  #
                                              Condition to filter data. Can reference input fields with
                                              {n} where n is the index of the input field starting from
                                              1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1
                                              and $2 are provided). Required.
                                            "inputs": [
                                                "str"  # List of
                                                  fields for filtering in JSON path expression.
                                                  Required.
                                            ],
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              filter.
                                            "type": "str"  # Optional.
                                              The type of dataflow operation. "Filter"
                                        }
                                    ],
                                    "map": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for mapping in JSON path expression. Required.
                                            ],
                                            "output": "str",  # Where and
                                              how the input fields to be organized in the output
                                              record. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              mapping function.
                                            "expression": "str",  #
                                              Optional. Modify the inputs field(s) to the final output
                                              field. Example: $1 * 2.2 (Assuming inputs section $1 is
                                              provided).
                                            "type": "str"  # Optional.
                                              Type of transformation. Known values are:
                                              "NewProperties", "Rename", "Compute", "PassThrough", and
                                              "BuiltInFunction".
                                        }
                                    ],
                                    "schemaRef": "str",  # Optional. Reference to
                                      the schema that describes the output of the transformation.
                                    "serializationFormat": "str"  # Optional.
                                      Serialization format. Optional; defaults to JSON. Allowed value
                                      JSON Schema/draft-7, Parquet. Default: Json. Known values are:
                                      "Delta", "Json", and "Parquet".
                                },
                                "destinationSettings": {
                                    "dataDestination": "str",  # Destination
                                      location, can be a topic or table name. Supports dynamic values
                                      with $topic, $systemProperties, $userProperties, $payload,
                                      $context, and $subscription. Required.
                                    "endpointRef": "str"  # Reference to the
                                      Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
                                      Required.
                                },
                                "name": "str",  # Optional. Optional user provided
                                  name of the transformation.
                                "sourceSettings": {
                                    "dataSources": [
                                        "str"  # List of source locations.
                                          Can be Broker or Kafka topics. Supports wildcards # and +.
                                          Required.
                                    ],
                                    "endpointRef": "str",  # Reference to the
                                      Dataflow Endpoint resource. Can only be of Broker and Kafka type.
                                      Required.
                                    "assetRef": "str",  # Optional. Reference to
                                      the resource in Azure Device Registry where the data in the
                                      endpoint originates from.
                                    "schemaRef": "str",  # Optional. Schema CR
                                      reference. Data will be deserialized according to the schema, and
                                      dropped if it doesn't match.
                                    "serializationFormat": "str"  # Optional.
                                      Content is a JSON Schema. Allowed: JSON Schema/draft-7. "Json"
                                }
                            }
                        ],
                        "mode": "str",  # Optional. Mode for Dataflow. Optional; defaults to
                          Enabled. Known values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_dataflow_list_by_profile_resource_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    dataflow_profile_name=dataflow_profile_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_name: str,
        **kwargs: Any
    ) -> JSON:
        # pylint: disable=line-too-long
        """Get a DataflowResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param dataflow_name: Name of Instance dataflowProfile dataflow resource. Required.
        :type dataflow_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "operations": [
                            {
                                "operationType": "str",  # Type of operation.
                                  Required. Known values are: "Source", "Destination", and
                                  "BuiltInTransformation".
                                "builtInTransformationSettings": {
                                    "datasets": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for enriching from the Broker State Store.
                                                  Required.
                                            ],
                                            "key": "str",  # The key of
                                              the dataset. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              dataset.
                                            "expression": "str",  #
                                              Optional. Condition to enrich data from Broker State
                                              Store. Example: $1 < 0 || $1 > $2 (Assuming inputs
                                              section $1 and $2 are provided).
                                            "schemaRef": "str"  #
                                              Optional. The reference to the schema that describes the
                                              dataset. Allowed: JSON Schema/draft-7.
                                        }
                                    ],
                                    "filter": [
                                        {
                                            "expression": "str",  #
                                              Condition to filter data. Can reference input fields with
                                              {n} where n is the index of the input field starting from
                                              1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1
                                              and $2 are provided). Required.
                                            "inputs": [
                                                "str"  # List of
                                                  fields for filtering in JSON path expression.
                                                  Required.
                                            ],
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              filter.
                                            "type": "str"  # Optional.
                                              The type of dataflow operation. "Filter"
                                        }
                                    ],
                                    "map": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for mapping in JSON path expression. Required.
                                            ],
                                            "output": "str",  # Where and
                                              how the input fields to be organized in the output
                                              record. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              mapping function.
                                            "expression": "str",  #
                                              Optional. Modify the inputs field(s) to the final output
                                              field. Example: $1 * 2.2 (Assuming inputs section $1 is
                                              provided).
                                            "type": "str"  # Optional.
                                              Type of transformation. Known values are:
                                              "NewProperties", "Rename", "Compute", "PassThrough", and
                                              "BuiltInFunction".
                                        }
                                    ],
                                    "schemaRef": "str",  # Optional. Reference to
                                      the schema that describes the output of the transformation.
                                    "serializationFormat": "str"  # Optional.
                                      Serialization format. Optional; defaults to JSON. Allowed value
                                      JSON Schema/draft-7, Parquet. Default: Json. Known values are:
                                      "Delta", "Json", and "Parquet".
                                },
                                "destinationSettings": {
                                    "dataDestination": "str",  # Destination
                                      location, can be a topic or table name. Supports dynamic values
                                      with $topic, $systemProperties, $userProperties, $payload,
                                      $context, and $subscription. Required.
                                    "endpointRef": "str"  # Reference to the
                                      Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
                                      Required.
                                },
                                "name": "str",  # Optional. Optional user provided
                                  name of the transformation.
                                "sourceSettings": {
                                    "dataSources": [
                                        "str"  # List of source locations.
                                          Can be Broker or Kafka topics. Supports wildcards # and +.
                                          Required.
                                    ],
                                    "endpointRef": "str",  # Reference to the
                                      Dataflow Endpoint resource. Can only be of Broker and Kafka type.
                                      Required.
                                    "assetRef": "str",  # Optional. Reference to
                                      the resource in Azure Device Registry where the data in the
                                      endpoint originates from.
                                    "schemaRef": "str",  # Optional. Schema CR
                                      reference. Data will be deserialized according to the schema, and
                                      dropped if it doesn't match.
                                    "serializationFormat": "str"  # Optional.
                                      Content is a JSON Schema. Allowed: JSON Schema/draft-7. "Json"
                                }
                            }
                        ],
                        "mode": "str",  # Optional. Mode for Dataflow. Optional; defaults to
                          Enabled. Known values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_dataflow_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_profile_name=dataflow_profile_name,
            dataflow_name=dataflow_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_dataflow_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_profile_name=dataflow_profile_name,
            dataflow_name=dataflow_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param dataflow_name: Name of Instance dataflowProfile dataflow resource. Required.
        :type dataflow_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "operations": [
                            {
                                "operationType": "str",  # Type of operation.
                                  Required. Known values are: "Source", "Destination", and
                                  "BuiltInTransformation".
                                "builtInTransformationSettings": {
                                    "datasets": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for enriching from the Broker State Store.
                                                  Required.
                                            ],
                                            "key": "str",  # The key of
                                              the dataset. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              dataset.
                                            "expression": "str",  #
                                              Optional. Condition to enrich data from Broker State
                                              Store. Example: $1 < 0 || $1 > $2 (Assuming inputs
                                              section $1 and $2 are provided).
                                            "schemaRef": "str"  #
                                              Optional. The reference to the schema that describes the
                                              dataset. Allowed: JSON Schema/draft-7.
                                        }
                                    ],
                                    "filter": [
                                        {
                                            "expression": "str",  #
                                              Condition to filter data. Can reference input fields with
                                              {n} where n is the index of the input field starting from
                                              1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1
                                              and $2 are provided). Required.
                                            "inputs": [
                                                "str"  # List of
                                                  fields for filtering in JSON path expression.
                                                  Required.
                                            ],
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              filter.
                                            "type": "str"  # Optional.
                                              The type of dataflow operation. "Filter"
                                        }
                                    ],
                                    "map": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for mapping in JSON path expression. Required.
                                            ],
                                            "output": "str",  # Where and
                                              how the input fields to be organized in the output
                                              record. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              mapping function.
                                            "expression": "str",  #
                                              Optional. Modify the inputs field(s) to the final output
                                              field. Example: $1 * 2.2 (Assuming inputs section $1 is
                                              provided).
                                            "type": "str"  # Optional.
                                              Type of transformation. Known values are:
                                              "NewProperties", "Rename", "Compute", "PassThrough", and
                                              "BuiltInFunction".
                                        }
                                    ],
                                    "schemaRef": "str",  # Optional. Reference to
                                      the schema that describes the output of the transformation.
                                    "serializationFormat": "str"  # Optional.
                                      Serialization format. Optional; defaults to JSON. Allowed value
                                      JSON Schema/draft-7, Parquet. Default: Json. Known values are:
                                      "Delta", "Json", and "Parquet".
                                },
                                "destinationSettings": {
                                    "dataDestination": "str",  # Destination
                                      location, can be a topic or table name. Supports dynamic values
                                      with $topic, $systemProperties, $userProperties, $payload,
                                      $context, and $subscription. Required.
                                    "endpointRef": "str"  # Reference to the
                                      Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
                                      Required.
                                },
                                "name": "str",  # Optional. Optional user provided
                                  name of the transformation.
                                "sourceSettings": {
                                    "dataSources": [
                                        "str"  # List of source locations.
                                          Can be Broker or Kafka topics. Supports wildcards # and +.
                                          Required.
                                    ],
                                    "endpointRef": "str",  # Reference to the
                                      Dataflow Endpoint resource. Can only be of Broker and Kafka type.
                                      Required.
                                    "assetRef": "str",  # Optional. Reference to
                                      the resource in Azure Device Registry where the data in the
                                      endpoint originates from.
                                    "schemaRef": "str",  # Optional. Schema CR
                                      reference. Data will be deserialized according to the schema, and
                                      dropped if it doesn't match.
                                    "serializationFormat": "str"  # Optional.
                                      Content is a JSON Schema. Allowed: JSON Schema/draft-7. "Json"
                                }
                            }
                        ],
                        "mode": "str",  # Optional. Mode for Dataflow. Optional; defaults to
                          Enabled. Known values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "operations": [
                            {
                                "operationType": "str",  # Type of operation.
                                  Required. Known values are: "Source", "Destination", and
                                  "BuiltInTransformation".
                                "builtInTransformationSettings": {
                                    "datasets": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for enriching from the Broker State Store.
                                                  Required.
                                            ],
                                            "key": "str",  # The key of
                                              the dataset. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              dataset.
                                            "expression": "str",  #
                                              Optional. Condition to enrich data from Broker State
                                              Store. Example: $1 < 0 || $1 > $2 (Assuming inputs
                                              section $1 and $2 are provided).
                                            "schemaRef": "str"  #
                                              Optional. The reference to the schema that describes the
                                              dataset. Allowed: JSON Schema/draft-7.
                                        }
                                    ],
                                    "filter": [
                                        {
                                            "expression": "str",  #
                                              Condition to filter data. Can reference input fields with
                                              {n} where n is the index of the input field starting from
                                              1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1
                                              and $2 are provided). Required.
                                            "inputs": [
                                                "str"  # List of
                                                  fields for filtering in JSON path expression.
                                                  Required.
                                            ],
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              filter.
                                            "type": "str"  # Optional.
                                              The type of dataflow operation. "Filter"
                                        }
                                    ],
                                    "map": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for mapping in JSON path expression. Required.
                                            ],
                                            "output": "str",  # Where and
                                              how the input fields to be organized in the output
                                              record. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              mapping function.
                                            "expression": "str",  #
                                              Optional. Modify the inputs field(s) to the final output
                                              field. Example: $1 * 2.2 (Assuming inputs section $1 is
                                              provided).
                                            "type": "str"  # Optional.
                                              Type of transformation. Known values are:
                                              "NewProperties", "Rename", "Compute", "PassThrough", and
                                              "BuiltInFunction".
                                        }
                                    ],
                                    "schemaRef": "str",  # Optional. Reference to
                                      the schema that describes the output of the transformation.
                                    "serializationFormat": "str"  # Optional.
                                      Serialization format. Optional; defaults to JSON. Allowed value
                                      JSON Schema/draft-7, Parquet. Default: Json. Known values are:
                                      "Delta", "Json", and "Parquet".
                                },
                                "destinationSettings": {
                                    "dataDestination": "str",  # Destination
                                      location, can be a topic or table name. Supports dynamic values
                                      with $topic, $systemProperties, $userProperties, $payload,
                                      $context, and $subscription. Required.
                                    "endpointRef": "str"  # Reference to the
                                      Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
                                      Required.
                                },
                                "name": "str",  # Optional. Optional user provided
                                  name of the transformation.
                                "sourceSettings": {
                                    "dataSources": [
                                        "str"  # List of source locations.
                                          Can be Broker or Kafka topics. Supports wildcards # and +.
                                          Required.
                                    ],
                                    "endpointRef": "str",  # Reference to the
                                      Dataflow Endpoint resource. Can only be of Broker and Kafka type.
                                      Required.
                                    "assetRef": "str",  # Optional. Reference to
                                      the resource in Azure Device Registry where the data in the
                                      endpoint originates from.
                                    "schemaRef": "str",  # Optional. Schema CR
                                      reference. Data will be deserialized according to the schema, and
                                      dropped if it doesn't match.
                                    "serializationFormat": "str"  # Optional.
                                      Content is a JSON Schema. Allowed: JSON Schema/draft-7. "Json"
                                }
                            }
                        ],
                        "mode": "str",  # Optional. Mode for Dataflow. Optional; defaults to
                          Enabled. Known values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param dataflow_name: Name of Instance dataflowProfile dataflow resource. Required.
        :type dataflow_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "operations": [
                            {
                                "operationType": "str",  # Type of operation.
                                  Required. Known values are: "Source", "Destination", and
                                  "BuiltInTransformation".
                                "builtInTransformationSettings": {
                                    "datasets": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for enriching from the Broker State Store.
                                                  Required.
                                            ],
                                            "key": "str",  # The key of
                                              the dataset. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              dataset.
                                            "expression": "str",  #
                                              Optional. Condition to enrich data from Broker State
                                              Store. Example: $1 < 0 || $1 > $2 (Assuming inputs
                                              section $1 and $2 are provided).
                                            "schemaRef": "str"  #
                                              Optional. The reference to the schema that describes the
                                              dataset. Allowed: JSON Schema/draft-7.
                                        }
                                    ],
                                    "filter": [
                                        {
                                            "expression": "str",  #
                                              Condition to filter data. Can reference input fields with
                                              {n} where n is the index of the input field starting from
                                              1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1
                                              and $2 are provided). Required.
                                            "inputs": [
                                                "str"  # List of
                                                  fields for filtering in JSON path expression.
                                                  Required.
                                            ],
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              filter.
                                            "type": "str"  # Optional.
                                              The type of dataflow operation. "Filter"
                                        }
                                    ],
                                    "map": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for mapping in JSON path expression. Required.
                                            ],
                                            "output": "str",  # Where and
                                              how the input fields to be organized in the output
                                              record. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              mapping function.
                                            "expression": "str",  #
                                              Optional. Modify the inputs field(s) to the final output
                                              field. Example: $1 * 2.2 (Assuming inputs section $1 is
                                              provided).
                                            "type": "str"  # Optional.
                                              Type of transformation. Known values are:
                                              "NewProperties", "Rename", "Compute", "PassThrough", and
                                              "BuiltInFunction".
                                        }
                                    ],
                                    "schemaRef": "str",  # Optional. Reference to
                                      the schema that describes the output of the transformation.
                                    "serializationFormat": "str"  # Optional.
                                      Serialization format. Optional; defaults to JSON. Allowed value
                                      JSON Schema/draft-7, Parquet. Default: Json. Known values are:
                                      "Delta", "Json", and "Parquet".
                                },
                                "destinationSettings": {
                                    "dataDestination": "str",  # Destination
                                      location, can be a topic or table name. Supports dynamic values
                                      with $topic, $systemProperties, $userProperties, $payload,
                                      $context, and $subscription. Required.
                                    "endpointRef": "str"  # Reference to the
                                      Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
                                      Required.
                                },
                                "name": "str",  # Optional. Optional user provided
                                  name of the transformation.
                                "sourceSettings": {
                                    "dataSources": [
                                        "str"  # List of source locations.
                                          Can be Broker or Kafka topics. Supports wildcards # and +.
                                          Required.
                                    ],
                                    "endpointRef": "str",  # Reference to the
                                      Dataflow Endpoint resource. Can only be of Broker and Kafka type.
                                      Required.
                                    "assetRef": "str",  # Optional. Reference to
                                      the resource in Azure Device Registry where the data in the
                                      endpoint originates from.
                                    "schemaRef": "str",  # Optional. Schema CR
                                      reference. Data will be deserialized according to the schema, and
                                      dropped if it doesn't match.
                                    "serializationFormat": "str"  # Optional.
                                      Content is a JSON Schema. Allowed: JSON Schema/draft-7. "Json"
                                }
                            }
                        ],
                        "mode": "str",  # Optional. Mode for Dataflow. Optional; defaults to
                          Enabled. Known values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a DataflowResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param dataflow_name: Name of Instance dataflowProfile dataflow resource. Required.
        :type dataflow_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "operations": [
                            {
                                "operationType": "str",  # Type of operation.
                                  Required. Known values are: "Source", "Destination", and
                                  "BuiltInTransformation".
                                "builtInTransformationSettings": {
                                    "datasets": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for enriching from the Broker State Store.
                                                  Required.
                                            ],
                                            "key": "str",  # The key of
                                              the dataset. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              dataset.
                                            "expression": "str",  #
                                              Optional. Condition to enrich data from Broker State
                                              Store. Example: $1 < 0 || $1 > $2 (Assuming inputs
                                              section $1 and $2 are provided).
                                            "schemaRef": "str"  #
                                              Optional. The reference to the schema that describes the
                                              dataset. Allowed: JSON Schema/draft-7.
                                        }
                                    ],
                                    "filter": [
                                        {
                                            "expression": "str",  #
                                              Condition to filter data. Can reference input fields with
                                              {n} where n is the index of the input field starting from
                                              1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1
                                              and $2 are provided). Required.
                                            "inputs": [
                                                "str"  # List of
                                                  fields for filtering in JSON path expression.
                                                  Required.
                                            ],
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              filter.
                                            "type": "str"  # Optional.
                                              The type of dataflow operation. "Filter"
                                        }
                                    ],
                                    "map": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for mapping in JSON path expression. Required.
                                            ],
                                            "output": "str",  # Where and
                                              how the input fields to be organized in the output
                                              record. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              mapping function.
                                            "expression": "str",  #
                                              Optional. Modify the inputs field(s) to the final output
                                              field. Example: $1 * 2.2 (Assuming inputs section $1 is
                                              provided).
                                            "type": "str"  # Optional.
                                              Type of transformation. Known values are:
                                              "NewProperties", "Rename", "Compute", "PassThrough", and
                                              "BuiltInFunction".
                                        }
                                    ],
                                    "schemaRef": "str",  # Optional. Reference to
                                      the schema that describes the output of the transformation.
                                    "serializationFormat": "str"  # Optional.
                                      Serialization format. Optional; defaults to JSON. Allowed value
                                      JSON Schema/draft-7, Parquet. Default: Json. Known values are:
                                      "Delta", "Json", and "Parquet".
                                },
                                "destinationSettings": {
                                    "dataDestination": "str",  # Destination
                                      location, can be a topic or table name. Supports dynamic values
                                      with $topic, $systemProperties, $userProperties, $payload,
                                      $context, and $subscription. Required.
                                    "endpointRef": "str"  # Reference to the
                                      Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
                                      Required.
                                },
                                "name": "str",  # Optional. Optional user provided
                                  name of the transformation.
                                "sourceSettings": {
                                    "dataSources": [
                                        "str"  # List of source locations.
                                          Can be Broker or Kafka topics. Supports wildcards # and +.
                                          Required.
                                    ],
                                    "endpointRef": "str",  # Reference to the
                                      Dataflow Endpoint resource. Can only be of Broker and Kafka type.
                                      Required.
                                    "assetRef": "str",  # Optional. Reference to
                                      the resource in Azure Device Registry where the data in the
                                      endpoint originates from.
                                    "schemaRef": "str",  # Optional. Schema CR
                                      reference. Data will be deserialized according to the schema, and
                                      dropped if it doesn't match.
                                    "serializationFormat": "str"  # Optional.
                                      Content is a JSON Schema. Allowed: JSON Schema/draft-7. "Json"
                                }
                            }
                        ],
                        "mode": "str",  # Optional. Mode for Dataflow. Optional; defaults to
                          Enabled. Known values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "operations": [
                            {
                                "operationType": "str",  # Type of operation.
                                  Required. Known values are: "Source", "Destination", and
                                  "BuiltInTransformation".
                                "builtInTransformationSettings": {
                                    "datasets": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for enriching from the Broker State Store.
                                                  Required.
                                            ],
                                            "key": "str",  # The key of
                                              the dataset. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              dataset.
                                            "expression": "str",  #
                                              Optional. Condition to enrich data from Broker State
                                              Store. Example: $1 < 0 || $1 > $2 (Assuming inputs
                                              section $1 and $2 are provided).
                                            "schemaRef": "str"  #
                                              Optional. The reference to the schema that describes the
                                              dataset. Allowed: JSON Schema/draft-7.
                                        }
                                    ],
                                    "filter": [
                                        {
                                            "expression": "str",  #
                                              Condition to filter data. Can reference input fields with
                                              {n} where n is the index of the input field starting from
                                              1. Example: $1 < 0 || $1 > $2 (Assuming inputs section $1
                                              and $2 are provided). Required.
                                            "inputs": [
                                                "str"  # List of
                                                  fields for filtering in JSON path expression.
                                                  Required.
                                            ],
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              filter.
                                            "type": "str"  # Optional.
                                              The type of dataflow operation. "Filter"
                                        }
                                    ],
                                    "map": [
                                        {
                                            "inputs": [
                                                "str"  # List of
                                                  fields for mapping in JSON path expression. Required.
                                            ],
                                            "output": "str",  # Where and
                                              how the input fields to be organized in the output
                                              record. Required.
                                            "description": "str",  #
                                              Optional. A user provided optional description of the
                                              mapping function.
                                            "expression": "str",  #
                                              Optional. Modify the inputs field(s) to the final output
                                              field. Example: $1 * 2.2 (Assuming inputs section $1 is
                                              provided).
                                            "type": "str"  # Optional.
                                              Type of transformation. Known values are:
                                              "NewProperties", "Rename", "Compute", "PassThrough", and
                                              "BuiltInFunction".
                                        }
                                    ],
                                    "schemaRef": "str",  # Optional. Reference to
                                      the schema that describes the output of the transformation.
                                    "serializationFormat": "str"  # Optional.
                                      Serialization format. Optional; defaults to JSON. Allowed value
                                      JSON Schema/draft-7, Parquet. Default: Json. Known values are:
                                      "Delta", "Json", and "Parquet".
                                },
                                "destinationSettings": {
                                    "dataDestination": "str",  # Destination
                                      location, can be a topic or table name. Supports dynamic values
                                      with $topic, $systemProperties, $userProperties, $payload,
                                      $context, and $subscription. Required.
                                    "endpointRef": "str"  # Reference to the
                                      Endpoint CR. Can be of Broker, Kafka, Fabric, ADLS, ADX type.
                                      Required.
                                },
                                "name": "str",  # Optional. Optional user provided
                                  name of the transformation.
                                "sourceSettings": {
                                    "dataSources": [
                                        "str"  # List of source locations.
                                          Can be Broker or Kafka topics. Supports wildcards # and +.
                                          Required.
                                    ],
                                    "endpointRef": "str",  # Reference to the
                                      Dataflow Endpoint resource. Can only be of Broker and Kafka type.
                                      Required.
                                    "assetRef": "str",  # Optional. Reference to
                                      the resource in Azure Device Registry where the data in the
                                      endpoint originates from.
                                    "schemaRef": "str",  # Optional. Schema CR
                                      reference. Data will be deserialized according to the schema, and
                                      dropped if it doesn't match.
                                    "serializationFormat": "str"  # Optional.
                                      Content is a JSON Schema. Allowed: JSON Schema/draft-7. "Json"
                                }
                            }
                        ],
                        "mode": "str",  # Optional. Mode for Dataflow. Optional; defaults to
                          Enabled. Known values are: "Enabled" and "Disabled".
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "requestDiskPersistence": "str"  # Optional. Disk persistence mode.
                          Known values are: "Enabled" and "Disabled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                dataflow_profile_name=dataflow_profile_name,
                dataflow_name=dataflow_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_name: str,
        **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_dataflow_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            dataflow_profile_name=dataflow_profile_name,
            dataflow_name=dataflow_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self,
        resource_group_name: str,
        instance_name: str,
        dataflow_profile_name: str,
        dataflow_name: str,
        **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a DataflowResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param dataflow_profile_name: Name of Instance dataflowProfile resource. Required.
        :type dataflow_profile_name: str
        :param dataflow_name: Name of Instance dataflowProfile dataflow resource. Required.
        :type dataflow_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                dataflow_profile_name=dataflow_profile_name,
                dataflow_name=dataflow_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class RegistryEndpointOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`registry_endpoint` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_instance_resource(self, resource_group_name: str, instance_name: str, **kwargs: Any) -> Iterable[JSON]:
        # pylint: disable=line-too-long
        """List RegistryEndpointResource resources by InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                registry_endpoint_authentication = {
                    "anonymousSettings": {},  # Anonymous authentication properties. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ArtifactPullSecret":
                registry_endpoint_authentication = {
                    "artifactPullSecretSettings": {
                        "secretRef": "str"  # The name of the kubernetes secret that contains
                          the artifact pull secret. Required.
                    },
                    "method": "ArtifactPullSecret"
                }

                # JSON input template for discriminator value "SystemAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "SystemAssignedManagedIdentity",
                    "systemAssignedManagedIdentitySettings": {
                        "audience": "str"  # Optional. Audience of the service to
                          authenticate against. Optional; defaults to the audience for Service host
                          configuration.
                    }
                }

                # JSON input template for discriminator value "UserAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "UserAssignedManagedIdentity",
                    "userAssignedManagedIdentitySettings": {
                        "clientId": "str",  # Client ID for the user-assigned managed
                          identity. Required.
                        "tenantId": "str",  # Tenant ID. Required.
                        "scope": "str"  # Optional. Resource identifier (application ID URI)
                          of the resource, affixed with the .default suffix.
                    }
                }

                # JSON input template for discriminator value "ConfigMap":
                registry_endpoint_trusted_signing_key = {
                    "configMapRef": "str",  # The name of the configmap. Required.
                    "type": "ConfigMap"
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": registry_endpoint_authentication,
                        "host": "str",  # The Container Registry endpoint hostname. Required.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "trustSettings": {
                            "trustedSigningKeys": registry_endpoint_trusted_signing_key
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_registry_endpoint_list_by_instance_resource_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                _request.url = self._client.format_url(_request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                _request.url = self._client.format_url(_request.url)

            return _request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                if _stream:
                    response.read()  # Load the body in memory and close the socket
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, instance_name: str, registry_endpoint_name: str, **kwargs: Any) -> JSON:
        # pylint: disable=line-too-long
        """Get a RegistryEndpointResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param registry_endpoint_name: Name of RegistryEndpoint resource. Required.
        :type registry_endpoint_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                registry_endpoint_authentication = {
                    "anonymousSettings": {},  # Anonymous authentication properties. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ArtifactPullSecret":
                registry_endpoint_authentication = {
                    "artifactPullSecretSettings": {
                        "secretRef": "str"  # The name of the kubernetes secret that contains
                          the artifact pull secret. Required.
                    },
                    "method": "ArtifactPullSecret"
                }

                # JSON input template for discriminator value "SystemAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "SystemAssignedManagedIdentity",
                    "systemAssignedManagedIdentitySettings": {
                        "audience": "str"  # Optional. Audience of the service to
                          authenticate against. Optional; defaults to the audience for Service host
                          configuration.
                    }
                }

                # JSON input template for discriminator value "UserAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "UserAssignedManagedIdentity",
                    "userAssignedManagedIdentitySettings": {
                        "clientId": "str",  # Client ID for the user-assigned managed
                          identity. Required.
                        "tenantId": "str",  # Tenant ID. Required.
                        "scope": "str"  # Optional. Resource identifier (application ID URI)
                          of the resource, affixed with the .default suffix.
                    }
                }

                # JSON input template for discriminator value "ConfigMap":
                registry_endpoint_trusted_signing_key = {
                    "configMapRef": "str",  # The name of the configmap. Required.
                    "type": "ConfigMap"
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": registry_endpoint_authentication,
                        "host": "str",  # The Container Registry endpoint hostname. Required.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "trustSettings": {
                            "trustedSigningKeys": registry_endpoint_trusted_signing_key
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_registry_endpoint_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            registry_endpoint_name=registry_endpoint_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        registry_endpoint_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> JSON:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        _request = build_registry_endpoint_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            registry_endpoint_name=registry_endpoint_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        registry_endpoint_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a RegistryEndpointResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param registry_endpoint_name: Name of RegistryEndpoint resource. Required.
        :type registry_endpoint_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                registry_endpoint_authentication = {
                    "anonymousSettings": {},  # Anonymous authentication properties. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ArtifactPullSecret":
                registry_endpoint_authentication = {
                    "artifactPullSecretSettings": {
                        "secretRef": "str"  # The name of the kubernetes secret that contains
                          the artifact pull secret. Required.
                    },
                    "method": "ArtifactPullSecret"
                }

                # JSON input template for discriminator value "SystemAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "SystemAssignedManagedIdentity",
                    "systemAssignedManagedIdentitySettings": {
                        "audience": "str"  # Optional. Audience of the service to
                          authenticate against. Optional; defaults to the audience for Service host
                          configuration.
                    }
                }

                # JSON input template for discriminator value "UserAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "UserAssignedManagedIdentity",
                    "userAssignedManagedIdentitySettings": {
                        "clientId": "str",  # Client ID for the user-assigned managed
                          identity. Required.
                        "tenantId": "str",  # Tenant ID. Required.
                        "scope": "str"  # Optional. Resource identifier (application ID URI)
                          of the resource, affixed with the .default suffix.
                    }
                }

                # JSON input template for discriminator value "ConfigMap":
                registry_endpoint_trusted_signing_key = {
                    "configMapRef": "str",  # The name of the configmap. Required.
                    "type": "ConfigMap"
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": registry_endpoint_authentication,
                        "host": "str",  # The Container Registry endpoint hostname. Required.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "trustSettings": {
                            "trustedSigningKeys": registry_endpoint_trusted_signing_key
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                registry_endpoint_authentication = {
                    "anonymousSettings": {},  # Anonymous authentication properties. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ArtifactPullSecret":
                registry_endpoint_authentication = {
                    "artifactPullSecretSettings": {
                        "secretRef": "str"  # The name of the kubernetes secret that contains
                          the artifact pull secret. Required.
                    },
                    "method": "ArtifactPullSecret"
                }

                # JSON input template for discriminator value "SystemAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "SystemAssignedManagedIdentity",
                    "systemAssignedManagedIdentitySettings": {
                        "audience": "str"  # Optional. Audience of the service to
                          authenticate against. Optional; defaults to the audience for Service host
                          configuration.
                    }
                }

                # JSON input template for discriminator value "UserAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "UserAssignedManagedIdentity",
                    "userAssignedManagedIdentitySettings": {
                        "clientId": "str",  # Client ID for the user-assigned managed
                          identity. Required.
                        "tenantId": "str",  # Tenant ID. Required.
                        "scope": "str"  # Optional. Resource identifier (application ID URI)
                          of the resource, affixed with the .default suffix.
                    }
                }

                # JSON input template for discriminator value "ConfigMap":
                registry_endpoint_trusted_signing_key = {
                    "configMapRef": "str",  # The name of the configmap. Required.
                    "type": "ConfigMap"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                registry_endpoint_authentication = {
                    "anonymousSettings": {},  # Anonymous authentication properties. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ArtifactPullSecret":
                registry_endpoint_authentication = {
                    "artifactPullSecretSettings": {
                        "secretRef": "str"  # The name of the kubernetes secret that contains
                          the artifact pull secret. Required.
                    },
                    "method": "ArtifactPullSecret"
                }

                # JSON input template for discriminator value "SystemAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "SystemAssignedManagedIdentity",
                    "systemAssignedManagedIdentitySettings": {
                        "audience": "str"  # Optional. Audience of the service to
                          authenticate against. Optional; defaults to the audience for Service host
                          configuration.
                    }
                }

                # JSON input template for discriminator value "UserAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "UserAssignedManagedIdentity",
                    "userAssignedManagedIdentitySettings": {
                        "clientId": "str",  # Client ID for the user-assigned managed
                          identity. Required.
                        "tenantId": "str",  # Tenant ID. Required.
                        "scope": "str"  # Optional. Resource identifier (application ID URI)
                          of the resource, affixed with the .default suffix.
                    }
                }

                # JSON input template for discriminator value "ConfigMap":
                registry_endpoint_trusted_signing_key = {
                    "configMapRef": "str",  # The name of the configmap. Required.
                    "type": "ConfigMap"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": registry_endpoint_authentication,
                        "host": "str",  # The Container Registry endpoint hostname. Required.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "trustSettings": {
                            "trustedSigningKeys": registry_endpoint_trusted_signing_key
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        registry_endpoint_name: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a RegistryEndpointResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param registry_endpoint_name: Name of RegistryEndpoint resource. Required.
        :type registry_endpoint_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                registry_endpoint_authentication = {
                    "anonymousSettings": {},  # Anonymous authentication properties. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ArtifactPullSecret":
                registry_endpoint_authentication = {
                    "artifactPullSecretSettings": {
                        "secretRef": "str"  # The name of the kubernetes secret that contains
                          the artifact pull secret. Required.
                    },
                    "method": "ArtifactPullSecret"
                }

                # JSON input template for discriminator value "SystemAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "SystemAssignedManagedIdentity",
                    "systemAssignedManagedIdentitySettings": {
                        "audience": "str"  # Optional. Audience of the service to
                          authenticate against. Optional; defaults to the audience for Service host
                          configuration.
                    }
                }

                # JSON input template for discriminator value "UserAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "UserAssignedManagedIdentity",
                    "userAssignedManagedIdentitySettings": {
                        "clientId": "str",  # Client ID for the user-assigned managed
                          identity. Required.
                        "tenantId": "str",  # Tenant ID. Required.
                        "scope": "str"  # Optional. Resource identifier (application ID URI)
                          of the resource, affixed with the .default suffix.
                    }
                }

                # JSON input template for discriminator value "ConfigMap":
                registry_endpoint_trusted_signing_key = {
                    "configMapRef": "str",  # The name of the configmap. Required.
                    "type": "ConfigMap"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                registry_endpoint_authentication = {
                    "anonymousSettings": {},  # Anonymous authentication properties. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ArtifactPullSecret":
                registry_endpoint_authentication = {
                    "artifactPullSecretSettings": {
                        "secretRef": "str"  # The name of the kubernetes secret that contains
                          the artifact pull secret. Required.
                    },
                    "method": "ArtifactPullSecret"
                }

                # JSON input template for discriminator value "SystemAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "SystemAssignedManagedIdentity",
                    "systemAssignedManagedIdentitySettings": {
                        "audience": "str"  # Optional. Audience of the service to
                          authenticate against. Optional; defaults to the audience for Service host
                          configuration.
                    }
                }

                # JSON input template for discriminator value "UserAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "UserAssignedManagedIdentity",
                    "userAssignedManagedIdentitySettings": {
                        "clientId": "str",  # Client ID for the user-assigned managed
                          identity. Required.
                        "tenantId": "str",  # Tenant ID. Required.
                        "scope": "str"  # Optional. Resource identifier (application ID URI)
                          of the resource, affixed with the .default suffix.
                    }
                }

                # JSON input template for discriminator value "ConfigMap":
                registry_endpoint_trusted_signing_key = {
                    "configMapRef": "str",  # The name of the configmap. Required.
                    "type": "ConfigMap"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": registry_endpoint_authentication,
                        "host": "str",  # The Container Registry endpoint hostname. Required.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "trustSettings": {
                            "trustedSigningKeys": registry_endpoint_trusted_signing_key
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        registry_endpoint_name: str,
        resource: Union[JSON, IO[bytes]],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        # pylint: disable=line-too-long
        """Create a RegistryEndpointResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param registry_endpoint_name: Name of RegistryEndpoint resource. Required.
        :type registry_endpoint_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO[bytes] type.
         Required.
        :type resource: JSON or IO[bytes]
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                registry_endpoint_authentication = {
                    "anonymousSettings": {},  # Anonymous authentication properties. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ArtifactPullSecret":
                registry_endpoint_authentication = {
                    "artifactPullSecretSettings": {
                        "secretRef": "str"  # The name of the kubernetes secret that contains
                          the artifact pull secret. Required.
                    },
                    "method": "ArtifactPullSecret"
                }

                # JSON input template for discriminator value "SystemAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "SystemAssignedManagedIdentity",
                    "systemAssignedManagedIdentitySettings": {
                        "audience": "str"  # Optional. Audience of the service to
                          authenticate against. Optional; defaults to the audience for Service host
                          configuration.
                    }
                }

                # JSON input template for discriminator value "UserAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "UserAssignedManagedIdentity",
                    "userAssignedManagedIdentitySettings": {
                        "clientId": "str",  # Client ID for the user-assigned managed
                          identity. Required.
                        "tenantId": "str",  # Tenant ID. Required.
                        "scope": "str"  # Optional. Resource identifier (application ID URI)
                          of the resource, affixed with the .default suffix.
                    }
                }

                # JSON input template for discriminator value "ConfigMap":
                registry_endpoint_trusted_signing_key = {
                    "configMapRef": "str",  # The name of the configmap. Required.
                    "type": "ConfigMap"
                }

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": registry_endpoint_authentication,
                        "host": "str",  # The Container Registry endpoint hostname. Required.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "trustSettings": {
                            "trustedSigningKeys": registry_endpoint_trusted_signing_key
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                registry_endpoint_authentication = {
                    "anonymousSettings": {},  # Anonymous authentication properties. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ArtifactPullSecret":
                registry_endpoint_authentication = {
                    "artifactPullSecretSettings": {
                        "secretRef": "str"  # The name of the kubernetes secret that contains
                          the artifact pull secret. Required.
                    },
                    "method": "ArtifactPullSecret"
                }

                # JSON input template for discriminator value "SystemAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "SystemAssignedManagedIdentity",
                    "systemAssignedManagedIdentitySettings": {
                        "audience": "str"  # Optional. Audience of the service to
                          authenticate against. Optional; defaults to the audience for Service host
                          configuration.
                    }
                }

                # JSON input template for discriminator value "UserAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "UserAssignedManagedIdentity",
                    "userAssignedManagedIdentitySettings": {
                        "clientId": "str",  # Client ID for the user-assigned managed
                          identity. Required.
                        "tenantId": "str",  # Tenant ID. Required.
                        "scope": "str"  # Optional. Resource identifier (application ID URI)
                          of the resource, affixed with the .default suffix.
                    }
                }

                # JSON input template for discriminator value "ConfigMap":
                registry_endpoint_trusted_signing_key = {
                    "configMapRef": "str",  # The name of the configmap. Required.
                    "type": "ConfigMap"
                }

                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "method":

                # JSON input template for discriminator value "Anonymous":
                registry_endpoint_authentication = {
                    "anonymousSettings": {},  # Anonymous authentication properties. Required.
                    "method": "Anonymous"
                }

                # JSON input template for discriminator value "ArtifactPullSecret":
                registry_endpoint_authentication = {
                    "artifactPullSecretSettings": {
                        "secretRef": "str"  # The name of the kubernetes secret that contains
                          the artifact pull secret. Required.
                    },
                    "method": "ArtifactPullSecret"
                }

                # JSON input template for discriminator value "SystemAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "SystemAssignedManagedIdentity",
                    "systemAssignedManagedIdentitySettings": {
                        "audience": "str"  # Optional. Audience of the service to
                          authenticate against. Optional; defaults to the audience for Service host
                          configuration.
                    }
                }

                # JSON input template for discriminator value "UserAssignedManagedIdentity":
                registry_endpoint_authentication = {
                    "method": "UserAssignedManagedIdentity",
                    "userAssignedManagedIdentitySettings": {
                        "clientId": "str",  # Client ID for the user-assigned managed
                          identity. Required.
                        "tenantId": "str",  # Tenant ID. Required.
                        "scope": "str"  # Optional. Resource identifier (application ID URI)
                          of the resource, affixed with the .default suffix.
                    }
                }

                # JSON input template for discriminator value "ConfigMap":
                registry_endpoint_trusted_signing_key = {
                    "configMapRef": "str",  # The name of the configmap. Required.
                    "type": "ConfigMap"
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": registry_endpoint_authentication,
                        "host": "str",  # The Container Registry endpoint hostname. Required.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "trustSettings": {
                            "trustedSigningKeys": registry_endpoint_trusted_signing_key
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                registry_endpoint_name=registry_endpoint_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[JSON].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[JSON](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, registry_endpoint_name: str, **kwargs: Any
    ) -> None:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_registry_endpoint_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            registry_endpoint_name=registry_endpoint_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, registry_endpoint_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a RegistryEndpointResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param registry_endpoint_name: Name of RegistryEndpoint resource. Required.
        :type registry_endpoint_name: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                registry_endpoint_name=registry_endpoint_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
