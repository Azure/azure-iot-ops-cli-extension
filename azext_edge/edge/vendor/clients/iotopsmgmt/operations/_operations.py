# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer
from .._vendor import _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Private.IoTOperations/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Private.IoTOperations/instances"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances"
    )
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_get_request(
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_create_or_update_request(
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_update_request(
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_instance_delete_request(
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_list_by_instance_resource_request(
    resource_group_name: str, instance_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_get_request(
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_create_or_update_request(
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_update_request(
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_delete_request(
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authentication_list_by_broker_resource_request(
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authentications"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authentication_get_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authentication_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authentications/{authenticationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authenticationName": _SERIALIZER.url(
            "authentication_name",
            authentication_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authentication_create_or_update_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authentication_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authentications/{authenticationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authenticationName": _SERIALIZER.url(
            "authentication_name",
            authentication_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authentication_update_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authentication_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authentications/{authenticationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authenticationName": _SERIALIZER.url(
            "authentication_name",
            authentication_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authentication_delete_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authentication_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authentications/{authenticationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authenticationName": _SERIALIZER.url(
            "authentication_name",
            authentication_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authorization_list_by_broker_resource_request(
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authorizations"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authorization_get_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authorization_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authorizations/{authorizationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authorizationName": _SERIALIZER.url(
            "authorization_name",
            authorization_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authorization_create_or_update_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authorization_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authorizations/{authorizationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authorizationName": _SERIALIZER.url(
            "authorization_name",
            authorization_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authorization_update_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authorization_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authorizations/{authorizationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authorizationName": _SERIALIZER.url(
            "authorization_name",
            authorization_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_authorization_delete_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    authorization_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/authorizations/{authorizationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "authorizationName": _SERIALIZER.url(
            "authorization_name",
            authorization_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_listener_list_by_broker_resource_request(
    resource_group_name: str, instance_name: str, broker_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/listeners"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_listener_get_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    listener_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/listeners/{listenerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "listenerName": _SERIALIZER.url(
            "listener_name", listener_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_listener_create_or_update_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    listener_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/listeners/{listenerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "listenerName": _SERIALIZER.url(
            "listener_name", listener_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_listener_update_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    listener_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/listeners/{listenerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "listenerName": _SERIALIZER.url(
            "listener_name", listener_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_broker_listener_delete_request(
    resource_group_name: str,
    instance_name: str,
    broker_name: str,
    listener_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-06-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Private.IoTOperations/instances/{instanceName}/brokers/{brokerName}/listeners/{listenerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "instanceName": _SERIALIZER.url(
            "instance_name", instance_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "brokerName": _SERIALIZER.url(
            "broker_name", broker_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "listenerName": _SERIALIZER.url(
            "listener_name", listener_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """List the operations for the provider.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actionType": "str",  # Optional. Enum. Indicates the action type. "Internal"
                      refers to actions that are for internal only APIs. "Internal"
                    "display": {
                        "description": "str",  # Optional. The short, localized friendly
                          description of the operation; suitable for tool tips and detailed views.
                        "operation": "str",  # Optional. The concise, localized friendly name
                          for the operation; suitable for dropdowns. E.g. "Create or Update Virtual
                          Machine", "Restart Virtual Machine".
                        "provider": "str",  # Optional. The localized friendly form of the
                          resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft
                          Compute".
                        "resource": "str"  # Optional. The localized friendly name of the
                          resource type related to this operation. E.g. "Virtual Machines" or "Job
                          Schedule Collections".
                    },
                    "isDataAction": bool,  # Optional. Whether the operation applies to
                      data-plane. This is "true" for data-plane operations and "false" for
                      ARM/control-plane operations.
                    "name": "str",  # Optional. The name of the operation, as per Resource-Based
                      Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write",
                      "Microsoft.Compute/virtualMachines/capture/action".
                    "origin": "str"  # Optional. The intended executor of the operation; as in
                      Resource Based Access Control (RBAC) and audit logs UX. Default value is
                      "user,system". Known values are: "user", "system", and "user,system".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class InstanceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`instance` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List InstanceResource resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_instance_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List InstanceResource resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_instance_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, instance_name: str, **kwargs: Any) -> JSON:
        """Get a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_instance_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_update_initial(
        self, resource_group_name: str, instance_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_instance_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self, resource_group_name: str, instance_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def update(self, resource_group_name: str, instance_name: str, properties: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Update a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Detailed description of the
                          Instance.
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "version": "str"  # Optional. The Azure IoT Operations version.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_instance_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_instance_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(self, resource_group_name: str, instance_name: str, **kwargs: Any) -> LROPoller[None]:
        """Delete a InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class BrokerOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`broker` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_instance_resource(self, resource_group_name: str, instance_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List BrokerResource resources by InstanceResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            },
                            "tolerations": {
                                "effect": "str",  # Toleration effect. Required.
                                "key": "str",  # Toleration key. Required.
                                "operator": "str",  # Toleration operator like
                                  'Exists', 'Equal' etc. Required. Known values are: "Equal" and
                                  "Exists".
                                "value": "str"  # Toleration Value. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the logs to the open telemetry
                                  collector.
                                "exportLogLevel": "error",  # Optional. Default value
                                  is "error". The level of logs to export.
                                "level": "info",  # Optional. Default value is
                                  "info". The log level. Examples - 'debug', 'info', 'warn', 'error',
                                  'trace'.
                                "openTelemetryCollectorAddress": "str"  # Optional.
                                  The open telemetry collector endpoint to export to.
                            },
                            "metrics": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable metrics. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "prometheusPort": 9600,  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                                "stalenessTimeSeconds": 600,  # Optional. Default
                                  value is 600. The time used to determine if a metric is stale and
                                  drop from the metrics cache.
                                "updateIntervalSeconds": 30  # Optional. Default
                                  value is 30. How often to refresh the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_broker_list_by_instance_resource_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any) -> JSON:
        """Get a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            },
                            "tolerations": {
                                "effect": "str",  # Toleration effect. Required.
                                "key": "str",  # Toleration key. Required.
                                "operator": "str",  # Toleration operator like
                                  'Exists', 'Equal' etc. Required. Known values are: "Equal" and
                                  "Exists".
                                "value": "str"  # Toleration Value. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the logs to the open telemetry
                                  collector.
                                "exportLogLevel": "error",  # Optional. Default value
                                  is "error". The level of logs to export.
                                "level": "info",  # Optional. Default value is
                                  "info". The log level. Examples - 'debug', 'info', 'warn', 'error',
                                  'trace'.
                                "openTelemetryCollectorAddress": "str"  # Optional.
                                  The open telemetry collector endpoint to export to.
                            },
                            "metrics": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable metrics. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "prometheusPort": 9600,  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                                "stalenessTimeSeconds": 600,  # Optional. Default
                                  value is 600. The time used to determine if a metric is stale and
                                  drop from the metrics cache.
                                "updateIntervalSeconds": 30  # Optional. Default
                                  value is 30. How often to refresh the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_broker_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_update_initial(
        self, resource_group_name: str, instance_name: str, broker_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_broker_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            },
                            "tolerations": {
                                "effect": "str",  # Toleration effect. Required.
                                "key": "str",  # Toleration key. Required.
                                "operator": "str",  # Toleration operator like
                                  'Exists', 'Equal' etc. Required. Known values are: "Equal" and
                                  "Exists".
                                "value": "str"  # Toleration Value. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the logs to the open telemetry
                                  collector.
                                "exportLogLevel": "error",  # Optional. Default value
                                  is "error". The level of logs to export.
                                "level": "info",  # Optional. Default value is
                                  "info". The log level. Examples - 'debug', 'info', 'warn', 'error',
                                  'trace'.
                                "openTelemetryCollectorAddress": "str"  # Optional.
                                  The open telemetry collector endpoint to export to.
                            },
                            "metrics": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable metrics. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "prometheusPort": 9600,  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                                "stalenessTimeSeconds": 600,  # Optional. Default
                                  value is 600. The time used to determine if a metric is stale and
                                  drop from the metrics cache.
                                "updateIntervalSeconds": 30  # Optional. Default
                                  value is 30. How often to refresh the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            },
                            "tolerations": {
                                "effect": "str",  # Toleration effect. Required.
                                "key": "str",  # Toleration key. Required.
                                "operator": "str",  # Toleration operator like
                                  'Exists', 'Equal' etc. Required. Known values are: "Equal" and
                                  "Exists".
                                "value": "str"  # Toleration Value. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the logs to the open telemetry
                                  collector.
                                "exportLogLevel": "error",  # Optional. Default value
                                  is "error". The level of logs to export.
                                "level": "info",  # Optional. Default value is
                                  "info". The log level. Examples - 'debug', 'info', 'warn', 'error',
                                  'trace'.
                                "openTelemetryCollectorAddress": "str"  # Optional.
                                  The open telemetry collector endpoint to export to.
                            },
                            "metrics": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable metrics. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "prometheusPort": 9600,  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                                "stalenessTimeSeconds": 600,  # Optional. Default
                                  value is 600. The time used to determine if a metric is stale and
                                  drop from the metrics cache.
                                "updateIntervalSeconds": 30  # Optional. Default
                                  value is 30. How often to refresh the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            },
                            "tolerations": {
                                "effect": "str",  # Toleration effect. Required.
                                "key": "str",  # Toleration key. Required.
                                "operator": "str",  # Toleration operator like
                                  'Exists', 'Equal' etc. Required. Known values are: "Equal" and
                                  "Exists".
                                "value": "str"  # Toleration Value. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the logs to the open telemetry
                                  collector.
                                "exportLogLevel": "error",  # Optional. Default value
                                  is "error". The level of logs to export.
                                "level": "info",  # Optional. Default value is
                                  "info". The log level. Examples - 'debug', 'info', 'warn', 'error',
                                  'trace'.
                                "openTelemetryCollectorAddress": "str"  # Optional.
                                  The open telemetry collector endpoint to export to.
                            },
                            "metrics": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable metrics. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "prometheusPort": 9600,  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                                "stalenessTimeSeconds": 600,  # Optional. Default
                                  value is 600. The time used to determine if a metric is stale and
                                  drop from the metrics cache.
                                "updateIntervalSeconds": 30  # Optional. Default
                                  value is 30. How often to refresh the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self, resource_group_name: str, instance_name: str, broker_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            },
                            "tolerations": {
                                "effect": "str",  # Toleration effect. Required.
                                "key": "str",  # Toleration key. Required.
                                "operator": "str",  # Toleration operator like
                                  'Exists', 'Equal' etc. Required. Known values are: "Equal" and
                                  "Exists".
                                "value": "str"  # Toleration Value. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the logs to the open telemetry
                                  collector.
                                "exportLogLevel": "error",  # Optional. Default value
                                  is "error". The level of logs to export.
                                "level": "info",  # Optional. Default value is
                                  "info". The log level. Examples - 'debug', 'info', 'warn', 'error',
                                  'trace'.
                                "openTelemetryCollectorAddress": "str"  # Optional.
                                  The open telemetry collector endpoint to export to.
                            },
                            "metrics": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable metrics. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "prometheusPort": 9600,  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                                "stalenessTimeSeconds": 600,  # Optional. Default
                                  value is 600. The time used to determine if a metric is stale and
                                  drop from the metrics cache.
                                "updateIntervalSeconds": 30  # Optional. Default
                                  value is 30. How often to refresh the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            },
                            "tolerations": {
                                "effect": "str",  # Toleration effect. Required.
                                "key": "str",  # Toleration key. Required.
                                "operator": "str",  # Toleration operator like
                                  'Exists', 'Equal' etc. Required. Known values are: "Equal" and
                                  "Exists".
                                "value": "str"  # Toleration Value. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the logs to the open telemetry
                                  collector.
                                "exportLogLevel": "error",  # Optional. Default value
                                  is "error". The level of logs to export.
                                "level": "info",  # Optional. Default value is
                                  "info". The log level. Examples - 'debug', 'info', 'warn', 'error',
                                  'trace'.
                                "openTelemetryCollectorAddress": "str"  # Optional.
                                  The open telemetry collector endpoint to export to.
                            },
                            "metrics": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable metrics. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "prometheusPort": 9600,  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                                "stalenessTimeSeconds": 600,  # Optional. Default
                                  value is 600. The time used to determine if a metric is stale and
                                  drop from the metrics cache.
                                "updateIntervalSeconds": 30  # Optional. Default
                                  value is 30. How often to refresh the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            },
                            "tolerations": {
                                "effect": "str",  # Toleration effect. Required.
                                "key": "str",  # Toleration key. Required.
                                "operator": "str",  # Toleration operator like
                                  'Exists', 'Equal' etc. Required. Known values are: "Equal" and
                                  "Exists".
                                "value": "str"  # Toleration Value. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the logs to the open telemetry
                                  collector.
                                "exportLogLevel": "error",  # Optional. Default value
                                  is "error". The level of logs to export.
                                "level": "info",  # Optional. Default value is
                                  "info". The log level. Examples - 'debug', 'info', 'warn', 'error',
                                  'trace'.
                                "openTelemetryCollectorAddress": "str"  # Optional.
                                  The open telemetry collector endpoint to export to.
                            },
                            "metrics": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable metrics. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "prometheusPort": 9600,  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                                "stalenessTimeSeconds": 600,  # Optional. Default
                                  value is 600. The time used to determine if a metric is stale and
                                  drop from the metrics cache.
                                "updateIntervalSeconds": 30  # Optional. Default
                                  value is 30. How often to refresh the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            },
                            "tolerations": {
                                "effect": "str",  # Toleration effect. Required.
                                "key": "str",  # Toleration key. Required.
                                "operator": "str",  # Toleration operator like
                                  'Exists', 'Equal' etc. Required. Known values are: "Equal" and
                                  "Exists".
                                "value": "str"  # Toleration Value. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the logs to the open telemetry
                                  collector.
                                "exportLogLevel": "error",  # Optional. Default value
                                  is "error". The level of logs to export.
                                "level": "info",  # Optional. Default value is
                                  "info". The log level. Examples - 'debug', 'info', 'warn', 'error',
                                  'trace'.
                                "openTelemetryCollectorAddress": "str"  # Optional.
                                  The open telemetry collector endpoint to export to.
                            },
                            "metrics": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable metrics. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "prometheusPort": 9600,  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                                "stalenessTimeSeconds": 600,  # Optional. Default
                                  value is 600. The time used to determine if a metric is stale and
                                  drop from the metrics cache.
                                "updateIntervalSeconds": 30  # Optional. Default
                                  value is 30. How often to refresh the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def update(
        self, resource_group_name: str, instance_name: str, broker_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Update a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "advanced": {
                            "clients": {
                                "maxKeepAliveSeconds": 0,  # Optional. Upper bound of
                                  a client's Keep Alive, in seconds.
                                "maxMessageExpirySeconds": 0,  # Optional. Upper
                                  bound of Message Expiry Interval, in seconds.
                                "maxReceiveMaximum": 0,  # Optional. Upper bound of
                                  Receive Maximum that a client can request in the CONNECT packet.
                                "maxSessionExpirySeconds": 0,  # Optional. Upper
                                  bound of Session Expiry Interval, in seconds.
                                "subscriberQueueLimit": {
                                    "length": 0,  # Optional. The maximum length
                                      of the queue before messages start getting dropped.
                                    "strategy": "str"  # Optional. The strategy
                                      to use for dropping messages from the queue. Known values are:
                                      "None" and "DropOldest".
                                }
                            },
                            "encryptInternalTraffic": "str",  # Optional. The setting to
                              enable or disable encryption of internal Traffic. Known values are:
                              "Enabled" and "Disabled".
                            "internalCerts": {
                                "duration": "str",  # Lifetime of certificate. Must
                                  be specified using a Go time.Duration format (h|m|s). E.g. 240h for
                                  240 hours and 45m for 45 minutes. Required.
                                "privateKey": {
                                    "algorithm": "str",  # algorithm for private
                                      key. Required. Known values are: "Ec256", "Ec384", "Ec521",
                                      "Ed25519", "Rsa2048", "Rsa4096", and "Rsa8192".
                                    "rotationPolicy": "str"  # cert-manager
                                      private key rotationPolicy. Required. Known values are: "Always"
                                      and "Never".
                                },
                                "renewBefore": "str"  # When to begin renewing
                                  certificate. Must be specified using a Go time.Duration format
                                  (h|m|s). E.g. 240h for 240 hours and 45m for 45 minutes. Required.
                            },
                            "tolerations": {
                                "effect": "str",  # Toleration effect. Required.
                                "key": "str",  # Toleration key. Required.
                                "operator": "str",  # Toleration operator like
                                  'Exists', 'Equal' etc. Required. Known values are: "Equal" and
                                  "Exists".
                                "value": "str"  # Toleration Value. Required.
                            }
                        },
                        "cardinality": {
                            "backendChain": {
                                "partitions": 0,  # The desired number of physical
                                  backend partitions. Required.
                                "redundancyFactor": 0,  # The desired numbers of
                                  backend replicas (pods) in a physical partition. Required.
                                "workers": 1  # Optional. Default value is 1. Number
                                  of logical backend workers per replica (pod).
                            },
                            "frontend": {
                                "replicas": 0,  # The desired number of frontend
                                  instances (pods). Required.
                                "workers": 2  # Optional. Default value is 2. Number
                                  of logical frontend workers per instance (pod).
                            }
                        },
                        "diagnostics": {
                            "logs": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the logs to the open telemetry
                                  collector.
                                "exportLogLevel": "error",  # Optional. Default value
                                  is "error". The level of logs to export.
                                "level": "info",  # Optional. Default value is
                                  "info". The log level. Examples - 'debug', 'info', 'warn', 'error',
                                  'trace'.
                                "openTelemetryCollectorAddress": "str"  # Optional.
                                  The open telemetry collector endpoint to export to.
                            },
                            "metrics": {
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable metrics. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "prometheusPort": 9600,  # Optional. Default value is
                                  9600. The prometheus port to expose the metrics.
                                "stalenessTimeSeconds": 600,  # Optional. Default
                                  value is 600. The time used to determine if a metric is stale and
                                  drop from the metrics cache.
                                "updateIntervalSeconds": 30  # Optional. Default
                                  value is 30. How often to refresh the metrics.
                            },
                            "selfCheck": {
                                "intervalSeconds": 30,  # Optional. Default value is
                                  30. The self check interval.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable self check. Known values are: "Enabled" and
                                  "Disabled".
                                "timeoutSeconds": 15  # Optional. Default value is
                                  15. The timeout for self check.
                            },
                            "traces": {
                                "cacheSizeMegabytes": 16,  # Optional. Default value
                                  is 16. The cache size in megabytes.
                                "exportIntervalSeconds": 30,  # Optional. Default
                                  value is 30. How often to export the metrics to the open telemetry
                                  collector.
                                "mode": "str",  # Optional. The toggle to
                                  enable/disable traces. Known values are: "Enabled" and "Disabled".
                                "openTelemetryCollectorAddress": "str",  # Optional.
                                  The open telemetry collector endpoint to export to.
                                "selfTracing": {
                                    "intervalSeconds": 30,  # Optional. Default
                                      value is 30. The self tracing interval.
                                    "mode": "str"  # Optional. The toggle to
                                      enable/disable self tracing. Known values are: "Enabled" and
                                      "Disabled".
                                },
                                "spanChannelCapacity": 1000  # Optional. Default
                                  value is 1000. The span channel capacity.
                            }
                        },
                        "diskBackedMessageBuffer": {
                            "maxSize": "str",  # The max size of the message buffer on
                              disk. If a PVC template is specified using one of
                              ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is
                              used as the request and limit sizes of that template. If neither
                              ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified,
                              then an emptyDir volume is mounted with this size as its limit. See
                              https://kubernetes.io/docs/concepts/storage/volumes/#emptydir for
                              details. Required.
                            "ephemeralVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            },
                            "persistentVolumeClaimSpec": {
                                "accessModes": [
                                    "str"  # Optional. AccessModes contains the
                                      desired access modes the volume should have. More info:
                                      https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1.
                                ],
                                "dataSource": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "dataSourceRef": {
                                    "kind": "str",  # Kind is the type of
                                      resource being referenced. Required.
                                    "name": "str",  # Name is the name of
                                      resource being referenced. Required.
                                    "apiGroup": "str"  # Optional. APIGroup is
                                      the group for the resource being referenced. If APIGroup is not
                                      specified, the specified Kind must be in the core API group. For
                                      any other third-party types, APIGroup is required.
                                },
                                "resources": {
                                    "limits": {
                                        "str": "str"  # Optional. Limits
                                          describes the maximum amount of compute resources allowed.
                                          More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    },
                                    "requests": {
                                        "str": "str"  # Optional. Requests
                                          describes the minimum amount of compute resources required.
                                          If Requests is omitted for a container, it defaults to Limits
                                          if that is explicitly specified, otherwise to an
                                          implementation-defined value. More info:
                                          https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/.
                                    }
                                },
                                "selector": {
                                    "matchExpressions": [
                                        {
                                            "key": "str",  # key is the
                                              label key that the selector applies to. Required.
                                            "operator": "str",  #
                                              operator represents a key's relationship to a set of
                                              values. Valid operators are In, NotIn, Exists and
                                              DoesNotExist. Required. Known values are: "In", "NotIn",
                                              "Exists", and "DoesNotExist".
                                            "values": [
                                                "str"  # Optional.
                                                  values is an array of string values. If the operator
                                                  is In or NotIn, the values array must be non-empty.
                                                  If the operator is Exists or DoesNotExist, the values
                                                  array must be empty. This array is replaced during a
                                                  strategic merge patch.
                                            ]
                                        }
                                    ],
                                    "matchLabels": {
                                        "str": "str"  # Optional. MatchLabels
                                          is a map of {key,value} pairs. A single {key,value} in the
                                          matchLabels map is equivalent to an element of
                                          matchExpressions, whose key field is "key", the operator is
                                          "In", and the values array contains only "value". The
                                          requirements are ANDed.
                                    }
                                },
                                "storageClassName": "str",  # Optional. Name of the
                                  StorageClass required by the claim. More info:
                                  https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1.
                                "volumeMode": "str",  # Optional. volumeMode defines
                                  what type of volume is required by the claim. Value of Filesystem is
                                  implied when not included in claim spec. This is a beta feature.
                                "volumeName": "str"  # Optional. VolumeName is the
                                  binding reference to the PersistentVolume backing this claim.
                            }
                        },
                        "generateResourceLimits": {
                            "cpu": "str"  # Optional. The toggle to enable/disable cpu
                              resource limits. Known values are: "Enabled" and "Disabled".
                        },
                        "memoryProfile": "str",  # Optional. Memory profile of Broker. Known
                          values are: "Tiny", "Low", "Medium", and "High".
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_broker_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_broker_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class BrokerAuthenticationOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`broker_authentication` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_broker_resource(
        self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        """List BrokerAuthenticationResource resources by BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "custom": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretName": "str",  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                            "secretNamespace": "str"  #
                                              Optional. Certificate K8S namespace. Omit to use current
                                              namespace.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "sat": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509": {
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_broker_authentication_list_by_broker_resource_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    broker_name=broker_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self, resource_group_name: str, instance_name: str, broker_name: str, authentication_name: str, **kwargs: Any
    ) -> JSON:
        """Get a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "custom": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretName": "str",  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                            "secretNamespace": "str"  #
                                              Optional. Certificate K8S namespace. Omit to use current
                                              namespace.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "sat": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509": {
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_broker_authentication_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authentication_name=authentication_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authentication_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_broker_authentication_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authentication_name=authentication_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authentication_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "custom": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretName": "str",  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                            "secretNamespace": "str"  #
                                              Optional. Certificate K8S namespace. Omit to use current
                                              namespace.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "sat": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509": {
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "custom": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretName": "str",  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                            "secretNamespace": "str"  #
                                              Optional. Certificate K8S namespace. Omit to use current
                                              namespace.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "sat": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509": {
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authentication_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "custom": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretName": "str",  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                            "secretNamespace": "str"  #
                                              Optional. Certificate K8S namespace. Omit to use current
                                              namespace.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "sat": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509": {
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authentication_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "custom": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretName": "str",  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                            "secretNamespace": "str"  #
                                              Optional. Certificate K8S namespace. Omit to use current
                                              namespace.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "sat": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509": {
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "custom": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretName": "str",  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                            "secretNamespace": "str"  #
                                              Optional. Certificate K8S namespace. Omit to use current
                                              namespace.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "sat": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509": {
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                authentication_name=authentication_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authentication_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "custom": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretName": "str",  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                            "secretNamespace": "str"  #
                                              Optional. Certificate K8S namespace. Omit to use current
                                              namespace.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "sat": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509": {
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authentication_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "custom": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretName": "str",  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                            "secretNamespace": "str"  #
                                              Optional. Certificate K8S namespace. Omit to use current
                                              namespace.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "sat": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509": {
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authentication_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Update a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authenticationMethods": [
                            {
                                "custom": {
                                    "endpoint": "str",  # Endpoint of the custom
                                      authentication server. Must be an HTTPS endpoint. Required.
                                    "auth": {
                                        "x509": {
                                            "secretName": "str",  #
                                              Kubernetes secret containing an X.509 client certificate.
                                              This is a reference to the secret through an identifying
                                              name, not the secret itself. Required.
                                            "secretNamespace": "str"  #
                                              Optional. Certificate K8S namespace. Omit to use current
                                              namespace.
                                        }
                                    },
                                    "caCertConfigMap": "str",  # Optional.
                                      Optional CA certificate for validating the custom authentication
                                      server's certificate.
                                    "headers": {
                                        "str": "str"  # Optional. Additional
                                          HTTP headers to pass to the custom authentication server.
                                    }
                                },
                                "sat": {
                                    "audiences": [
                                        "str"  # List of allowed audience.
                                          Required.
                                    ]
                                },
                                "x509": {
                                    "authorizationAttributes": {
                                        "str": {
                                            "attributes": {
                                                "str": "str"  #
                                                  Attributes object. Required.
                                            },
                                            "subject": "str"  # Subject
                                              of the X509 attribute. Required.
                                        }
                                    },
                                    "trustedClientCaCert": "client-ca"  #
                                      Optional. Default value is "client-ca". Name of the trusted
                                      client ca cert resource.
                                }
                            }
                        ],
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_broker_authentication_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authentication_name=authentication_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, broker_name: str, authentication_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_broker_authentication_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authentication_name=authentication_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, broker_name: str, authentication_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a BrokerAuthenticationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authentication_name: Name of Instance broker authentication resource. Required.
        :type authentication_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                authentication_name=authentication_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class BrokerAuthorizationOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`broker_authorization` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_broker_resource(
        self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        """List BrokerAuthorizationResource resources by BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a MQTT method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_broker_authorization_list_by_broker_resource_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    broker_name=broker_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self, resource_group_name: str, instance_name: str, broker_name: str, authorization_name: str, **kwargs: Any
    ) -> JSON:
        """Get a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a MQTT method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_broker_authorization_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authorization_name=authorization_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authorization_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_broker_authorization_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authorization_name=authorization_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authorization_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a MQTT method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a MQTT method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authorization_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a MQTT method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authorization_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a MQTT method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a MQTT method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                authorization_name=authorization_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authorization_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a MQTT method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authorization_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a MQTT method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        authorization_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Update a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authorizationPolicies": {
                            "cache": "str",  # Optional. Enable caching of the
                              authorization rules. Known values are: "Enabled" and "Disabled".
                            "rules": [
                                {
                                    "brokerResources": [
                                        {
                                            "method": "str",  # Give
                                              access for a MQTT method (i.e., Connect, Subscribe, or
                                              Publish). Required. Known values are: "Connect",
                                              "Publish", and "Subscribe".
                                            "topics": [
                                                "str"  # Optional. A
                                                  list of topics or topic patterns that match the
                                                  topics that the clients can publish or subscribe to.
                                                  This subfield is required if the method is Publish or
                                                  Subscribe.
                                            ]
                                        }
                                    ],
                                    "principals": {
                                        "attributes": [
                                            {
                                                "str": "str"  #
                                                  Optional. A list of key-value pairs that match the
                                                  attributes of the clients. The attributes are
                                                  case-sensitive and must match the attributes provided
                                                  by the clients during authentication.
                                            }
                                        ],
                                        "clientIds": [
                                            "str"  # Optional. A list of
                                              client IDs that match the clients. The client IDs are
                                              case-sensitive and must match the client IDs provided by
                                              the clients during connection.
                                        ],
                                        "usernames": [
                                            "str"  # Optional. A list of
                                              usernames that match the clients. The usernames are
                                              case-sensitive and must match the usernames provided by
                                              the clients during authentication.
                                        ]
                                    },
                                    "stateStoreResources": [
                                        {
                                            "keyType": "str",  # Allowed
                                              keyTypes pattern, string, binary. The key type used for
                                              matching, for example pattern tries to match the key to a
                                              glob-style pattern and string checks key is equal to
                                              value provided in keys. Required. Known values are:
                                              "Pattern", "String", and "Binary".
                                            "keys": [
                                                "str"  # Give access
                                                  to state store keys for the corresponding principals
                                                  defined. When key type is pattern set glob-style
                                                  pattern (e.g., '"" *', 'clients/*"" '). Required.
                                            ],
                                            "method": "str"  # Give
                                              access for ``Read``"" , ``Write`` and ``ReadWrite``
                                              access level. Required. Known values are: "Read",
                                              "Write", and "ReadWrite".
                                        }
                                    ]
                                }
                            ]
                        },
                        "provisioningState": "str"  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_broker_authorization_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authorization_name=authorization_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, broker_name: str, authorization_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_broker_authorization_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            authorization_name=authorization_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, broker_name: str, authorization_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a BrokerAuthorizationResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param authorization_name: Name of Instance broker authorization resource. Required.
        :type authorization_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                authorization_name=authorization_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class BrokerListenerOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~aziotops.mgmt.MicrosoftIoTOperationsManagementService`'s
        :attr:`broker_listener` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_broker_resource(
        self, resource_group_name: str, instance_name: str, broker_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        """List BrokerListenerResource resources by BrokerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "brokerRef": "str",  # Broker associated with this listener.
                          Required.
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "automatic": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str",  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    },
                                    "manual": {
                                        "secretName": "str",  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "aio-mq-dmqtt-frontend",  # Optional. Default value is
                          "aio-mq-dmqtt-frontend". Kubernetes Service name of this listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_broker_listener_list_by_broker_resource_request(
                    resource_group_name=resource_group_name,
                    instance_name=instance_name,
                    broker_name=broker_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self, resource_group_name: str, instance_name: str, broker_name: str, listener_name: str, **kwargs: Any
    ) -> JSON:
        """Get a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "brokerRef": "str",  # Broker associated with this listener.
                          Required.
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "automatic": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str",  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    },
                                    "manual": {
                                        "secretName": "str",  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "aio-mq-dmqtt-frontend",  # Optional. Default value is
                          "aio-mq-dmqtt-frontend". Kubernetes Service name of this listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_broker_listener_get_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            listener_name=listener_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        listener_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_broker_listener_create_or_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            listener_name=listener_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        listener_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "brokerRef": "str",  # Broker associated with this listener.
                          Required.
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "automatic": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str",  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    },
                                    "manual": {
                                        "secretName": "str",  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "aio-mq-dmqtt-frontend",  # Optional. Default value is
                          "aio-mq-dmqtt-frontend". Kubernetes Service name of this listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "brokerRef": "str",  # Broker associated with this listener.
                          Required.
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "automatic": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str",  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    },
                                    "manual": {
                                        "secretName": "str",  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "aio-mq-dmqtt-frontend",  # Optional. Default value is
                          "aio-mq-dmqtt-frontend". Kubernetes Service name of this listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        listener_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "brokerRef": "str",  # Broker associated with this listener.
                          Required.
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "automatic": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str",  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    },
                                    "manual": {
                                        "secretName": "str",  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "aio-mq-dmqtt-frontend",  # Optional. Default value is
                          "aio-mq-dmqtt-frontend". Kubernetes Service name of this listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        listener_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "brokerRef": "str",  # Broker associated with this listener.
                          Required.
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "automatic": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str",  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    },
                                    "manual": {
                                        "secretName": "str",  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "aio-mq-dmqtt-frontend",  # Optional. Default value is
                          "aio-mq-dmqtt-frontend". Kubernetes Service name of this listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "brokerRef": "str",  # Broker associated with this listener.
                          Required.
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "automatic": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str",  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    },
                                    "manual": {
                                        "secretName": "str",  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "aio-mq-dmqtt-frontend",  # Optional. Default value is
                          "aio-mq-dmqtt-frontend". Kubernetes Service name of this listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                listener_name=listener_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        listener_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "brokerRef": "str",  # Broker associated with this listener.
                          Required.
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "automatic": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str",  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    },
                                    "manual": {
                                        "secretName": "str",  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "aio-mq-dmqtt-frontend",  # Optional. Default value is
                          "aio-mq-dmqtt-frontend". Kubernetes Service name of this listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        listener_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "brokerRef": "str",  # Broker associated with this listener.
                          Required.
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "automatic": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str",  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    },
                                    "manual": {
                                        "secretName": "str",  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "aio-mq-dmqtt-frontend",  # Optional. Default value is
                          "aio-mq-dmqtt-frontend". Kubernetes Service name of this listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def update(
        self,
        resource_group_name: str,
        instance_name: str,
        broker_name: str,
        listener_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Update a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # Type of ExtendedLocation. Required. "CustomLocation"
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "brokerRef": "str",  # Broker associated with this listener.
                          Required.
                        "ports": [
                            {
                                "port": 0,  # TCP port for accepting client
                                  connections. Required.
                                "authenticationRef": "str",  # Optional. Reference to
                                  client authentication settings. Omit to disable authentication.
                                "authorizationRef": "str",  # Optional. Reference to
                                  client authorization settings. Omit to disable authorization.
                                "nodePort": 0,  # Optional. Kubernetes node port.
                                  Only relevant when this port is associated with a ``NodePort``
                                  listener.
                                "protocol": "str",  # Optional. Protocol to use for
                                  client connections. Known values are: "Mqtt" and "WebSockets".
                                "tls": {
                                    "automatic": {
                                        "issuerRef": {
                                            "group": "cert-manager.io",
                                              # Default value is "cert-manager.io". group of issuer.
                                            "kind": "str",  # kind of
                                              issuer (Issuer or ClusterIssuer). Required. Known values
                                              are: "Issuer" and "ClusterIssuer".
                                            "name": "str"  # name of
                                              issuer. Required.
                                        },
                                        "duration": "str",  # Optional.
                                          Lifetime of certificate. Must be specified using a Go
                                          time.Duration format (h|m|s). E.g. 240h for 240 hours and 45m
                                          for 45 minutes.
                                        "privateKey": {
                                            "algorithm": "str",  #
                                              algorithm for private key. Required. Known values are:
                                              "Ec256", "Ec384", "Ec521", "Ed25519", "Rsa2048",
                                              "Rsa4096", and "Rsa8192".
                                            "rotationPolicy": "str"  #
                                              cert-manager private key rotationPolicy. Required. Known
                                              values are: "Always" and "Never".
                                        },
                                        "renewBefore": "str",  # Optional.
                                          When to begin renewing certificate. Must be specified using a
                                          Go time.Duration format (h|m|s). E.g. 240h for 240 hours and
                                          45m for 45 minutes.
                                        "san": {
                                            "dns": [
                                                "str"  # DNS SANs.
                                                  Required.
                                            ],
                                            "ip": [
                                                "str"  # IP address
                                                  SANs. Required.
                                            ]
                                        },
                                        "secretName": "str",  # Optional.
                                          Secret for storing server certificate. Any existing data will
                                          be overwritten. This is a reference to the secret through an
                                          identifying name, not the secret itself.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    },
                                    "manual": {
                                        "secretName": "str",  # Kubernetes
                                          secret containing an X.509 client certificate. This is a
                                          reference to the secret through an identifying name, not the
                                          secret itself. Required.
                                        "secretNamespace": "str"  # Optional.
                                          Certificate K8S namespace. Omit to use current namespace.
                                    }
                                }
                            }
                        ],
                        "provisioningState": "str",  # Optional. The status of the last
                          operation. Known values are: "Succeeded", "Failed", "Canceled",
                          "Provisioning", "Updating", "Deleting", and "Accepted".
                        "serviceName": "aio-mq-dmqtt-frontend",  # Optional. Default value is
                          "aio-mq-dmqtt-frontend". Kubernetes Service name of this listener.
                        "serviceType": "str"  # Optional. Kubernetes Service type of this
                          listener. Known values are: "ClusterIp", "LoadBalancer", and "NodePort".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_broker_listener_update_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            listener_name=listener_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, instance_name: str, broker_name: str, listener_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_broker_listener_delete_request(
            resource_group_name=resource_group_name,
            instance_name=instance_name,
            broker_name=broker_name,
            listener_name=listener_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, instance_name: str, broker_name: str, listener_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a BrokerListenerResource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param instance_name: Name of instance. Required.
        :type instance_name: str
        :param broker_name: Name of broker. Required.
        :type broker_name: str
        :param listener_name: Name of Instance broker listener resource. Required.
        :type listener_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                instance_name=instance_name,
                broker_name=broker_name,
                listener_name=listener_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
