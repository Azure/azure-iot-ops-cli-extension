# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer
from .._vendor import _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.DeviceRegistry/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_get_request(
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetEndpointProfileName": _SERIALIZER.url(
            "asset_endpoint_profile_name",
            asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_create_or_replace_request(
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetEndpointProfileName": _SERIALIZER.url(
            "asset_endpoint_profile_name",
            asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_update_request(
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetEndpointProfileName": _SERIALIZER.url(
            "asset_endpoint_profile_name",
            asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_delete_request(
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetEndpointProfileName": _SERIALIZER.url(
            "asset_endpoint_profile_name",
            asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/assets"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets"
    )
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_get_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_create_or_replace_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_update_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_delete_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_billing_containers_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/billingContainers"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_billing_containers_get_request(
    billing_container_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/billingContainers/{billingContainerName}"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "billingContainerName": _SERIALIZER.url(
            "billing_container_name",
            billing_container_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[0-9a-zA-Z][a-zA-Z0-9-]*$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_asset_endpoint_profiles_list_by_subscription_request(
    subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/discoveredAssetEndpointProfiles"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_asset_endpoint_profiles_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/discoveredAssetEndpointProfiles"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_asset_endpoint_profiles_get_request(
    resource_group_name: str, discovered_asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/discoveredAssetEndpointProfiles/{discoveredAssetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "discoveredAssetEndpointProfileName": _SERIALIZER.url(
            "discovered_asset_endpoint_profile_name",
            discovered_asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_asset_endpoint_profiles_create_or_replace_request(
    resource_group_name: str, discovered_asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/discoveredAssetEndpointProfiles/{discoveredAssetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "discoveredAssetEndpointProfileName": _SERIALIZER.url(
            "discovered_asset_endpoint_profile_name",
            discovered_asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_asset_endpoint_profiles_update_request(
    resource_group_name: str, discovered_asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/discoveredAssetEndpointProfiles/{discoveredAssetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "discoveredAssetEndpointProfileName": _SERIALIZER.url(
            "discovered_asset_endpoint_profile_name",
            discovered_asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_asset_endpoint_profiles_delete_request(
    resource_group_name: str, discovered_asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/discoveredAssetEndpointProfiles/{discoveredAssetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "discoveredAssetEndpointProfileName": _SERIALIZER.url(
            "discovered_asset_endpoint_profile_name",
            discovered_asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_assets_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/discoveredAssets"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_assets_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/discoveredAssets"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_assets_get_request(
    resource_group_name: str, discovered_asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/discoveredAssets/{discoveredAssetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "discoveredAssetName": _SERIALIZER.url(
            "discovered_asset_name",
            discovered_asset_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_assets_create_or_replace_request(
    resource_group_name: str, discovered_asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/discoveredAssets/{discoveredAssetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "discoveredAssetName": _SERIALIZER.url(
            "discovered_asset_name",
            discovered_asset_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_assets_update_request(
    resource_group_name: str, discovered_asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/discoveredAssets/{discoveredAssetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "discoveredAssetName": _SERIALIZER.url(
            "discovered_asset_name",
            discovered_asset_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_discovered_assets_delete_request(
    resource_group_name: str, discovered_asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/discoveredAssets/{discoveredAssetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "discoveredAssetName": _SERIALIZER.url(
            "discovered_asset_name",
            discovered_asset_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_operation_status_get_request(
    location: str, operation_id: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/locations/{location}/operationStatuses/{operationId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "location": _SERIALIZER.url("location", location, "str", min_length=1),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/schemaRegistries"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_get_request(
    resource_group_name: str, schema_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_create_or_replace_request(
    resource_group_name: str, schema_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_update_request(
    resource_group_name: str, schema_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_delete_request(
    resource_group_name: str, schema_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_list_by_schema_registry_request(
    resource_group_name: str, schema_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_get_request(
    resource_group_name: str, schema_registry_name: str, schema_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_create_or_replace_request(
    resource_group_name: str, schema_registry_name: str, schema_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_delete_request(
    resource_group_name: str, schema_registry_name: str, schema_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_versions_list_by_schema_request(
    resource_group_name: str, schema_registry_name: str, schema_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}/schemaVersions"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_versions_get_request(
    resource_group_name: str,
    schema_registry_name: str,
    schema_name: str,
    schema_version_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}/schemaVersions/{schemaVersionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "schemaVersionName": _SERIALIZER.url(
            "schema_version_name", schema_version_name, "str", max_length=10, min_length=1, pattern=r"^[0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_versions_create_or_replace_request(
    resource_group_name: str,
    schema_registry_name: str,
    schema_name: str,
    schema_version_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}/schemaVersions/{schemaVersionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "schemaVersionName": _SERIALIZER.url(
            "schema_version_name", schema_version_name, "str", max_length=10, min_length=1, pattern=r"^[0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_versions_delete_request(
    resource_group_name: str,
    schema_registry_name: str,
    schema_name: str,
    schema_version_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-09-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}/schemaVersions/{schemaVersionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "schemaVersionName": _SERIALIZER.url(
            "schema_version_name", schema_version_name, "str", max_length=10, min_length=1, pattern=r"^[0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~deviceregistry.mgmt.MicrosoftDeviceRegistryManagementService`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """List the operations for the provider.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actionType": "str",  # Optional. Enum. Indicates the action type. "Internal"
                      refers to actions that are for internal only APIs. "Internal"
                    "display": {
                        "description": "str",  # Optional. The short, localized friendly
                          description of the operation; suitable for tool tips and detailed views.
                        "operation": "str",  # Optional. The concise, localized friendly name
                          for the operation; suitable for dropdowns. E.g. "Create or Update Virtual
                          Machine", "Restart Virtual Machine".
                        "provider": "str",  # Optional. The localized friendly form of the
                          resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft
                          Compute".
                        "resource": "str"  # Optional. The localized friendly name of the
                          resource type related to this operation. E.g. "Virtual Machines" or "Job
                          Schedule Collections".
                    },
                    "isDataAction": bool,  # Optional. Whether the operation applies to
                      data-plane. This is "true" for data-plane operations and "false" for
                      ARM/control-plane operations.
                    "name": "str",  # Optional. The name of the operation, as per Resource-Based
                      Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write",
                      "Microsoft.Compute/virtualMachines/capture/action".
                    "origin": "str"  # Optional. The intended executor of the operation; as in
                      Resource Based Access Control (RBAC) and audit logs UX. Default value is
                      "user,system". Known values are: "user", "system", and "user,system".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class AssetEndpointProfilesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~deviceregistry.mgmt.MicrosoftDeviceRegistryManagementService`'s
        :attr:`asset_endpoint_profiles` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List AssetEndpointProfile resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_asset_endpoint_profiles_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List AssetEndpointProfile resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_asset_endpoint_profiles_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, asset_endpoint_profile_name: str, **kwargs: Any) -> JSON:
        """Get a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_asset_endpoint_profiles_get_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self, resource_group_name: str, asset_endpoint_profile_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_asset_endpoint_profiles_create_or_replace_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self, resource_group_name: str, asset_endpoint_profile_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                asset_endpoint_profile_name=asset_endpoint_profile_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, resource_group_name: str, asset_endpoint_profile_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_asset_endpoint_profiles_update_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Optional. Defines the method to
                              authenticate the user of the client at the server. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # Optional. The name of
                                  the secret containing the password.
                                "usernameSecretName": "str"  # Optional. The name of
                                  the secret containing the username.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # Optional. The name
                                  of the secret containing the certificate and private key (e.g. stored
                                  as .der/.pem or .der/.pfx).
                            }
                        },
                        "endpointProfileType": "str",  # Optional. Defines the configuration
                          for the connector type that is being used with the endpoint profile.
                        "targetAddress": "str"  # Optional. The local valid URI specifying
                          the network address/DNS name of a southbound device. The scheme part of the
                          targetAddress URI specifies the type of the device. The
                          additionalConfiguration field holds further connector type specific
                          configuration.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_group_name: str, asset_endpoint_profile_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Optional. Defines the method to
                              authenticate the user of the client at the server. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # Optional. The name of
                                  the secret containing the password.
                                "usernameSecretName": "str"  # Optional. The name of
                                  the secret containing the username.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # Optional. The name
                                  of the secret containing the certificate and private key (e.g. stored
                                  as .der/.pem or .der/.pfx).
                            }
                        },
                        "endpointProfileType": "str",  # Optional. Defines the configuration
                          for the connector type that is being used with the endpoint profile.
                        "targetAddress": "str"  # Optional. The local valid URI specifying
                          the network address/DNS name of a southbound device. The scheme part of the
                          targetAddress URI specifies the type of the device. The
                          additionalConfiguration field holds further connector type specific
                          configuration.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                asset_endpoint_profile_name=asset_endpoint_profile_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, asset_endpoint_profile_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_asset_endpoint_profiles_delete_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, asset_endpoint_profile_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                asset_endpoint_profile_name=asset_endpoint_profile_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class AssetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~deviceregistry.mgmt.MicrosoftDeviceRegistryManagementService`'s
        :attr:`assets` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List Asset resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_assets_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List Asset resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_assets_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, asset_name: str, **kwargs: Any) -> JSON:
        """Get a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_assets_get_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self, resource_group_name: str, asset_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_assets_create_or_replace_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self, resource_group_name: str, asset_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                asset_name=asset_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, resource_group_name: str, asset_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_assets_update_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # Optional. The topic path for messages
                              published to an MQTT broker.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_group_name: str, asset_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # Optional. The topic path for messages
                              published to an MQTT broker.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "None"  #
                                          Optional. Default value is "None". An indication of how the
                                          data point should be mapped to OpenTelemetry. Known values
                                          are: "None", "Counter", "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "None",  # Optional. Default
                                  value is "None". An indication of how the event should be mapped to
                                  OpenTelemetry. Known values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                asset_name=asset_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, asset_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_assets_delete_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(self, resource_group_name: str, asset_name: str, **kwargs: Any) -> LROPoller[None]:
        """Delete a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: Asset name parameter. Required.
        :type asset_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                asset_name=asset_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class BillingContainersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~deviceregistry.mgmt.MicrosoftDeviceRegistryManagementService`'s
        :attr:`billing_containers` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List BillingContainer resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",  # Optional. Resource ETag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_billing_containers_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, billing_container_name: str, **kwargs: Any) -> JSON:
        """Get a BillingContainer.

        :param billing_container_name: Name of the billing container. Required.
        :type billing_container_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",  # Optional. Resource ETag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_billing_containers_get_request(
            billing_container_name=billing_container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class DiscoveredAssetEndpointProfilesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~deviceregistry.mgmt.MicrosoftDeviceRegistryManagementService`'s
        :attr:`discovered_asset_endpoint_profiles` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List DiscoveredAssetEndpointProfile resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset endpoint profile. Required.
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_discovered_asset_endpoint_profiles_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List DiscoveredAssetEndpointProfile resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset endpoint profile. Required.
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_discovered_asset_endpoint_profiles_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, discovered_asset_endpoint_profile_name: str, **kwargs: Any) -> JSON:
        """Get a DiscoveredAssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_endpoint_profile_name: Discovered Asset Endpoint Profile name
         parameter. Required.
        :type discovered_asset_endpoint_profile_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset endpoint profile. Required.
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_discovered_asset_endpoint_profiles_get_request(
            resource_group_name=resource_group_name,
            discovered_asset_endpoint_profile_name=discovered_asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self,
        resource_group_name: str,
        discovered_asset_endpoint_profile_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_discovered_asset_endpoint_profiles_create_or_replace_request(
            resource_group_name=resource_group_name,
            discovered_asset_endpoint_profile_name=discovered_asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        discovered_asset_endpoint_profile_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a DiscoveredAssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_endpoint_profile_name: Discovered Asset Endpoint Profile name
         parameter. Required.
        :type discovered_asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset endpoint profile. Required.
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset endpoint profile. Required.
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        discovered_asset_endpoint_profile_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a DiscoveredAssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_endpoint_profile_name: Discovered Asset Endpoint Profile name
         parameter. Required.
        :type discovered_asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset endpoint profile. Required.
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        discovered_asset_endpoint_profile_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a DiscoveredAssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_endpoint_profile_name: Discovered Asset Endpoint Profile name
         parameter. Required.
        :type discovered_asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset endpoint profile. Required.
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset endpoint profile. Required.
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                discovered_asset_endpoint_profile_name=discovered_asset_endpoint_profile_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        discovered_asset_endpoint_profile_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_discovered_asset_endpoint_profiles_update_request(
            resource_group_name=resource_group_name,
            discovered_asset_endpoint_profile_name=discovered_asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        discovered_asset_endpoint_profile_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a DiscoveredAssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_endpoint_profile_name: Discovered Asset Endpoint Profile name
         parameter. Required.
        :type discovered_asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "discoveryId": "str",  # Optional. Identifier used to detect changes
                          in the asset endpoint profile.
                        "endpointProfileType": "str",  # Optional. Defines the configuration
                          for the connector type that is being used with the endpoint profile.
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ],
                        "targetAddress": "str",  # Optional. The local valid URI specifying
                          the network address/DNS name of a southbound device. The scheme part of the
                          targetAddress URI specifies the type of the device. The
                          additionalConfiguration field holds further connector type specific
                          configuration.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset endpoint profile. Required.
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        discovered_asset_endpoint_profile_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a DiscoveredAssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_endpoint_profile_name: Discovered Asset Endpoint Profile name
         parameter. Required.
        :type discovered_asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset endpoint profile. Required.
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        discovered_asset_endpoint_profile_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a DiscoveredAssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_endpoint_profile_name: Discovered Asset Endpoint Profile name
         parameter. Required.
        :type discovered_asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "discoveryId": "str",  # Optional. Identifier used to detect changes
                          in the asset endpoint profile.
                        "endpointProfileType": "str",  # Optional. Defines the configuration
                          for the connector type that is being used with the endpoint profile.
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ],
                        "targetAddress": "str",  # Optional. The local valid URI specifying
                          the network address/DNS name of a southbound device. The scheme part of the
                          targetAddress URI specifies the type of the device. The
                          additionalConfiguration field holds further connector type specific
                          configuration.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset endpoint profile. Required.
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g. OPC UA,
                          Modbus, ONVIF).
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "supportedAuthenticationMethods": [
                            "str"  # Optional. List of supported authentication methods
                              supported by the target server.
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                discovered_asset_endpoint_profile_name=discovered_asset_endpoint_profile_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, discovered_asset_endpoint_profile_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_discovered_asset_endpoint_profiles_delete_request(
            resource_group_name=resource_group_name,
            discovered_asset_endpoint_profile_name=discovered_asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, discovered_asset_endpoint_profile_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a DiscoveredAssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_endpoint_profile_name: Discovered Asset Endpoint Profile name
         parameter. Required.
        :type discovered_asset_endpoint_profile_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                discovered_asset_endpoint_profile_name=discovered_asset_endpoint_profile_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class DiscoveredAssetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~deviceregistry.mgmt.MicrosoftDeviceRegistryManagementService`'s
        :attr:`discovered_assets` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List DiscoveredAsset resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_discovered_assets_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List DiscoveredAsset resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_discovered_assets_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, discovered_asset_name: str, **kwargs: Any) -> JSON:
        """Get a DiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_name: Discovered Asset name parameter. Required.
        :type discovered_asset_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_discovered_assets_get_request(
            resource_group_name=resource_group_name,
            discovered_asset_name=discovered_asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self, resource_group_name: str, discovered_asset_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_discovered_assets_create_or_replace_request(
            resource_group_name=resource_group_name,
            discovered_asset_name=discovered_asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        discovered_asset_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a DiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_name: Discovered Asset name parameter. Required.
        :type discovered_asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        discovered_asset_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a DiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_name: Discovered Asset name parameter. Required.
        :type discovered_asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self, resource_group_name: str, discovered_asset_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a DiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_name: Discovered Asset name parameter. Required.
        :type discovered_asset_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                discovered_asset_name=discovered_asset_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, resource_group_name: str, discovered_asset_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_discovered_assets_update_request(
            resource_group_name=resource_group_name,
            discovered_asset_name=discovered_asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        discovered_asset_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a DiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_name: Discovered Asset name parameter. Required.
        :type discovered_asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # Optional. The topic path for messages
                              published to an MQTT broker.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "discoveryId": "str",  # Optional. Identifier used to detect changes
                          in the asset.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        discovered_asset_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a DiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_name: Discovered Asset name parameter. Required.
        :type discovered_asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_group_name: str, discovered_asset_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a DiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_name: Discovered Asset name parameter. Required.
        :type discovered_asset_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # Optional. The topic path for messages
                              published to an MQTT broker.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "discoveryId": "str",  # Optional. Identifier used to detect changes
                          in the asset.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                discovered_asset_name=discovered_asset_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, discovered_asset_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_discovered_assets_delete_request(
            resource_group_name=resource_group_name,
            discovered_asset_name=discovered_asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(self, resource_group_name: str, discovered_asset_name: str, **kwargs: Any) -> LROPoller[None]:
        """Delete a DiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param discovered_asset_name: Discovered Asset name parameter. Required.
        :type discovered_asset_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                discovered_asset_name=discovered_asset_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class OperationStatusOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~deviceregistry.mgmt.MicrosoftDeviceRegistryManagementService`'s
        :attr:`operation_status` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, location: str, operation_id: str, **kwargs: Any) -> JSON:
        """Returns the current status of an async operation.

        :param location: The name of the Azure region. Required.
        :type location: str
        :param operation_id: The ID of an ongoing async operation. Required.
        :type operation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "status": "str",  # Operation status. Required.
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the operation.
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "id": "str",  # Optional. Fully qualified ID for the async operation.
                    "name": "str",  # Optional. Name of the async operation.
                    "operations": [
                        ...
                    ],
                    "percentComplete": 0.0,  # Optional. Percent of the operation that is
                      complete.
                    "resourceId": "str",  # Optional. Fully qualified ID of the resource against
                      which the original async operation was started.
                    "startTime": "2020-02-20 00:00:00"  # Optional. The start time of the
                      operation.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_operation_status_get_request(
            location=location,
            operation_id=operation_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class SchemaRegistriesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~deviceregistry.mgmt.MicrosoftDeviceRegistryManagementService`'s
        :attr:`schema_registries` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List SchemaRegistry resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_schema_registries_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List SchemaRegistry resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_schema_registries_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, schema_registry_name: str, **kwargs: Any) -> JSON:
        """Get a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_schema_registries_get_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self, resource_group_name: str, schema_registry_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_schema_registries_create_or_replace_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self, resource_group_name: str, schema_registry_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                schema_registry_name=schema_registry_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, resource_group_name: str, schema_registry_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_schema_registries_update_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "properties": {
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str"  # Optional. Human-readable display name.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_group_name: str, schema_registry_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "properties": {
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str"  # Optional. Human-readable display name.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                schema_registry_name=schema_registry_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, schema_registry_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_schema_registries_delete_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(self, resource_group_name: str, schema_registry_name: str, **kwargs: Any) -> LROPoller[None]:
        """Delete a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                schema_registry_name=schema_registry_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class SchemasOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~deviceregistry.mgmt.MicrosoftDeviceRegistryManagementService`'s
        :attr:`schemas` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_schema_registry(
        self, resource_group_name: str, schema_registry_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        """List Schema resources by SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_schemas_list_by_schema_registry_request(
                    resource_group_name=resource_group_name,
                    schema_registry_name=schema_registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, schema_registry_name: str, schema_name: str, **kwargs: Any) -> JSON:
        """Get a Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_schemas_get_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Create a Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_schemas_create_or_replace_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, schema_registry_name: str, schema_name: str, **kwargs: Any
    ) -> None:
        """Delete a Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_schemas_delete_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class SchemaVersionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~deviceregistry.mgmt.MicrosoftDeviceRegistryManagementService`'s
        :attr:`schema_versions` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_schema(
        self, resource_group_name: str, schema_registry_name: str, schema_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        """List SchemaVersion resources by Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_schema_versions_list_by_schema_request(
                    resource_group_name=resource_group_name,
                    schema_registry_name=schema_registry_name,
                    schema_name=schema_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        schema_version_name: str,
        **kwargs: Any
    ) -> JSON:
        """Get a SchemaVersion.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param schema_version_name: Schema version name parameter. Required.
        :type schema_version_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_schema_versions_get_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            schema_version_name=schema_version_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        schema_version_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a SchemaVersion.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param schema_version_name: Schema version name parameter. Required.
        :type schema_version_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        schema_version_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a SchemaVersion.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param schema_version_name: Schema version name parameter. Required.
        :type schema_version_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        schema_version_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Create a SchemaVersion.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param schema_version_name: Schema version name parameter. Required.
        :type schema_version_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          id.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_schema_versions_create_or_replace_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            schema_version_name=schema_version_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        schema_version_name: str,
        **kwargs: Any
    ) -> None:
        """Delete a SchemaVersion.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param schema_version_name: Schema version name parameter. Required.
        :type schema_version_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_schema_versions_delete_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            schema_version_name=schema_version_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
