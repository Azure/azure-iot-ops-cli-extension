# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer
from .._vendor import _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.SecretSyncController/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_azure_key_vault_secret_provider_classes_list_by_subscription_request(
    subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.SecretSyncController/azureKeyVaultSecretProviderClasses"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_azure_key_vault_secret_provider_classes_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SecretSyncController/azureKeyVaultSecretProviderClasses"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_azure_key_vault_secret_provider_classes_get_request(
    resource_group_name: str, azure_key_vault_secret_provider_class_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SecretSyncController/azureKeyVaultSecretProviderClasses/{azureKeyVaultSecretProviderClassName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "azureKeyVaultSecretProviderClassName": _SERIALIZER.url(
            "azure_key_vault_secret_provider_class_name",
            azure_key_vault_secret_provider_class_name,
            "str",
            pattern=r"^[a-zA-Z0-9-]{3,24}$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_azure_key_vault_secret_provider_classes_create_or_update_request(
    resource_group_name: str, azure_key_vault_secret_provider_class_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SecretSyncController/azureKeyVaultSecretProviderClasses/{azureKeyVaultSecretProviderClassName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "azureKeyVaultSecretProviderClassName": _SERIALIZER.url(
            "azure_key_vault_secret_provider_class_name",
            azure_key_vault_secret_provider_class_name,
            "str",
            pattern=r"^[a-zA-Z0-9-]{3,24}$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_azure_key_vault_secret_provider_classes_update_request(
    resource_group_name: str, azure_key_vault_secret_provider_class_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SecretSyncController/azureKeyVaultSecretProviderClasses/{azureKeyVaultSecretProviderClassName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "azureKeyVaultSecretProviderClassName": _SERIALIZER.url(
            "azure_key_vault_secret_provider_class_name",
            azure_key_vault_secret_provider_class_name,
            "str",
            pattern=r"^[a-zA-Z0-9-]{3,24}$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_azure_key_vault_secret_provider_classes_delete_request(
    resource_group_name: str, azure_key_vault_secret_provider_class_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SecretSyncController/azureKeyVaultSecretProviderClasses/{azureKeyVaultSecretProviderClassName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "azureKeyVaultSecretProviderClassName": _SERIALIZER.url(
            "azure_key_vault_secret_provider_class_name",
            azure_key_vault_secret_provider_class_name,
            "str",
            pattern=r"^[a-zA-Z0-9-]{3,24}$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_secret_syncs_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.SecretSyncController/secretSyncs"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_secret_syncs_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SecretSyncController/secretSyncs"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_secret_syncs_get_request(
    resource_group_name: str, secret_sync_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SecretSyncController/secretSyncs/{secretSyncName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "secretSyncName": _SERIALIZER.url("secret_sync_name", secret_sync_name, "str", pattern=r"^[a-zA-Z0-9-]{3,24}$"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_secret_syncs_create_or_update_request(
    resource_group_name: str, secret_sync_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SecretSyncController/secretSyncs/{secretSyncName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "secretSyncName": _SERIALIZER.url("secret_sync_name", secret_sync_name, "str", pattern=r"^[a-zA-Z0-9-]{3,24}$"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_secret_syncs_update_request(
    resource_group_name: str, secret_sync_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SecretSyncController/secretSyncs/{secretSyncName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "secretSyncName": _SERIALIZER.url("secret_sync_name", secret_sync_name, "str", pattern=r"^[a-zA-Z0-9-]{3,24}$"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_secret_syncs_delete_request(
    resource_group_name: str, secret_sync_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2024-08-21-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.SecretSyncController/secretSyncs/{secretSyncName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "secretSyncName": _SERIALIZER.url("secret_sync_name", secret_sync_name, "str", pattern=r"^[a-zA-Z0-9-]{3,24}$"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~secretsync.mgmt.MicrosoftSecretSyncController`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """List the operations for the provider.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actionType": "str",  # Optional. Enum. Indicates the action type. "Internal"
                      refers to actions that are for internal only APIs. "Internal"
                    "display": {
                        "description": "str",  # Optional. The short, localized friendly
                          description of the operation; suitable for tool tips and detailed views.
                        "operation": "str",  # Optional. The concise, localized friendly name
                          for the operation; suitable for dropdowns. E.g. "Create or Update Virtual
                          Machine", "Restart Virtual Machine".
                        "provider": "str",  # Optional. The localized friendly form of the
                          resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft
                          Compute".
                        "resource": "str"  # Optional. The localized friendly name of the
                          resource type related to this operation. E.g. "Virtual Machines" or "Job
                          Schedule Collections".
                    },
                    "isDataAction": bool,  # Optional. Whether the operation applies to
                      data-plane. This is "true" for data-plane operations and "false" for
                      ARM/control-plane operations.
                    "name": "str",  # Optional. The name of the operation, as per Resource-Based
                      Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write",
                      "Microsoft.Compute/virtualMachines/capture/action".
                    "origin": "str"  # Optional. The intended executor of the operation; as in
                      Resource Based Access Control (RBAC) and audit logs UX. Default value is
                      "user,system". Known values are: "user", "system", and "user,system".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class AzureKeyVaultSecretProviderClassesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~secretsync.mgmt.MicrosoftSecretSyncController`'s
        :attr:`azure_key_vault_secret_provider_classes` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists the AzureKeyVaultSecretProviderClass instances within an Azure subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clientId": "str",  # The user assigned managed identity client ID
                          that should be used to access the Azure Key Vault. Required.
                        "keyvaultName": "str",  # The name of the Azure Key Vault to sync
                          secrets from. Required.
                        "tenantId": "str",  # The Azure Active Directory tenant ID that
                          should be used for authenticating requests to the Azure Key Vault. Required.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          AzureKeyVaultSecretProviderClass instance. Known values are: "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_azure_key_vault_secret_provider_classes_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists the AzureKeyVaultSecretProviderClass instances within a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clientId": "str",  # The user assigned managed identity client ID
                          that should be used to access the Azure Key Vault. Required.
                        "keyvaultName": "str",  # The name of the Azure Key Vault to sync
                          secrets from. Required.
                        "tenantId": "str",  # The Azure Active Directory tenant ID that
                          should be used for authenticating requests to the Azure Key Vault. Required.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          AzureKeyVaultSecretProviderClass instance. Known values are: "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_azure_key_vault_secret_provider_classes_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, azure_key_vault_secret_provider_class_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of an AzureKeyVaultSecretProviderClass instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param azure_key_vault_secret_provider_class_name: The name of the
         AzureKeyVaultSecretProviderClass. Required.
        :type azure_key_vault_secret_provider_class_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clientId": "str",  # The user assigned managed identity client ID
                          that should be used to access the Azure Key Vault. Required.
                        "keyvaultName": "str",  # The name of the Azure Key Vault to sync
                          secrets from. Required.
                        "tenantId": "str",  # The Azure Active Directory tenant ID that
                          should be used for authenticating requests to the Azure Key Vault. Required.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          AzureKeyVaultSecretProviderClass instance. Known values are: "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_azure_key_vault_secret_provider_classes_get_request(
            resource_group_name=resource_group_name,
            azure_key_vault_secret_provider_class_name=azure_key_vault_secret_provider_class_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        azure_key_vault_secret_provider_class_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_azure_key_vault_secret_provider_classes_create_or_update_request(
            resource_group_name=resource_group_name,
            azure_key_vault_secret_provider_class_name=azure_key_vault_secret_provider_class_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        azure_key_vault_secret_provider_class_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates, or updates, an AzureKeyVaultSecretProviderClass instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param azure_key_vault_secret_provider_class_name: The name of the
         AzureKeyVaultSecretProviderClass. Required.
        :type azure_key_vault_secret_provider_class_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clientId": "str",  # The user assigned managed identity client ID
                          that should be used to access the Azure Key Vault. Required.
                        "keyvaultName": "str",  # The name of the Azure Key Vault to sync
                          secrets from. Required.
                        "tenantId": "str",  # The Azure Active Directory tenant ID that
                          should be used for authenticating requests to the Azure Key Vault. Required.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          AzureKeyVaultSecretProviderClass instance. Known values are: "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clientId": "str",  # The user assigned managed identity client ID
                          that should be used to access the Azure Key Vault. Required.
                        "keyvaultName": "str",  # The name of the Azure Key Vault to sync
                          secrets from. Required.
                        "tenantId": "str",  # The Azure Active Directory tenant ID that
                          should be used for authenticating requests to the Azure Key Vault. Required.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          AzureKeyVaultSecretProviderClass instance. Known values are: "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        azure_key_vault_secret_provider_class_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates, or updates, an AzureKeyVaultSecretProviderClass instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param azure_key_vault_secret_provider_class_name: The name of the
         AzureKeyVaultSecretProviderClass. Required.
        :type azure_key_vault_secret_provider_class_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clientId": "str",  # The user assigned managed identity client ID
                          that should be used to access the Azure Key Vault. Required.
                        "keyvaultName": "str",  # The name of the Azure Key Vault to sync
                          secrets from. Required.
                        "tenantId": "str",  # The Azure Active Directory tenant ID that
                          should be used for authenticating requests to the Azure Key Vault. Required.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          AzureKeyVaultSecretProviderClass instance. Known values are: "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        azure_key_vault_secret_provider_class_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates, or updates, an AzureKeyVaultSecretProviderClass instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param azure_key_vault_secret_provider_class_name: The name of the
         AzureKeyVaultSecretProviderClass. Required.
        :type azure_key_vault_secret_provider_class_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clientId": "str",  # The user assigned managed identity client ID
                          that should be used to access the Azure Key Vault. Required.
                        "keyvaultName": "str",  # The name of the Azure Key Vault to sync
                          secrets from. Required.
                        "tenantId": "str",  # The Azure Active Directory tenant ID that
                          should be used for authenticating requests to the Azure Key Vault. Required.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          AzureKeyVaultSecretProviderClass instance. Known values are: "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clientId": "str",  # The user assigned managed identity client ID
                          that should be used to access the Azure Key Vault. Required.
                        "keyvaultName": "str",  # The name of the Azure Key Vault to sync
                          secrets from. Required.
                        "tenantId": "str",  # The Azure Active Directory tenant ID that
                          should be used for authenticating requests to the Azure Key Vault. Required.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          AzureKeyVaultSecretProviderClass instance. Known values are: "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                azure_key_vault_secret_provider_class_name=azure_key_vault_secret_provider_class_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        azure_key_vault_secret_provider_class_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_azure_key_vault_secret_provider_classes_update_request(
            resource_group_name=resource_group_name,
            azure_key_vault_secret_provider_class_name=azure_key_vault_secret_provider_class_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        azure_key_vault_secret_provider_class_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates an AzureKeyVaultSecretProviderClass instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param azure_key_vault_secret_provider_class_name: The name of the
         AzureKeyVaultSecretProviderClass. Required.
        :type azure_key_vault_secret_provider_class_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "clientId": "str",  # Optional. The user assigned managed identity
                          client ID that should be used to access the Azure Key Vault.
                        "keyvaultName": "str",  # Optional. The name of the Azure Key Vault
                          to sync secrets from.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "tenantId": "str"  # Optional. The Azure Active Directory tenant ID
                          that should be used for authenticating requests to the Azure Key Vault.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clientId": "str",  # The user assigned managed identity client ID
                          that should be used to access the Azure Key Vault. Required.
                        "keyvaultName": "str",  # The name of the Azure Key Vault to sync
                          secrets from. Required.
                        "tenantId": "str",  # The Azure Active Directory tenant ID that
                          should be used for authenticating requests to the Azure Key Vault. Required.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          AzureKeyVaultSecretProviderClass instance. Known values are: "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        azure_key_vault_secret_provider_class_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates an AzureKeyVaultSecretProviderClass instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param azure_key_vault_secret_provider_class_name: The name of the
         AzureKeyVaultSecretProviderClass. Required.
        :type azure_key_vault_secret_provider_class_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clientId": "str",  # The user assigned managed identity client ID
                          that should be used to access the Azure Key Vault. Required.
                        "keyvaultName": "str",  # The name of the Azure Key Vault to sync
                          secrets from. Required.
                        "tenantId": "str",  # The Azure Active Directory tenant ID that
                          should be used for authenticating requests to the Azure Key Vault. Required.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          AzureKeyVaultSecretProviderClass instance. Known values are: "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        azure_key_vault_secret_provider_class_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates an AzureKeyVaultSecretProviderClass instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param azure_key_vault_secret_provider_class_name: The name of the
         AzureKeyVaultSecretProviderClass. Required.
        :type azure_key_vault_secret_provider_class_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "clientId": "str",  # Optional. The user assigned managed identity
                          client ID that should be used to access the Azure Key Vault.
                        "keyvaultName": "str",  # Optional. The name of the Azure Key Vault
                          to sync secrets from.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "tenantId": "str"  # Optional. The Azure Active Directory tenant ID
                          that should be used for authenticating requests to the Azure Key Vault.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clientId": "str",  # The user assigned managed identity client ID
                          that should be used to access the Azure Key Vault. Required.
                        "keyvaultName": "str",  # The name of the Azure Key Vault to sync
                          secrets from. Required.
                        "tenantId": "str",  # The Azure Active Directory tenant ID that
                          should be used for authenticating requests to the Azure Key Vault. Required.
                        "objects": "str",  # Optional. Objects defines the desired state of
                          synced K8s secret objects.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          AzureKeyVaultSecretProviderClass instance. Known values are: "Succeeded",
                          "Failed", and "Canceled".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                azure_key_vault_secret_provider_class_name=azure_key_vault_secret_provider_class_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, azure_key_vault_secret_provider_class_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_azure_key_vault_secret_provider_classes_delete_request(
            resource_group_name=resource_group_name,
            azure_key_vault_secret_provider_class_name=azure_key_vault_secret_provider_class_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, azure_key_vault_secret_provider_class_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Deletes an AzureKeyVaultSecretProviderClass instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param azure_key_vault_secret_provider_class_name: The name of the
         AzureKeyVaultSecretProviderClass. Required.
        :type azure_key_vault_secret_provider_class_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                azure_key_vault_secret_provider_class_name=azure_key_vault_secret_provider_class_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class SecretSyncsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~secretsync.mgmt.MicrosoftSecretSyncController`'s
        :attr:`secret_syncs` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists the SecretSync instances within an Azure subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "kubernetesSecretType": "str",  # Type specifies the type of the
                          Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The controller
                          must have permission to create secrets of the specified type. Required. Known
                          values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # SecretProviderClassName
                          specifies the name of the SecretProviderClass resource, which contains the
                          information needed to access the cloud provider secret store. Required.
                        "serviceAccountName": "str",  # ServiceAccountName specifies the name
                          of the service account used to access the cloud provider secret store. The
                          audience field in the service account token must be passed as parameter in
                          the controller configuration. The audience is used when requesting a token
                          from the API server for the service account; the supported audiences are
                          defined by each provider. Required.
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          SecretSync instance. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": {
                            "conditions": [
                                {
                                    "message": "str",  # Message is a human
                                      readable message indicating details about the transition. This
                                      may be an empty string. Required.
                                    "reason": "str",  # Reason contains a
                                      programmatic identifier indicating the reason for the condition's
                                      last transition. Producers of specific condition types may define
                                      expected values and meanings for this field, and whether the
                                      values are considered a guaranteed API. The value should be a
                                      CamelCase string. This field may not be empty. Required.
                                    "status": "str",  # Status of the condition,
                                      one of True, False, Unknown. Required. Known values are: "True",
                                      "False", and "Unknown".
                                    "type": "str",  # Type of condition in
                                      CamelCase or in foo.example.com/CamelCase. Many .condition.type
                                      values are consistent across resources like Available, but
                                      because arbitrary conditions can be useful (see
                                      .node.status.conditions), the ability to de-conflict is
                                      important. The regex it matches is
                                      (dns1123SubdomainFmt/)?(qualifiedNameFmt). Required.
                                    "lastTransitionTime": "2020-02-20 00:00:00",
                                      # Optional. LastTransitionTime is the last time the condition
                                      transitioned from one status to another. This should be when the
                                      underlying condition changed. If that is not known, then using
                                      the time when the API field changed is acceptable.
                                    "observedGeneration": 0  # Optional.
                                      ObservedGeneration represents the .metadata.generation that the
                                      condition was set based upon. For instance, if
                                      .metadata.generation is currently 12, but the
                                      .status.conditions[x].observedGeneration is 9, the condition is
                                      out of date with respect to the current state of the instance.
                                }
                            ],
                            "lastSuccessfulSyncTime": "2020-02-20 00:00:00"  # Optional.
                              LastSuccessfulSyncTime represents the last time the secret was retrieved
                              from the Provider and updated.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_secret_syncs_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists the SecretSync instances within a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "kubernetesSecretType": "str",  # Type specifies the type of the
                          Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The controller
                          must have permission to create secrets of the specified type. Required. Known
                          values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # SecretProviderClassName
                          specifies the name of the SecretProviderClass resource, which contains the
                          information needed to access the cloud provider secret store. Required.
                        "serviceAccountName": "str",  # ServiceAccountName specifies the name
                          of the service account used to access the cloud provider secret store. The
                          audience field in the service account token must be passed as parameter in
                          the controller configuration. The audience is used when requesting a token
                          from the API server for the service account; the supported audiences are
                          defined by each provider. Required.
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          SecretSync instance. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": {
                            "conditions": [
                                {
                                    "message": "str",  # Message is a human
                                      readable message indicating details about the transition. This
                                      may be an empty string. Required.
                                    "reason": "str",  # Reason contains a
                                      programmatic identifier indicating the reason for the condition's
                                      last transition. Producers of specific condition types may define
                                      expected values and meanings for this field, and whether the
                                      values are considered a guaranteed API. The value should be a
                                      CamelCase string. This field may not be empty. Required.
                                    "status": "str",  # Status of the condition,
                                      one of True, False, Unknown. Required. Known values are: "True",
                                      "False", and "Unknown".
                                    "type": "str",  # Type of condition in
                                      CamelCase or in foo.example.com/CamelCase. Many .condition.type
                                      values are consistent across resources like Available, but
                                      because arbitrary conditions can be useful (see
                                      .node.status.conditions), the ability to de-conflict is
                                      important. The regex it matches is
                                      (dns1123SubdomainFmt/)?(qualifiedNameFmt). Required.
                                    "lastTransitionTime": "2020-02-20 00:00:00",
                                      # Optional. LastTransitionTime is the last time the condition
                                      transitioned from one status to another. This should be when the
                                      underlying condition changed. If that is not known, then using
                                      the time when the API field changed is acceptable.
                                    "observedGeneration": 0  # Optional.
                                      ObservedGeneration represents the .metadata.generation that the
                                      condition was set based upon. For instance, if
                                      .metadata.generation is currently 12, but the
                                      .status.conditions[x].observedGeneration is 9, the condition is
                                      out of date with respect to the current state of the instance.
                                }
                            ],
                            "lastSuccessfulSyncTime": "2020-02-20 00:00:00"  # Optional.
                              LastSuccessfulSyncTime represents the last time the secret was retrieved
                              from the Provider and updated.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_secret_syncs_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, secret_sync_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of a SecretSync instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param secret_sync_name: The name of the SecretSync. Required.
        :type secret_sync_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "kubernetesSecretType": "str",  # Type specifies the type of the
                          Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The controller
                          must have permission to create secrets of the specified type. Required. Known
                          values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # SecretProviderClassName
                          specifies the name of the SecretProviderClass resource, which contains the
                          information needed to access the cloud provider secret store. Required.
                        "serviceAccountName": "str",  # ServiceAccountName specifies the name
                          of the service account used to access the cloud provider secret store. The
                          audience field in the service account token must be passed as parameter in
                          the controller configuration. The audience is used when requesting a token
                          from the API server for the service account; the supported audiences are
                          defined by each provider. Required.
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          SecretSync instance. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": {
                            "conditions": [
                                {
                                    "message": "str",  # Message is a human
                                      readable message indicating details about the transition. This
                                      may be an empty string. Required.
                                    "reason": "str",  # Reason contains a
                                      programmatic identifier indicating the reason for the condition's
                                      last transition. Producers of specific condition types may define
                                      expected values and meanings for this field, and whether the
                                      values are considered a guaranteed API. The value should be a
                                      CamelCase string. This field may not be empty. Required.
                                    "status": "str",  # Status of the condition,
                                      one of True, False, Unknown. Required. Known values are: "True",
                                      "False", and "Unknown".
                                    "type": "str",  # Type of condition in
                                      CamelCase or in foo.example.com/CamelCase. Many .condition.type
                                      values are consistent across resources like Available, but
                                      because arbitrary conditions can be useful (see
                                      .node.status.conditions), the ability to de-conflict is
                                      important. The regex it matches is
                                      (dns1123SubdomainFmt/)?(qualifiedNameFmt). Required.
                                    "lastTransitionTime": "2020-02-20 00:00:00",
                                      # Optional. LastTransitionTime is the last time the condition
                                      transitioned from one status to another. This should be when the
                                      underlying condition changed. If that is not known, then using
                                      the time when the API field changed is acceptable.
                                    "observedGeneration": 0  # Optional.
                                      ObservedGeneration represents the .metadata.generation that the
                                      condition was set based upon. For instance, if
                                      .metadata.generation is currently 12, but the
                                      .status.conditions[x].observedGeneration is 9, the condition is
                                      out of date with respect to the current state of the instance.
                                }
                            ],
                            "lastSuccessfulSyncTime": "2020-02-20 00:00:00"  # Optional.
                              LastSuccessfulSyncTime represents the last time the secret was retrieved
                              from the Provider and updated.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_secret_syncs_get_request(
            resource_group_name=resource_group_name,
            secret_sync_name=secret_sync_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_update_initial(
        self, resource_group_name: str, secret_sync_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_secret_syncs_create_or_update_request(
            resource_group_name=resource_group_name,
            secret_sync_name=secret_sync_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        secret_sync_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates new or updates a SecretSync instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param secret_sync_name: The name of the SecretSync. Required.
        :type secret_sync_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "kubernetesSecretType": "str",  # Type specifies the type of the
                          Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The controller
                          must have permission to create secrets of the specified type. Required. Known
                          values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # SecretProviderClassName
                          specifies the name of the SecretProviderClass resource, which contains the
                          information needed to access the cloud provider secret store. Required.
                        "serviceAccountName": "str",  # ServiceAccountName specifies the name
                          of the service account used to access the cloud provider secret store. The
                          audience field in the service account token must be passed as parameter in
                          the controller configuration. The audience is used when requesting a token
                          from the API server for the service account; the supported audiences are
                          defined by each provider. Required.
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          SecretSync instance. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": {
                            "conditions": [
                                {
                                    "message": "str",  # Message is a human
                                      readable message indicating details about the transition. This
                                      may be an empty string. Required.
                                    "reason": "str",  # Reason contains a
                                      programmatic identifier indicating the reason for the condition's
                                      last transition. Producers of specific condition types may define
                                      expected values and meanings for this field, and whether the
                                      values are considered a guaranteed API. The value should be a
                                      CamelCase string. This field may not be empty. Required.
                                    "status": "str",  # Status of the condition,
                                      one of True, False, Unknown. Required. Known values are: "True",
                                      "False", and "Unknown".
                                    "type": "str",  # Type of condition in
                                      CamelCase or in foo.example.com/CamelCase. Many .condition.type
                                      values are consistent across resources like Available, but
                                      because arbitrary conditions can be useful (see
                                      .node.status.conditions), the ability to de-conflict is
                                      important. The regex it matches is
                                      (dns1123SubdomainFmt/)?(qualifiedNameFmt). Required.
                                    "lastTransitionTime": "2020-02-20 00:00:00",
                                      # Optional. LastTransitionTime is the last time the condition
                                      transitioned from one status to another. This should be when the
                                      underlying condition changed. If that is not known, then using
                                      the time when the API field changed is acceptable.
                                    "observedGeneration": 0  # Optional.
                                      ObservedGeneration represents the .metadata.generation that the
                                      condition was set based upon. For instance, if
                                      .metadata.generation is currently 12, but the
                                      .status.conditions[x].observedGeneration is 9, the condition is
                                      out of date with respect to the current state of the instance.
                                }
                            ],
                            "lastSuccessfulSyncTime": "2020-02-20 00:00:00"  # Optional.
                              LastSuccessfulSyncTime represents the last time the secret was retrieved
                              from the Provider and updated.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "kubernetesSecretType": "str",  # Type specifies the type of the
                          Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The controller
                          must have permission to create secrets of the specified type. Required. Known
                          values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # SecretProviderClassName
                          specifies the name of the SecretProviderClass resource, which contains the
                          information needed to access the cloud provider secret store. Required.
                        "serviceAccountName": "str",  # ServiceAccountName specifies the name
                          of the service account used to access the cloud provider secret store. The
                          audience field in the service account token must be passed as parameter in
                          the controller configuration. The audience is used when requesting a token
                          from the API server for the service account; the supported audiences are
                          defined by each provider. Required.
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          SecretSync instance. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": {
                            "conditions": [
                                {
                                    "message": "str",  # Message is a human
                                      readable message indicating details about the transition. This
                                      may be an empty string. Required.
                                    "reason": "str",  # Reason contains a
                                      programmatic identifier indicating the reason for the condition's
                                      last transition. Producers of specific condition types may define
                                      expected values and meanings for this field, and whether the
                                      values are considered a guaranteed API. The value should be a
                                      CamelCase string. This field may not be empty. Required.
                                    "status": "str",  # Status of the condition,
                                      one of True, False, Unknown. Required. Known values are: "True",
                                      "False", and "Unknown".
                                    "type": "str",  # Type of condition in
                                      CamelCase or in foo.example.com/CamelCase. Many .condition.type
                                      values are consistent across resources like Available, but
                                      because arbitrary conditions can be useful (see
                                      .node.status.conditions), the ability to de-conflict is
                                      important. The regex it matches is
                                      (dns1123SubdomainFmt/)?(qualifiedNameFmt). Required.
                                    "lastTransitionTime": "2020-02-20 00:00:00",
                                      # Optional. LastTransitionTime is the last time the condition
                                      transitioned from one status to another. This should be when the
                                      underlying condition changed. If that is not known, then using
                                      the time when the API field changed is acceptable.
                                    "observedGeneration": 0  # Optional.
                                      ObservedGeneration represents the .metadata.generation that the
                                      condition was set based upon. For instance, if
                                      .metadata.generation is currently 12, but the
                                      .status.conditions[x].observedGeneration is 9, the condition is
                                      out of date with respect to the current state of the instance.
                                }
                            ],
                            "lastSuccessfulSyncTime": "2020-02-20 00:00:00"  # Optional.
                              LastSuccessfulSyncTime represents the last time the secret was retrieved
                              from the Provider and updated.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        secret_sync_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates new or updates a SecretSync instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param secret_sync_name: The name of the SecretSync. Required.
        :type secret_sync_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "kubernetesSecretType": "str",  # Type specifies the type of the
                          Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The controller
                          must have permission to create secrets of the specified type. Required. Known
                          values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # SecretProviderClassName
                          specifies the name of the SecretProviderClass resource, which contains the
                          information needed to access the cloud provider secret store. Required.
                        "serviceAccountName": "str",  # ServiceAccountName specifies the name
                          of the service account used to access the cloud provider secret store. The
                          audience field in the service account token must be passed as parameter in
                          the controller configuration. The audience is used when requesting a token
                          from the API server for the service account; the supported audiences are
                          defined by each provider. Required.
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          SecretSync instance. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": {
                            "conditions": [
                                {
                                    "message": "str",  # Message is a human
                                      readable message indicating details about the transition. This
                                      may be an empty string. Required.
                                    "reason": "str",  # Reason contains a
                                      programmatic identifier indicating the reason for the condition's
                                      last transition. Producers of specific condition types may define
                                      expected values and meanings for this field, and whether the
                                      values are considered a guaranteed API. The value should be a
                                      CamelCase string. This field may not be empty. Required.
                                    "status": "str",  # Status of the condition,
                                      one of True, False, Unknown. Required. Known values are: "True",
                                      "False", and "Unknown".
                                    "type": "str",  # Type of condition in
                                      CamelCase or in foo.example.com/CamelCase. Many .condition.type
                                      values are consistent across resources like Available, but
                                      because arbitrary conditions can be useful (see
                                      .node.status.conditions), the ability to de-conflict is
                                      important. The regex it matches is
                                      (dns1123SubdomainFmt/)?(qualifiedNameFmt). Required.
                                    "lastTransitionTime": "2020-02-20 00:00:00",
                                      # Optional. LastTransitionTime is the last time the condition
                                      transitioned from one status to another. This should be when the
                                      underlying condition changed. If that is not known, then using
                                      the time when the API field changed is acceptable.
                                    "observedGeneration": 0  # Optional.
                                      ObservedGeneration represents the .metadata.generation that the
                                      condition was set based upon. For instance, if
                                      .metadata.generation is currently 12, but the
                                      .status.conditions[x].observedGeneration is 9, the condition is
                                      out of date with respect to the current state of the instance.
                                }
                            ],
                            "lastSuccessfulSyncTime": "2020-02-20 00:00:00"  # Optional.
                              LastSuccessfulSyncTime represents the last time the secret was retrieved
                              from the Provider and updated.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self, resource_group_name: str, secret_sync_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates new or updates a SecretSync instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param secret_sync_name: The name of the SecretSync. Required.
        :type secret_sync_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "kubernetesSecretType": "str",  # Type specifies the type of the
                          Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The controller
                          must have permission to create secrets of the specified type. Required. Known
                          values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # SecretProviderClassName
                          specifies the name of the SecretProviderClass resource, which contains the
                          information needed to access the cloud provider secret store. Required.
                        "serviceAccountName": "str",  # ServiceAccountName specifies the name
                          of the service account used to access the cloud provider secret store. The
                          audience field in the service account token must be passed as parameter in
                          the controller configuration. The audience is used when requesting a token
                          from the API server for the service account; the supported audiences are
                          defined by each provider. Required.
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          SecretSync instance. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": {
                            "conditions": [
                                {
                                    "message": "str",  # Message is a human
                                      readable message indicating details about the transition. This
                                      may be an empty string. Required.
                                    "reason": "str",  # Reason contains a
                                      programmatic identifier indicating the reason for the condition's
                                      last transition. Producers of specific condition types may define
                                      expected values and meanings for this field, and whether the
                                      values are considered a guaranteed API. The value should be a
                                      CamelCase string. This field may not be empty. Required.
                                    "status": "str",  # Status of the condition,
                                      one of True, False, Unknown. Required. Known values are: "True",
                                      "False", and "Unknown".
                                    "type": "str",  # Type of condition in
                                      CamelCase or in foo.example.com/CamelCase. Many .condition.type
                                      values are consistent across resources like Available, but
                                      because arbitrary conditions can be useful (see
                                      .node.status.conditions), the ability to de-conflict is
                                      important. The regex it matches is
                                      (dns1123SubdomainFmt/)?(qualifiedNameFmt). Required.
                                    "lastTransitionTime": "2020-02-20 00:00:00",
                                      # Optional. LastTransitionTime is the last time the condition
                                      transitioned from one status to another. This should be when the
                                      underlying condition changed. If that is not known, then using
                                      the time when the API field changed is acceptable.
                                    "observedGeneration": 0  # Optional.
                                      ObservedGeneration represents the .metadata.generation that the
                                      condition was set based upon. For instance, if
                                      .metadata.generation is currently 12, but the
                                      .status.conditions[x].observedGeneration is 9, the condition is
                                      out of date with respect to the current state of the instance.
                                }
                            ],
                            "lastSuccessfulSyncTime": "2020-02-20 00:00:00"  # Optional.
                              LastSuccessfulSyncTime represents the last time the secret was retrieved
                              from the Provider and updated.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "kubernetesSecretType": "str",  # Type specifies the type of the
                          Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The controller
                          must have permission to create secrets of the specified type. Required. Known
                          values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # SecretProviderClassName
                          specifies the name of the SecretProviderClass resource, which contains the
                          information needed to access the cloud provider secret store. Required.
                        "serviceAccountName": "str",  # ServiceAccountName specifies the name
                          of the service account used to access the cloud provider secret store. The
                          audience field in the service account token must be passed as parameter in
                          the controller configuration. The audience is used when requesting a token
                          from the API server for the service account; the supported audiences are
                          defined by each provider. Required.
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          SecretSync instance. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": {
                            "conditions": [
                                {
                                    "message": "str",  # Message is a human
                                      readable message indicating details about the transition. This
                                      may be an empty string. Required.
                                    "reason": "str",  # Reason contains a
                                      programmatic identifier indicating the reason for the condition's
                                      last transition. Producers of specific condition types may define
                                      expected values and meanings for this field, and whether the
                                      values are considered a guaranteed API. The value should be a
                                      CamelCase string. This field may not be empty. Required.
                                    "status": "str",  # Status of the condition,
                                      one of True, False, Unknown. Required. Known values are: "True",
                                      "False", and "Unknown".
                                    "type": "str",  # Type of condition in
                                      CamelCase or in foo.example.com/CamelCase. Many .condition.type
                                      values are consistent across resources like Available, but
                                      because arbitrary conditions can be useful (see
                                      .node.status.conditions), the ability to de-conflict is
                                      important. The regex it matches is
                                      (dns1123SubdomainFmt/)?(qualifiedNameFmt). Required.
                                    "lastTransitionTime": "2020-02-20 00:00:00",
                                      # Optional. LastTransitionTime is the last time the condition
                                      transitioned from one status to another. This should be when the
                                      underlying condition changed. If that is not known, then using
                                      the time when the API field changed is acceptable.
                                    "observedGeneration": 0  # Optional.
                                      ObservedGeneration represents the .metadata.generation that the
                                      condition was set based upon. For instance, if
                                      .metadata.generation is currently 12, but the
                                      .status.conditions[x].observedGeneration is 9, the condition is
                                      out of date with respect to the current state of the instance.
                                }
                            ],
                            "lastSuccessfulSyncTime": "2020-02-20 00:00:00"  # Optional.
                              LastSuccessfulSyncTime represents the last time the secret was retrieved
                              from the Provider and updated.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                secret_sync_name=secret_sync_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, resource_group_name: str, secret_sync_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_secret_syncs_update_request(
            resource_group_name=resource_group_name,
            secret_sync_name=secret_sync_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        secret_sync_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a SecretSync instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param secret_sync_name: The name of the SecretSync. Required.
        :type secret_sync_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "kubernetesSecretType": "str",  # Optional. Type specifies the type
                          of the Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The
                          controller must have permission to create secrets of the specified type.
                          Known values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # Optional.
                          SecretProviderClassName specifies the name of the SecretProviderClass
                          resource, which contains the information needed to access the cloud provider
                          secret store.
                        "serviceAccountName": "str"  # Optional. ServiceAccountName specifies
                          the name of the service account used to access the cloud provider secret
                          store. The audience field in the service account token must be passed as
                          parameter in the controller configuration. The audience is used when
                          requesting a token from the API server for the service account; the supported
                          audiences are defined by each provider.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "kubernetesSecretType": "str",  # Type specifies the type of the
                          Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The controller
                          must have permission to create secrets of the specified type. Required. Known
                          values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # SecretProviderClassName
                          specifies the name of the SecretProviderClass resource, which contains the
                          information needed to access the cloud provider secret store. Required.
                        "serviceAccountName": "str",  # ServiceAccountName specifies the name
                          of the service account used to access the cloud provider secret store. The
                          audience field in the service account token must be passed as parameter in
                          the controller configuration. The audience is used when requesting a token
                          from the API server for the service account; the supported audiences are
                          defined by each provider. Required.
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          SecretSync instance. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": {
                            "conditions": [
                                {
                                    "message": "str",  # Message is a human
                                      readable message indicating details about the transition. This
                                      may be an empty string. Required.
                                    "reason": "str",  # Reason contains a
                                      programmatic identifier indicating the reason for the condition's
                                      last transition. Producers of specific condition types may define
                                      expected values and meanings for this field, and whether the
                                      values are considered a guaranteed API. The value should be a
                                      CamelCase string. This field may not be empty. Required.
                                    "status": "str",  # Status of the condition,
                                      one of True, False, Unknown. Required. Known values are: "True",
                                      "False", and "Unknown".
                                    "type": "str",  # Type of condition in
                                      CamelCase or in foo.example.com/CamelCase. Many .condition.type
                                      values are consistent across resources like Available, but
                                      because arbitrary conditions can be useful (see
                                      .node.status.conditions), the ability to de-conflict is
                                      important. The regex it matches is
                                      (dns1123SubdomainFmt/)?(qualifiedNameFmt). Required.
                                    "lastTransitionTime": "2020-02-20 00:00:00",
                                      # Optional. LastTransitionTime is the last time the condition
                                      transitioned from one status to another. This should be when the
                                      underlying condition changed. If that is not known, then using
                                      the time when the API field changed is acceptable.
                                    "observedGeneration": 0  # Optional.
                                      ObservedGeneration represents the .metadata.generation that the
                                      condition was set based upon. For instance, if
                                      .metadata.generation is currently 12, but the
                                      .status.conditions[x].observedGeneration is 9, the condition is
                                      out of date with respect to the current state of the instance.
                                }
                            ],
                            "lastSuccessfulSyncTime": "2020-02-20 00:00:00"  # Optional.
                              LastSuccessfulSyncTime represents the last time the secret was retrieved
                              from the Provider and updated.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        secret_sync_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a SecretSync instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param secret_sync_name: The name of the SecretSync. Required.
        :type secret_sync_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "kubernetesSecretType": "str",  # Type specifies the type of the
                          Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The controller
                          must have permission to create secrets of the specified type. Required. Known
                          values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # SecretProviderClassName
                          specifies the name of the SecretProviderClass resource, which contains the
                          information needed to access the cloud provider secret store. Required.
                        "serviceAccountName": "str",  # ServiceAccountName specifies the name
                          of the service account used to access the cloud provider secret store. The
                          audience field in the service account token must be passed as parameter in
                          the controller configuration. The audience is used when requesting a token
                          from the API server for the service account; the supported audiences are
                          defined by each provider. Required.
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          SecretSync instance. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": {
                            "conditions": [
                                {
                                    "message": "str",  # Message is a human
                                      readable message indicating details about the transition. This
                                      may be an empty string. Required.
                                    "reason": "str",  # Reason contains a
                                      programmatic identifier indicating the reason for the condition's
                                      last transition. Producers of specific condition types may define
                                      expected values and meanings for this field, and whether the
                                      values are considered a guaranteed API. The value should be a
                                      CamelCase string. This field may not be empty. Required.
                                    "status": "str",  # Status of the condition,
                                      one of True, False, Unknown. Required. Known values are: "True",
                                      "False", and "Unknown".
                                    "type": "str",  # Type of condition in
                                      CamelCase or in foo.example.com/CamelCase. Many .condition.type
                                      values are consistent across resources like Available, but
                                      because arbitrary conditions can be useful (see
                                      .node.status.conditions), the ability to de-conflict is
                                      important. The regex it matches is
                                      (dns1123SubdomainFmt/)?(qualifiedNameFmt). Required.
                                    "lastTransitionTime": "2020-02-20 00:00:00",
                                      # Optional. LastTransitionTime is the last time the condition
                                      transitioned from one status to another. This should be when the
                                      underlying condition changed. If that is not known, then using
                                      the time when the API field changed is acceptable.
                                    "observedGeneration": 0  # Optional.
                                      ObservedGeneration represents the .metadata.generation that the
                                      condition was set based upon. For instance, if
                                      .metadata.generation is currently 12, but the
                                      .status.conditions[x].observedGeneration is 9, the condition is
                                      out of date with respect to the current state of the instance.
                                }
                            ],
                            "lastSuccessfulSyncTime": "2020-02-20 00:00:00"  # Optional.
                              LastSuccessfulSyncTime represents the last time the secret was retrieved
                              from the Provider and updated.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_group_name: str, secret_sync_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a SecretSync instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param secret_sync_name: The name of the SecretSync. Required.
        :type secret_sync_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "kubernetesSecretType": "str",  # Optional. Type specifies the type
                          of the Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The
                          controller must have permission to create secrets of the specified type.
                          Known values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # Optional.
                          SecretProviderClassName specifies the name of the SecretProviderClass
                          resource, which contains the information needed to access the cloud provider
                          secret store.
                        "serviceAccountName": "str"  # Optional. ServiceAccountName specifies
                          the name of the service account used to access the cloud provider secret
                          store. The audience field in the service account token must be passed as
                          parameter in the controller configuration. The audience is used when
                          requesting a token from the API server for the service account; the supported
                          audiences are defined by each provider.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # The name of the extended location. Required.
                        "type": "str"  # The type of the extended location. Required. Known
                          values are: "EdgeZone" and "CustomLocation".
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "kubernetesSecretType": "str",  # Type specifies the type of the
                          Kubernetes secret object, e.g. "Opaque" or"kubernetes.io/tls". The controller
                          must have permission to create secrets of the specified type. Required. Known
                          values are: "Opaque" and "kubernetes.io/tls".
                        "objectSecretMapping": [
                            {
                                "sourcePath": "str",  # SourcePath is the identifier
                                  for the secret data as defined by the external secret provider. This
                                  is the key or path to the secret in the provider's system, which gets
                                  mounted to a specific path in the pod. The value should match the
                                  name of the secret as specified in the SecretProviderClass's objects
                                  array. Required.
                                "targetKey": "str"  # TargetKey is the key in the
                                  Kubernetes secret's data field where the secret value will be stored.
                                  This key is used to reference the secret data within Kubernetes, and
                                  it should be unique within the secret. Required.
                            }
                        ],
                        "secretProviderClassName": "str",  # SecretProviderClassName
                          specifies the name of the SecretProviderClass resource, which contains the
                          information needed to access the cloud provider secret store. Required.
                        "serviceAccountName": "str",  # ServiceAccountName specifies the name
                          of the service account used to access the cloud provider secret store. The
                          audience field in the service account token must be passed as parameter in
                          the controller configuration. The audience is used when requesting a token
                          from the API server for the service account; the supported audiences are
                          defined by each provider. Required.
                        "forceSynchronization": "str",  # Optional. ForceSynchronization can
                          be used to force the secret synchronization. The secret synchronization is
                          triggered by changing the value in this field. This field is not used to
                          resolve synchronization conflicts.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          SecretSync instance. Known values are: "Succeeded", "Failed", and "Canceled".
                        "status": {
                            "conditions": [
                                {
                                    "message": "str",  # Message is a human
                                      readable message indicating details about the transition. This
                                      may be an empty string. Required.
                                    "reason": "str",  # Reason contains a
                                      programmatic identifier indicating the reason for the condition's
                                      last transition. Producers of specific condition types may define
                                      expected values and meanings for this field, and whether the
                                      values are considered a guaranteed API. The value should be a
                                      CamelCase string. This field may not be empty. Required.
                                    "status": "str",  # Status of the condition,
                                      one of True, False, Unknown. Required. Known values are: "True",
                                      "False", and "Unknown".
                                    "type": "str",  # Type of condition in
                                      CamelCase or in foo.example.com/CamelCase. Many .condition.type
                                      values are consistent across resources like Available, but
                                      because arbitrary conditions can be useful (see
                                      .node.status.conditions), the ability to de-conflict is
                                      important. The regex it matches is
                                      (dns1123SubdomainFmt/)?(qualifiedNameFmt). Required.
                                    "lastTransitionTime": "2020-02-20 00:00:00",
                                      # Optional. LastTransitionTime is the last time the condition
                                      transitioned from one status to another. This should be when the
                                      underlying condition changed. If that is not known, then using
                                      the time when the API field changed is acceptable.
                                    "observedGeneration": 0  # Optional.
                                      ObservedGeneration represents the .metadata.generation that the
                                      condition was set based upon. For instance, if
                                      .metadata.generation is currently 12, but the
                                      .status.conditions[x].observedGeneration is 9, the condition is
                                      out of date with respect to the current state of the instance.
                                }
                            ],
                            "lastSuccessfulSyncTime": "2020-02-20 00:00:00"  # Optional.
                              LastSuccessfulSyncTime represents the last time the secret was retrieved
                              from the Provider and updated.
                        }
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                secret_sync_name=secret_sync_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, secret_sync_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_secret_syncs_delete_request(
            resource_group_name=resource_group_name,
            secret_sync_name=secret_sync_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(self, resource_group_name: str, secret_sync_name: str, **kwargs: Any) -> LROPoller[None]:
        """Deletes a SecretSync instance.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param secret_sync_name: The name of the SecretSync. Required.
        :type secret_sync_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                secret_sync_name=secret_sync_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
