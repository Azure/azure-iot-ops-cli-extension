# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat

from .._serialization import Serializer
from .._vendor import KeyVaultClientMixinABC, _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_key_vault_set_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_delete_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_update_secret_request(secret_name: str, secret_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}/{secret-version}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
        "secret-version": _SERIALIZER.url("secret_version", secret_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_secret_request(secret_name: str, secret_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}/{secret-version}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
        "secret-version": _SERIALIZER.url("secret_version", secret_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_secrets_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets"

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_secret_versions_request(
    secret_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}/versions"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_secrets_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedsecrets"

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedsecrets/{secret-name}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_purge_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedsecrets/{secret-name}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_recover_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedsecrets/{secret-name}/recover"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_backup_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}/backup"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_restore_secret_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/restore"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


class KeyVaultClientOperationsMixin(KeyVaultClientMixinABC):
    @overload
    def set_secret(
        self,
        vault_base_url: str,
        secret_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets a secret in a specified key vault.

        The SET operation adds a secret to the Azure Key Vault. If the named secret already exists,
        Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type secret_name: str
        :param parameters: The parameters for setting the secret. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": "str",  # The value of the secret. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @overload
    def set_secret(
        self,
        vault_base_url: str,
        secret_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets a secret in a specified key vault.

        The SET operation adds a secret to the Azure Key Vault. If the named secret already exists,
        Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type secret_name: str
        :param parameters: The parameters for setting the secret. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @distributed_trace
    def set_secret(self, vault_base_url: str, secret_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Sets a secret in a specified key vault.

        The SET operation adds a secret to the Azure Key Vault. If the named secret already exists,
        Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type secret_name: str
        :param parameters: The parameters for setting the secret. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": "str",  # The value of the secret. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_set_secret_request(
            secret_name=secret_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> JSON:
        """Deletes a secret from a specified key vault.

        The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied
        to an individual version of a secret. This operation requires the secrets/delete permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the secret
                      was deleted, in UTC.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted secret.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      secret is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_delete_secret_request(
            secret_name=secret_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update_secret(
        self,
        vault_base_url: str,
        secret_name: str,
        secret_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the attributes associated with a specified secret in a given key vault.

        The UPDATE operation changes specified attributes of an existing stored secret. Attributes that
        are not specified in the request are left unchanged. The value of a secret itself cannot be
        changed. This operation requires the secrets/set permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :param secret_version: The version of the secret. Required.
        :type secret_version: str
        :param parameters: The parameters for update secret operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @overload
    def update_secret(
        self,
        vault_base_url: str,
        secret_name: str,
        secret_version: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the attributes associated with a specified secret in a given key vault.

        The UPDATE operation changes specified attributes of an existing stored secret. Attributes that
        are not specified in the request are left unchanged. The value of a secret itself cannot be
        changed. This operation requires the secrets/set permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :param secret_version: The version of the secret. Required.
        :type secret_version: str
        :param parameters: The parameters for update secret operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @distributed_trace
    def update_secret(
        self, vault_base_url: str, secret_name: str, secret_version: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates the attributes associated with a specified secret in a given key vault.

        The UPDATE operation changes specified attributes of an existing stored secret. Attributes that
        are not specified in the request are left unchanged. The value of a secret itself cannot be
        changed. This operation requires the secrets/set permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :param secret_version: The version of the secret. Required.
        :type secret_version: str
        :param parameters: The parameters for update secret operation. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_update_secret_request(
            secret_name=secret_name,
            secret_version=secret_version,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_secret(self, vault_base_url: str, secret_name: str, secret_version: str, **kwargs: Any) -> JSON:
        """Get a specified secret from a given key vault.

        The GET operation is applicable to any secret stored in Azure Key Vault. This operation
        requires the secrets/get permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :param secret_version: The version of the secret. This URI fragment is optional. If not
         specified, the latest version of the secret is returned. Required.
        :type secret_version: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_secret_request(
            secret_name=secret_name,
            secret_version=secret_version,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_secrets(self, vault_base_url: str, *, maxresults: Optional[int] = None, **kwargs: Any) -> Iterable[JSON]:
        """List secrets in a specified key vault.

        The Get Secrets operation is applicable to the entire vault. However, only the base secret
        identifier and its attributes are provided in the response. Individual secret versions are not
        listed in the response. This operation requires the secrets/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified, the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "id": "str",  # Optional. Secret identifier.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_secrets_request(
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_secret_versions(
        self, vault_base_url: str, secret_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """List all versions of the specified secret.

        The full secret identifier and attributes are provided in the response. No values are returned
        for the secrets. This operations requires the secrets/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified, the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "id": "str",  # Optional. Secret identifier.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_secret_versions_request(
                    secret_name=secret_name,
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deleted_secrets(
        self, vault_base_url: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists deleted secrets for the specified vault.

        The Get Deleted Secrets operation returns the secrets that have been deleted for a vault
        enabled for soft-delete. This operation requires the secrets/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the secret
                      was deleted, in UTC.
                    "id": "str",  # Optional. Secret identifier.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted secret.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      secret is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_deleted_secrets_request(
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deleted_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> JSON:
        """Gets the specified deleted secret.

        The Get Deleted Secret operation returns the specified deleted secret along with its
        attributes. This operation requires the secrets/get permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the secret
                      was deleted, in UTC.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted secret.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      secret is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_deleted_secret_request(
            secret_name=secret_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def purge_deleted_secret(  # pylint: disable=inconsistent-return-statements
        self, vault_base_url: str, secret_name: str, **kwargs: Any
    ) -> None:
        """Permanently deletes the specified secret.

        The purge deleted secret operation removes the secret permanently, without the possibility of
        recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
        requires the secrets/purge permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_key_vault_purge_deleted_secret_request(
            secret_name=secret_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def recover_deleted_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> JSON:
        """Recovers the deleted secret to the latest version.

        Recovers the deleted secret in the specified vault. This operation can only be performed on a
        soft-delete enabled vault. This operation requires the secrets/recover permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the deleted secret. Required.
        :type secret_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_recover_deleted_secret_request(
            secret_name=secret_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def backup_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> JSON:
        """Backs up the specified secret.

        Requests that a backup of the specified secret be downloaded to the client. All versions of the
        secret will be downloaded. This operation requires the secrets/backup permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": bytes("bytes", encoding="utf-8")  # Optional. The backup blob
                      containing the backed up secret.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_backup_secret_request(
            secret_name=secret_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def restore_secret(
        self, vault_base_url: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Restores a backed up secret to a vault.

        Restores a backed up secret, and all its versions, to a vault. This operation requires the
        secrets/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the secret. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": bytes("bytes", encoding="utf-8")  # The backup blob associated with
                      a secret bundle. Required.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @overload
    def restore_secret(
        self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Restores a backed up secret to a vault.

        Restores a backed up secret, and all its versions, to a vault. This operation requires the
        secrets/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the secret. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @distributed_trace
    def restore_secret(self, vault_base_url: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Restores a backed up secret to a vault.

        Restores a backed up secret, and all its versions, to a vault. This operation requires the
        secrets/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the secret. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": bytes("bytes", encoding="utf-8")  # The backup blob associated with
                      a secret bundle. Required.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_restore_secret_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)
