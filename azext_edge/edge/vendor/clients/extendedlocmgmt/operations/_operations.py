# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer
from .._vendor import _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_custom_locations_list_operations_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.ExtendedLocation/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_custom_locations_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.ExtendedLocation/customLocations"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_custom_locations_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_custom_locations_get_request(
    resource_group_name: str, resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations/{resourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceName": _SERIALIZER.url(
            "resource_name",
            resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_custom_locations_create_or_update_request(
    resource_group_name: str, resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations/{resourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceName": _SERIALIZER.url(
            "resource_name",
            resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_custom_locations_delete_request(
    resource_group_name: str, resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations/{resourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceName": _SERIALIZER.url(
            "resource_name",
            resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_custom_locations_update_request(
    resource_group_name: str, resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations/{resourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceName": _SERIALIZER.url(
            "resource_name",
            resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_custom_locations_list_enabled_resource_types_request(
    resource_group_name: str, resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations/{resourceName}/enabledResourceTypes"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceName": _SERIALIZER.url(
            "resource_name",
            resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_custom_locations_find_target_resource_group_request(
    resource_group_name: str, resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations/{resourceName}/findTargetResourceGroup"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceName": _SERIALIZER.url(
            "resource_name",
            resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_sync_rules_list_by_custom_location_id_request(
    resource_group_name: str, resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations/{resourceName}/resourceSyncRules"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceName": _SERIALIZER.url(
            "resource_name",
            resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_sync_rules_get_request(
    resource_group_name: str, resource_name: str, child_resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations/{resourceName}/resourceSyncRules/{childResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceName": _SERIALIZER.url(
            "resource_name",
            resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
        "childResourceName": _SERIALIZER.url(
            "child_resource_name",
            child_resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_sync_rules_create_or_update_request(
    resource_group_name: str, resource_name: str, child_resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations/{resourceName}/resourceSyncRules/{childResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceName": _SERIALIZER.url(
            "resource_name",
            resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
        "childResourceName": _SERIALIZER.url(
            "child_resource_name",
            child_resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_sync_rules_delete_request(
    resource_group_name: str, resource_name: str, child_resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations/{resourceName}/resourceSyncRules/{childResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceName": _SERIALIZER.url(
            "resource_name",
            resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
        "childResourceName": _SERIALIZER.url(
            "child_resource_name",
            child_resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_resource_sync_rules_update_request(
    resource_group_name: str, resource_name: str, child_resource_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-08-31-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ExtendedLocation/customLocations/{resourceName}/resourceSyncRules/{childResourceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceName": _SERIALIZER.url(
            "resource_name",
            resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
        "childResourceName": _SERIALIZER.url(
            "child_resource_name",
            child_resource_name,
            "str",
            max_length=63,
            min_length=1,
            pattern=r"^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


class CustomLocationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.extendedlocation.CustomLocations`'s
        :attr:`custom_locations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_operations(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists all available Custom Locations operations.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "display": {
                        "description": "str",  # Optional. The description of the operation.
                        "operation": "str",  # Optional. The display name of the compute
                          operation.
                        "provider": "str",  # Optional. The resource provider for the
                          operation.
                        "resource": "str"  # Optional. The display name of the resource the
                          operation applies to.
                    },
                    "isDataAction": bool,  # Optional. Is this Operation a data plane operation.
                    "name": "str",  # Optional. The name of the compute operation.
                    "origin": "str"  # Optional. The origin of the compute operation.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_custom_locations_list_operations_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """Gets a list of Custom Locations in a subscription.

        Gets a list of Custom Locations in the specified subscription. The operation returns properties
        of each Custom Location.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_custom_locations_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Gets a list of Custom Locations in the specified subscription and resource group.

        Gets a list of Custom Locations in the specified subscription and resource group. The operation
        returns properties of each Custom Location.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_custom_locations_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, resource_name: str, **kwargs: Any) -> JSON:
        """Gets a Custom Location.

        Gets the details of the customLocation with a specified resource group and name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_custom_locations_get_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_update_initial(
        self, resource_group_name: str, resource_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_custom_locations_create_or_update_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        resource_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates or updates a Custom Location.

        Creates or updates a Custom Location in the specified Subscription and Resource Group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param parameters: Parameters supplied to create or update a Custom Location. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        resource_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates or updates a Custom Location.

        Creates or updates a Custom Location in the specified Subscription and Resource Group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param parameters: Parameters supplied to create or update a Custom Location. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self, resource_group_name: str, resource_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates or updates a Custom Location.

        Creates or updates a Custom Location in the specified Subscription and Resource Group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param parameters: Parameters supplied to create or update a Custom Location. Is either a JSON
         type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                resource_name=resource_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, resource_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_custom_locations_delete_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_delete(self, resource_group_name: str, resource_name: str, **kwargs: Any) -> LROPoller[None]:
        """Deletes a Custom Location.

        Deletes the Custom Location with the specified Resource Name, Resource Group, and Subscription
        Id.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                resource_name=resource_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        resource_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates a Custom Location.

        Updates a Custom Location with the specified Resource Name in the specified Resource Group and
        Subscription.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param parameters: The updatable fields of an existing Custom Location. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        resource_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates a Custom Location.

        Updates a Custom Location with the specified Resource Name in the specified Resource Group and
        Subscription.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param parameters: The updatable fields of an existing Custom Location. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def update(self, resource_group_name: str, resource_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Updates a Custom Location.

        Updates a Custom Location with the specified Resource Name in the specified Resource Group and
        Subscription.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param parameters: The updatable fields of an existing Custom Location. Is either a JSON type
         or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "type": "str"  # Optional. The identity type. Known values are:
                          "SystemAssigned" and "None".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "authentication": {
                            "type": "str",  # Optional. The type of the Custom Locations
                              authentication.
                            "value": "str"  # Optional. The kubeconfig value.
                        },
                        "clusterExtensionIds": [
                            "str"  # Optional. Contains the reference to the add-on that
                              contains charts to deploy CRDs and operators.
                        ],
                        "displayName": "str",  # Optional. Display name for the Custom
                          Locations location.
                        "hostResourceId": "str",  # Optional. Connected Cluster or AKS
                          Cluster. The Custom Locations RP will perform a checkAccess API for
                          listAdminCredentials permissions.
                        "hostType": "str",  # Optional. Type of host the Custom Locations is
                          referencing (Kubernetes, etc...). "Kubernetes"
                        "namespace": "str",  # Optional. Kubernetes namespace that will be
                          created on the specified cluster.
                        "provisioningState": "str"  # Optional. Provisioning State for the
                          Custom Location.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_custom_locations_update_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_enabled_resource_types(
        self, resource_group_name: str, resource_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets the list of Enabled Resource Types.

        Gets the list of the Enabled Resource Types.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "clusterExtensionId": "str",  # Optional. Cluster Extension ID.
                        "extensionType": "str",  # Optional. Cluster Extension Type.
                        "typesMetadata": [
                            {
                                "apiVersion": "str",  # Optional. Api Version of
                                  Resource Type.
                                "resourceProviderNamespace": "str",  # Optional.
                                  Resource Provider Namespace of Resource Type.
                                "resourceType": "str"  # Optional. Resource Type.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_custom_locations_list_enabled_resource_types_request(
                    resource_group_name=resource_group_name,
                    resource_name=resource_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def find_target_resource_group(
        self,
        resource_group_name: str,
        resource_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Optional[JSON]:
        """Gets matching target resource group for resource sync.

        Returns the target resource group associated with the resource sync rules of the Custom
        Location that match the rules passed in with the Find Target Resource Group Request.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param parameters: Parameters of the find target resource group request. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "labels": {
                        "str": "str"  # Optional. Labels of the custom resource, this is a
                          map of {key,value} pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "matchedResourceSyncRule": "str",  # Optional. The matching resource sync
                      rule is the particular resource sync rule that matched the match expressions and
                      labels and had lowest priority. This is the rule responsible for mapping the
                      target resource to the target resource group.
                    "targetResourceGroup": "str"  # Optional. The target resource group of
                      matching resource sync rule. The labels from the request will be used to find out
                      matching resource sync rule against the selector property of the resource sync
                      rule. The one with highest priority will be returned if there are multiple
                      matching rules.
                }
        """

    @overload
    def find_target_resource_group(
        self,
        resource_group_name: str,
        resource_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Optional[JSON]:
        """Gets matching target resource group for resource sync.

        Returns the target resource group associated with the resource sync rules of the Custom
        Location that match the rules passed in with the Find Target Resource Group Request.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param parameters: Parameters of the find target resource group request. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "matchedResourceSyncRule": "str",  # Optional. The matching resource sync
                      rule is the particular resource sync rule that matched the match expressions and
                      labels and had lowest priority. This is the rule responsible for mapping the
                      target resource to the target resource group.
                    "targetResourceGroup": "str"  # Optional. The target resource group of
                      matching resource sync rule. The labels from the request will be used to find out
                      matching resource sync rule against the selector property of the resource sync
                      rule. The one with highest priority will be returned if there are multiple
                      matching rules.
                }
        """

    @distributed_trace
    def find_target_resource_group(
        self, resource_group_name: str, resource_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        """Gets matching target resource group for resource sync.

        Returns the target resource group associated with the resource sync rules of the Custom
        Location that match the rules passed in with the Find Target Resource Group Request.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param parameters: Parameters of the find target resource group request. Is either a JSON type
         or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "labels": {
                        "str": "str"  # Optional. Labels of the custom resource, this is a
                          map of {key,value} pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "matchedResourceSyncRule": "str",  # Optional. The matching resource sync
                      rule is the particular resource sync rule that matched the match expressions and
                      labels and had lowest priority. This is the rule responsible for mapping the
                      target resource to the target resource group.
                    "targetResourceGroup": "str"  # Optional. The target resource group of
                      matching resource sync rule. The labels from the request will be used to find out
                      matching resource sync rule against the selector property of the resource sync
                      rule. The one with highest priority will be returned if there are multiple
                      matching rules.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_custom_locations_find_target_resource_group_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class ResourceSyncRulesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~microsoft.extendedlocation.CustomLocations`'s
        :attr:`resource_sync_rules` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_custom_location_id(self, resource_group_name: str, resource_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all Resource Sync Rules in a Custom Location.

        Gets a list of Resource Sync Rules in the specified subscription. The operation returns
        properties of each Resource Sync Rule.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_resource_sync_rules_list_by_custom_location_id_request(
                    resource_group_name=resource_group_name,
                    resource_name=resource_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, resource_name: str, child_resource_name: str, **kwargs: Any) -> JSON:
        """Gets a Resource Sync Rule.

        Gets the details of the resourceSyncRule with a specified resource group, subscription id
        Custom Location resource name and Resource Sync Rule name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param child_resource_name: Resource Sync Rule name. Required.
        :type child_resource_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_resource_sync_rules_get_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            child_resource_name=child_resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_update_initial(
        self,
        resource_group_name: str,
        resource_name: str,
        child_resource_name: str,
        parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_resource_sync_rules_create_or_update_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            child_resource_name=child_resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        resource_name: str,
        child_resource_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates or updates a Resource Sync Rule.

        Creates or updates a Resource Sync Rule in the parent Custom Location, Subscription Id and
        Resource Group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param child_resource_name: Resource Sync Rule name. Required.
        :type child_resource_name: str
        :param parameters: Parameters supplied to create or update a Resource Sync Rule. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_update(
        self,
        resource_group_name: str,
        resource_name: str,
        child_resource_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates or updates a Resource Sync Rule.

        Creates or updates a Resource Sync Rule in the parent Custom Location, Subscription Id and
        Resource Group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param child_resource_name: Resource Sync Rule name. Required.
        :type child_resource_name: str
        :param parameters: Parameters supplied to create or update a Resource Sync Rule. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self,
        resource_group_name: str,
        resource_name: str,
        child_resource_name: str,
        parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates or updates a Resource Sync Rule.

        Creates or updates a Resource Sync Rule in the parent Custom Location, Subscription Id and
        Resource Group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param child_resource_name: Resource Sync Rule name. Required.
        :type child_resource_name: str
        :param parameters: Parameters supplied to create or update a Resource Sync Rule. Is either a
         JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_update_initial(
                resource_group_name=resource_group_name,
                resource_name=resource_name,
                child_resource_name=child_resource_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, resource_name: str, child_resource_name: str, **kwargs: Any
    ) -> None:
        """Deletes a Resource Sync Rule.

        Deletes the Resource Sync Rule with the specified Resource Sync Rule Name, Custom Location
        Resource Name, Resource Group, and Subscription Id.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param child_resource_name: Resource Sync Rule name. Required.
        :type child_resource_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_resource_sync_rules_delete_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            child_resource_name=child_resource_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    def _update_initial(
        self,
        resource_group_name: str,
        resource_name: str,
        child_resource_name: str,
        parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_resource_sync_rules_update_request(
            resource_group_name=resource_group_name,
            resource_name=resource_name,
            child_resource_name=child_resource_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        resource_name: str,
        child_resource_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a Resource Sync Rule.

        Updates a Resource Sync Rule with the specified Resource Sync Rule name in the specified
        Resource Group, Subscription and Custom Location name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param child_resource_name: Resource Sync Rule name. Required.
        :type child_resource_name: str
        :param parameters: The updatable fields of an existing Resource Sync Rule. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        resource_name: str,
        child_resource_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a Resource Sync Rule.

        Updates a Resource Sync Rule with the specified Resource Sync Rule name in the specified
        Resource Group, Subscription and Custom Location name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param child_resource_name: Resource Sync Rule name. Required.
        :type child_resource_name: str
        :param parameters: The updatable fields of an existing Resource Sync Rule. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        resource_name: str,
        child_resource_name: str,
        parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Updates a Resource Sync Rule.

        Updates a Resource Sync Rule with the specified Resource Sync Rule name in the specified
        Resource Group, Subscription and Custom Location name.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_name: Custom Locations name. Required.
        :type resource_name: str
        :param child_resource_name: Resource Sync Rule name. Required.
        :type child_resource_name: str
        :param parameters: The updatable fields of an existing Resource Sync Rule. Is either a JSON
         type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "priority": 0,  # Optional. Priority represents a priority of the
                          Resource Sync Rule.
                        "provisioningState": "str",  # Optional. Provisioning State for the
                          Resource Sync Rule.
                        "selector": {
                            "matchExpressions": [
                                {
                                    "key": "str",  # Optional. Key is the label
                                      key that the selector applies to.
                                    "operator": "str",  # Optional. The Operator
                                      field represents a key's relationship to a set of values. Valid
                                      operators are In, NotIn, Exists and DoesNotExist.
                                    "values": [
                                        "str"  # Optional. The label value.
                                    ]
                                }
                            ],
                            "matchLabels": {
                                "str": "str"  # Optional. MatchLabels is a map of
                                  {key,value} pairs. A single {key,value} in the matchLabels map is
                                  equivalent to an element of matchExpressions, whose key field is
                                  'key', the operator is 'In', and the values array contains only
                                  'value'.
                            }
                        },
                        "targetResourceGroup": "str"  # Optional. For an unmapped custom
                          resource, its labels will be used to find matching resource sync rules. If
                          this resource sync rule is one of the matching rules with highest priority,
                          then the unmapped custom resource will be projected to the target resource
                          group associated with this resource sync rule. The user creating this
                          resource sync rule should have write permissions on the target resource group
                          and this write permission will be validated when creating the resource sync
                          rule.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                resource_name=resource_name,
                child_resource_name=child_resource_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
