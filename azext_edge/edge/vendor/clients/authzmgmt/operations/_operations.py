# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat

from .._serialization import Serializer
from .._vendor import _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_deny_assignments_list_for_resource_request(
    resource_group_name: str,
    resource_provider_namespace: str,
    parent_resource_path: str,
    resource_type: str,
    resource_name: str,
    subscription_id: str,
    *,
    filter: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/denyAssignments"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceProviderNamespace": _SERIALIZER.url(
            "resource_provider_namespace", resource_provider_namespace, "str", skip_quote=True
        ),
        "parentResourcePath": _SERIALIZER.url("parent_resource_path", parent_resource_path, "str", skip_quote=True),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str", skip_quote=True),
        "resourceName": _SERIALIZER.url("resource_name", resource_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deny_assignments_list_for_resource_group_request(
    resource_group_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/denyAssignments"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deny_assignments_list_request(
    subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/denyAssignments"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deny_assignments_get_request(scope: str, deny_assignment_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Authorization/denyAssignments/{denyAssignmentId}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "denyAssignmentId": _SERIALIZER.url("deny_assignment_id", deny_assignment_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deny_assignments_get_by_id_request(deny_assignment_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{denyAssignmentId}"
    path_format_arguments = {
        "denyAssignmentId": _SERIALIZER.url("deny_assignment_id", deny_assignment_id, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deny_assignments_list_for_scope_request(
    scope: str, *, filter: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Authorization/denyAssignments"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_provider_operations_metadata_get_request(
    resource_provider_namespace: str, *, expand: str = "resourceTypes", **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Authorization/providerOperations/{resourceProviderNamespace}"
    path_format_arguments = {
        "resourceProviderNamespace": _SERIALIZER.url(
            "resource_provider_namespace", resource_provider_namespace, "str", skip_quote=True
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_provider_operations_metadata_list_request(*, expand: str = "resourceTypes", **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Authorization/providerOperations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_assignments_list_for_subscription_request(
    subscription_id: str, *, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/roleAssignments"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
    if tenant_id is not None:
        _params["tenantId"] = _SERIALIZER.query("tenant_id", tenant_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_assignments_list_for_resource_group_request(
    resource_group_name: str,
    subscription_id: str,
    *,
    filter: Optional[str] = None,
    tenant_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/roleAssignments"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
    if tenant_id is not None:
        _params["tenantId"] = _SERIALIZER.query("tenant_id", tenant_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_assignments_list_for_resource_request(
    resource_group_name: str,
    resource_provider_namespace: str,
    resource_type: str,
    resource_name: str,
    subscription_id: str,
    *,
    filter: Optional[str] = None,
    tenant_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/roleAssignments"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceProviderNamespace": _SERIALIZER.url(
            "resource_provider_namespace", resource_provider_namespace, "str", skip_quote=True
        ),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str", skip_quote=True),
        "resourceName": _SERIALIZER.url("resource_name", resource_name, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
    if tenant_id is not None:
        _params["tenantId"] = _SERIALIZER.query("tenant_id", tenant_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_assignments_get_request(
    scope: str, role_assignment_name: str, *, tenant_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tenant_id is not None:
        _params["tenantId"] = _SERIALIZER.query("tenant_id", tenant_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_assignments_create_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_assignments_delete_request(
    scope: str, role_assignment_name: str, *, tenant_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tenant_id is not None:
        _params["tenantId"] = _SERIALIZER.query("tenant_id", tenant_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_assignments_list_for_scope_request(
    scope: str,
    *,
    filter: Optional[str] = None,
    tenant_id: Optional[str] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Authorization/roleAssignments"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tenant_id is not None:
        _params["tenantId"] = _SERIALIZER.query("tenant_id", tenant_id, "str")
    if skip_token is not None:
        _params["$skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str", skip_quote=True)

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_assignments_get_by_id_request(
    role_assignment_id: str, *, tenant_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{roleAssignmentId}"
    path_format_arguments = {
        "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tenant_id is not None:
        _params["tenantId"] = _SERIALIZER.query("tenant_id", tenant_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_assignments_create_by_id_request(role_assignment_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{roleAssignmentId}"
    path_format_arguments = {
        "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_assignments_delete_by_id_request(
    role_assignment_id: str, *, tenant_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{roleAssignmentId}"
    path_format_arguments = {
        "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if tenant_id is not None:
        _params["tenantId"] = _SERIALIZER.query("tenant_id", tenant_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_permissions_list_for_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Authorization/permissions"
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_permissions_list_for_resource_request(
    resource_group_name: str,
    resource_provider_namespace: str,
    parent_resource_path: str,
    resource_type: str,
    resource_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/permissions"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "resourceProviderNamespace": _SERIALIZER.url(
            "resource_provider_namespace", resource_provider_namespace, "str", skip_quote=True
        ),
        "parentResourcePath": _SERIALIZER.url("parent_resource_path", parent_resource_path, "str", skip_quote=True),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str", skip_quote=True),
        "resourceName": _SERIALIZER.url("resource_name", resource_name, "str", pattern=r".+"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_definitions_delete_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "roleDefinitionId": _SERIALIZER.url("role_definition_id", role_definition_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_definitions_get_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "roleDefinitionId": _SERIALIZER.url("role_definition_id", role_definition_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_definitions_create_or_update_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "roleDefinitionId": _SERIALIZER.url("role_definition_id", role_definition_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_definitions_list_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.Authorization/roleDefinitions"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_role_definitions_get_by_id_request(role_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{roleId}"
    path_format_arguments = {
        "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class DenyAssignmentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~authz.mgmt.AuthorizationManagementClient`'s
        :attr:`deny_assignments` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_for_resource(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        *,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets deny assignments for a resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource identity. Required.
        :type parent_resource_path: str
        :param resource_type: The resource type of the resource. Required.
        :type resource_type: str
        :param resource_name: The name of the resource to get deny assignments for. Required.
        :type resource_name: str
        :keyword filter: The filter to apply on the operation. Use $filter=atScope() to return all deny
         assignments at or above the scope. Use $filter=denyAssignmentName eq '{name}' to search deny
         assignments by name at specified scope. Use $filter=principalId eq '{id}' to return all deny
         assignments at, above and below the scope for the specified principal. Use
         $filter=gdprExportPrincipalId eq '{id}' to return all deny assignments at, above and below the
         scope for the specified principal. This filter is different from the principalId filter as it
         returns not only those deny assignments that contain the specified principal is the Principals
         list but also those deny assignments that contain the specified principal is the
         ExcludePrincipals list. Additionally, when gdprExportPrincipalId filter is used, only the deny
         assignment name and description properties are returned. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The deny assignment ID.
                    "name": "str",  # Optional. The deny assignment name.
                    "properties": {
                        "condition": "str",  # Optional. The conditions on the deny
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "denyAssignmentName": "str",  # Optional. The display name of the
                          deny assignment.
                        "description": "str",  # Optional. The description of the deny
                          assignment.
                        "doNotApplyToChildScopes": bool,  # Optional. Determines if the deny
                          assignment applies to child scopes. Default value is false.
                        "excludePrincipals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "isSystemProtected": bool,  # Optional. Specifies whether this deny
                          assignment was created by Azure and cannot be edited or deleted.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Actions to which the deny
                                      assignment does not grant access.
                                ],
                                "condition": "str",  # Optional. The conditions on
                                  the Deny assignment permission. This limits the resources it applies
                                  to.
                                "conditionVersion": "str",  # Optional. Version of
                                  the condition.
                                "dataActions": [
                                    "str"  # Optional. Data actions to which the
                                      deny assignment does not grant access.
                                ],
                                "notActions": [
                                    "str"  # Optional. Actions to exclude from
                                      that the deny assignment does not grant access.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Data actions to exclude
                                      from that the deny assignment does not grant access.
                                ]
                            }
                        ],
                        "principals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "scope": "str",  # Optional. The deny assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The deny assignment type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deny_assignments_list_for_resource_request(
                    resource_group_name=resource_group_name,
                    resource_provider_namespace=resource_provider_namespace,
                    parent_resource_path=parent_resource_path,
                    resource_type=resource_type,
                    resource_name=resource_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_for_resource_group(
        self, resource_group_name: str, *, filter: Optional[str] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets deny assignments for a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :keyword filter: The filter to apply on the operation. Use $filter=atScope() to return all deny
         assignments at or above the scope. Use $filter=denyAssignmentName eq '{name}' to search deny
         assignments by name at specified scope. Use $filter=principalId eq '{id}' to return all deny
         assignments at, above and below the scope for the specified principal. Use
         $filter=gdprExportPrincipalId eq '{id}' to return all deny assignments at, above and below the
         scope for the specified principal. This filter is different from the principalId filter as it
         returns not only those deny assignments that contain the specified principal is the Principals
         list but also those deny assignments that contain the specified principal is the
         ExcludePrincipals list. Additionally, when gdprExportPrincipalId filter is used, only the deny
         assignment name and description properties are returned. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The deny assignment ID.
                    "name": "str",  # Optional. The deny assignment name.
                    "properties": {
                        "condition": "str",  # Optional. The conditions on the deny
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "denyAssignmentName": "str",  # Optional. The display name of the
                          deny assignment.
                        "description": "str",  # Optional. The description of the deny
                          assignment.
                        "doNotApplyToChildScopes": bool,  # Optional. Determines if the deny
                          assignment applies to child scopes. Default value is false.
                        "excludePrincipals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "isSystemProtected": bool,  # Optional. Specifies whether this deny
                          assignment was created by Azure and cannot be edited or deleted.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Actions to which the deny
                                      assignment does not grant access.
                                ],
                                "condition": "str",  # Optional. The conditions on
                                  the Deny assignment permission. This limits the resources it applies
                                  to.
                                "conditionVersion": "str",  # Optional. Version of
                                  the condition.
                                "dataActions": [
                                    "str"  # Optional. Data actions to which the
                                      deny assignment does not grant access.
                                ],
                                "notActions": [
                                    "str"  # Optional. Actions to exclude from
                                      that the deny assignment does not grant access.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Data actions to exclude
                                      from that the deny assignment does not grant access.
                                ]
                            }
                        ],
                        "principals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "scope": "str",  # Optional. The deny assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The deny assignment type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deny_assignments_list_for_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list(self, *, filter: Optional[str] = None, **kwargs: Any) -> Iterable[JSON]:
        """Gets all deny assignments for the subscription.

        :keyword filter: The filter to apply on the operation. Use $filter=atScope() to return all deny
         assignments at or above the scope. Use $filter=denyAssignmentName eq '{name}' to search deny
         assignments by name at specified scope. Use $filter=principalId eq '{id}' to return all deny
         assignments at, above and below the scope for the specified principal. Use
         $filter=gdprExportPrincipalId eq '{id}' to return all deny assignments at, above and below the
         scope for the specified principal. This filter is different from the principalId filter as it
         returns not only those deny assignments that contain the specified principal is the Principals
         list but also those deny assignments that contain the specified principal is the
         ExcludePrincipals list. Additionally, when gdprExportPrincipalId filter is used, only the deny
         assignment name and description properties are returned. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The deny assignment ID.
                    "name": "str",  # Optional. The deny assignment name.
                    "properties": {
                        "condition": "str",  # Optional. The conditions on the deny
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "denyAssignmentName": "str",  # Optional. The display name of the
                          deny assignment.
                        "description": "str",  # Optional. The description of the deny
                          assignment.
                        "doNotApplyToChildScopes": bool,  # Optional. Determines if the deny
                          assignment applies to child scopes. Default value is false.
                        "excludePrincipals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "isSystemProtected": bool,  # Optional. Specifies whether this deny
                          assignment was created by Azure and cannot be edited or deleted.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Actions to which the deny
                                      assignment does not grant access.
                                ],
                                "condition": "str",  # Optional. The conditions on
                                  the Deny assignment permission. This limits the resources it applies
                                  to.
                                "conditionVersion": "str",  # Optional. Version of
                                  the condition.
                                "dataActions": [
                                    "str"  # Optional. Data actions to which the
                                      deny assignment does not grant access.
                                ],
                                "notActions": [
                                    "str"  # Optional. Actions to exclude from
                                      that the deny assignment does not grant access.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Data actions to exclude
                                      from that the deny assignment does not grant access.
                                ]
                            }
                        ],
                        "principals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "scope": "str",  # Optional. The deny assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The deny assignment type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deny_assignments_list_request(
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, scope: str, deny_assignment_id: str, **kwargs: Any) -> JSON:
        """Get the specified deny assignment.

        :param scope: The scope of the deny assignment. Required.
        :type scope: str
        :param deny_assignment_id: The ID of the deny assignment to get. Required.
        :type deny_assignment_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The deny assignment ID.
                    "name": "str",  # Optional. The deny assignment name.
                    "properties": {
                        "condition": "str",  # Optional. The conditions on the deny
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "denyAssignmentName": "str",  # Optional. The display name of the
                          deny assignment.
                        "description": "str",  # Optional. The description of the deny
                          assignment.
                        "doNotApplyToChildScopes": bool,  # Optional. Determines if the deny
                          assignment applies to child scopes. Default value is false.
                        "excludePrincipals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "isSystemProtected": bool,  # Optional. Specifies whether this deny
                          assignment was created by Azure and cannot be edited or deleted.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Actions to which the deny
                                      assignment does not grant access.
                                ],
                                "condition": "str",  # Optional. The conditions on
                                  the Deny assignment permission. This limits the resources it applies
                                  to.
                                "conditionVersion": "str",  # Optional. Version of
                                  the condition.
                                "dataActions": [
                                    "str"  # Optional. Data actions to which the
                                      deny assignment does not grant access.
                                ],
                                "notActions": [
                                    "str"  # Optional. Actions to exclude from
                                      that the deny assignment does not grant access.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Data actions to exclude
                                      from that the deny assignment does not grant access.
                                ]
                            }
                        ],
                        "principals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "scope": "str",  # Optional. The deny assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The deny assignment type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deny_assignments_get_request(
            scope=scope,
            deny_assignment_id=deny_assignment_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_by_id(self, deny_assignment_id: str, **kwargs: Any) -> JSON:
        """Gets a deny assignment by ID.

        :param deny_assignment_id: The fully qualified deny assignment ID. For example, use the format,
         /subscriptions/{guid}/providers/Microsoft.Authorization/denyAssignments/{denyAssignmentId} for
         subscription level deny assignments, or
         /providers/Microsoft.Authorization/denyAssignments/{denyAssignmentId} for tenant level deny
         assignments. Required.
        :type deny_assignment_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The deny assignment ID.
                    "name": "str",  # Optional. The deny assignment name.
                    "properties": {
                        "condition": "str",  # Optional. The conditions on the deny
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "denyAssignmentName": "str",  # Optional. The display name of the
                          deny assignment.
                        "description": "str",  # Optional. The description of the deny
                          assignment.
                        "doNotApplyToChildScopes": bool,  # Optional. Determines if the deny
                          assignment applies to child scopes. Default value is false.
                        "excludePrincipals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "isSystemProtected": bool,  # Optional. Specifies whether this deny
                          assignment was created by Azure and cannot be edited or deleted.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Actions to which the deny
                                      assignment does not grant access.
                                ],
                                "condition": "str",  # Optional. The conditions on
                                  the Deny assignment permission. This limits the resources it applies
                                  to.
                                "conditionVersion": "str",  # Optional. Version of
                                  the condition.
                                "dataActions": [
                                    "str"  # Optional. Data actions to which the
                                      deny assignment does not grant access.
                                ],
                                "notActions": [
                                    "str"  # Optional. Actions to exclude from
                                      that the deny assignment does not grant access.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Data actions to exclude
                                      from that the deny assignment does not grant access.
                                ]
                            }
                        ],
                        "principals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "scope": "str",  # Optional. The deny assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The deny assignment type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deny_assignments_get_by_id_request(
            deny_assignment_id=deny_assignment_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_for_scope(self, scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> Iterable[JSON]:
        """Gets deny assignments for a scope.

        :param scope: The scope of the deny assignments. Required.
        :type scope: str
        :keyword filter: The filter to apply on the operation. Use $filter=atScope() to return all deny
         assignments at or above the scope. Use $filter=denyAssignmentName eq '{name}' to search deny
         assignments by name at specified scope. Use $filter=principalId eq '{id}' to return all deny
         assignments at, above and below the scope for the specified principal. Use
         $filter=gdprExportPrincipalId eq '{id}' to return all deny assignments at, above and below the
         scope for the specified principal. This filter is different from the principalId filter as it
         returns not only those deny assignments that contain the specified principal is the Principals
         list but also those deny assignments that contain the specified principal is the
         ExcludePrincipals list. Additionally, when gdprExportPrincipalId filter is used, only the deny
         assignment name and description properties are returned. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The deny assignment ID.
                    "name": "str",  # Optional. The deny assignment name.
                    "properties": {
                        "condition": "str",  # Optional. The conditions on the deny
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "denyAssignmentName": "str",  # Optional. The display name of the
                          deny assignment.
                        "description": "str",  # Optional. The description of the deny
                          assignment.
                        "doNotApplyToChildScopes": bool,  # Optional. Determines if the deny
                          assignment applies to child scopes. Default value is false.
                        "excludePrincipals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "isSystemProtected": bool,  # Optional. Specifies whether this deny
                          assignment was created by Azure and cannot be edited or deleted.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Actions to which the deny
                                      assignment does not grant access.
                                ],
                                "condition": "str",  # Optional. The conditions on
                                  the Deny assignment permission. This limits the resources it applies
                                  to.
                                "conditionVersion": "str",  # Optional. Version of
                                  the condition.
                                "dataActions": [
                                    "str"  # Optional. Data actions to which the
                                      deny assignment does not grant access.
                                ],
                                "notActions": [
                                    "str"  # Optional. Actions to exclude from
                                      that the deny assignment does not grant access.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Data actions to exclude
                                      from that the deny assignment does not grant access.
                                ]
                            }
                        ],
                        "principals": [
                            {
                                "displayName": "str",  # Optional. The name of the
                                  principal made changes.
                                "email": "str",  # Optional. Email of principal.
                                "id": "str",  # Optional. The id of the principal
                                  made changes.
                                "type": "str"  # Optional. Type of principal such as
                                  user , group etc.
                            }
                        ],
                        "scope": "str",  # Optional. The deny assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The deny assignment type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deny_assignments_list_for_scope_request(
                    scope=scope,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class ProviderOperationsMetadataOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~authz.mgmt.AuthorizationManagementClient`'s
        :attr:`provider_operations_metadata` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, resource_provider_namespace: str, *, expand: str = "resourceTypes", **kwargs: Any) -> JSON:
        """Gets provider operations metadata for the specified resource provider.

        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :keyword expand: Specifies whether to expand the values. Default value is "resourceTypes".
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "displayName": "str",  # Optional. The provider display name.
                    "id": "str",  # Optional. The provider id.
                    "name": "str",  # Optional. The provider name.
                    "operations": [
                        {
                            "description": "str",  # Optional. The operation description.
                            "displayName": "str",  # Optional. The operation display
                              name.
                            "isDataAction": bool,  # Optional. The dataAction flag to
                              specify the operation type.
                            "name": "str",  # Optional. The operation name.
                            "origin": "str",  # Optional. The operation origin.
                            "properties": {}  # Optional. The operation properties.
                        }
                    ],
                    "resourceTypes": [
                        {
                            "displayName": "str",  # Optional. The resource type display
                              name.
                            "name": "str",  # Optional. The resource type name.
                            "operations": [
                                {
                                    "description": "str",  # Optional. The
                                      operation description.
                                    "displayName": "str",  # Optional. The
                                      operation display name.
                                    "isDataAction": bool,  # Optional. The
                                      dataAction flag to specify the operation type.
                                    "name": "str",  # Optional. The operation
                                      name.
                                    "origin": "str",  # Optional. The operation
                                      origin.
                                    "properties": {}  # Optional. The operation
                                      properties.
                                }
                            ]
                        }
                    ],
                    "type": "str"  # Optional. The provider type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_provider_operations_metadata_get_request(
            resource_provider_namespace=resource_provider_namespace,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list(self, *, expand: str = "resourceTypes", **kwargs: Any) -> Iterable[JSON]:
        """Gets provider operations metadata for all resource providers.

        :keyword expand: Specifies whether to expand the values. Default value is "resourceTypes".
        :paramtype expand: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "displayName": "str",  # Optional. The provider display name.
                    "id": "str",  # Optional. The provider id.
                    "name": "str",  # Optional. The provider name.
                    "operations": [
                        {
                            "description": "str",  # Optional. The operation description.
                            "displayName": "str",  # Optional. The operation display
                              name.
                            "isDataAction": bool,  # Optional. The dataAction flag to
                              specify the operation type.
                            "name": "str",  # Optional. The operation name.
                            "origin": "str",  # Optional. The operation origin.
                            "properties": {}  # Optional. The operation properties.
                        }
                    ],
                    "resourceTypes": [
                        {
                            "displayName": "str",  # Optional. The resource type display
                              name.
                            "name": "str",  # Optional. The resource type name.
                            "operations": [
                                {
                                    "description": "str",  # Optional. The
                                      operation description.
                                    "displayName": "str",  # Optional. The
                                      operation display name.
                                    "isDataAction": bool,  # Optional. The
                                      dataAction flag to specify the operation type.
                                    "name": "str",  # Optional. The operation
                                      name.
                                    "origin": "str",  # Optional. The operation
                                      origin.
                                    "properties": {}  # Optional. The operation
                                      properties.
                                }
                            ]
                        }
                    ],
                    "type": "str"  # Optional. The provider type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_provider_operations_metadata_list_request(
                    expand=expand,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class RoleAssignmentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~authz.mgmt.AuthorizationManagementClient`'s
        :attr:`role_assignments` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_for_subscription(
        self, *, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """List all role assignments that apply to a subscription.

        :keyword filter: The filter to apply on the operation. Use $filter=atScope() to return all role
         assignments at or above the scope. Use $filter=principalId eq {id} to return all role
         assignments at, above or below the scope for the specified principal. Default value is None.
        :paramtype filter: str
        :keyword tenant_id: Tenant ID for cross-tenant request. Default value is None.
        :paramtype tenant_id: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_role_assignments_list_for_subscription_request(
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    tenant_id=tenant_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_for_resource_group(
        self, resource_group_name: str, *, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """List all role assignments that apply to a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :keyword filter: The filter to apply on the operation. Use $filter=atScope() to return all role
         assignments at or above the scope. Use $filter=principalId eq {id} to return all role
         assignments at, above or below the scope for the specified principal. Default value is None.
        :paramtype filter: str
        :keyword tenant_id: Tenant ID for cross-tenant request. Default value is None.
        :paramtype tenant_id: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_role_assignments_list_for_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    tenant_id=tenant_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_for_resource(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        resource_type: str,
        resource_name: str,
        *,
        filter: Optional[str] = None,
        tenant_id: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """List all role assignments that apply to a resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :param resource_type: The resource type name. For example the type name of a web app is 'sites'
         (from Microsoft.Web/sites). Required.
        :type resource_type: str
        :param resource_name: The resource name. Required.
        :type resource_name: str
        :keyword filter: The filter to apply on the operation. Use $filter=atScope() to return all role
         assignments at or above the scope. Use $filter=principalId eq {id} to return all role
         assignments at, above or below the scope for the specified principal. Default value is None.
        :paramtype filter: str
        :keyword tenant_id: Tenant ID for cross-tenant request. Default value is None.
        :paramtype tenant_id: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_role_assignments_list_for_resource_request(
                    resource_group_name=resource_group_name,
                    resource_provider_namespace=resource_provider_namespace,
                    resource_type=resource_type,
                    resource_name=resource_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    tenant_id=tenant_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, scope: str, role_assignment_name: str, *, tenant_id: Optional[str] = None, **kwargs: Any) -> JSON:
        """Get a role assignment by scope and name.

        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
         '/subscriptions/{subscriptionId}'), resource group (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
         Required.
        :type scope: str
        :param role_assignment_name: The name of the role assignment. It can be any valid GUID.
         Required.
        :type role_assignment_name: str
        :keyword tenant_id: Tenant ID for cross-tenant request. Default value is None.
        :paramtype tenant_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_role_assignments_get_request(
            scope=scope,
            role_assignment_name=role_assignment_name,
            tenant_id=tenant_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create(
        self,
        scope: str,
        role_assignment_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create or update a role assignment by scope and name.

        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
         '/subscriptions/{subscriptionId}'), resource group (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
         Required.
        :type scope: str
        :param role_assignment_name: The name of the role assignment. It can be any valid GUID.
         Required.
        :type role_assignment_name: str
        :param parameters: Parameters for the role assignment. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """

    @overload
    def create(
        self,
        scope: str,
        role_assignment_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create or update a role assignment by scope and name.

        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
         '/subscriptions/{subscriptionId}'), resource group (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
         Required.
        :type scope: str
        :param role_assignment_name: The name of the role assignment. It can be any valid GUID.
         Required.
        :type role_assignment_name: str
        :param parameters: Parameters for the role assignment. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """

    @distributed_trace
    def create(self, scope: str, role_assignment_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Create or update a role assignment by scope and name.

        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
         '/subscriptions/{subscriptionId}'), resource group (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
         Required.
        :type scope: str
        :param role_assignment_name: The name of the role assignment. It can be any valid GUID.
         Required.
        :type role_assignment_name: str
        :param parameters: Parameters for the role assignment. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_role_assignments_create_request(
            scope=scope,
            role_assignment_name=role_assignment_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(
        self, scope: str, role_assignment_name: str, *, tenant_id: Optional[str] = None, **kwargs: Any
    ) -> Optional[JSON]:
        """Delete a role assignment by scope and name.

        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
         '/subscriptions/{subscriptionId}'), resource group (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
         Required.
        :type scope: str
        :param role_assignment_name: The name of the role assignment. It can be any valid GUID.
         Required.
        :type role_assignment_name: str
        :keyword tenant_id: Tenant ID for cross-tenant request. Default value is None.
        :paramtype tenant_id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        request = build_role_assignments_delete_request(
            scope=scope,
            role_assignment_name=role_assignment_name,
            tenant_id=tenant_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list_for_scope(
        self,
        scope: str,
        *,
        filter: Optional[str] = None,
        tenant_id: Optional[str] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """List all role assignments that apply to a scope.

        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
         '/subscriptions/{subscriptionId}'), resource group (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
         Required.
        :type scope: str
        :keyword filter: The filter to apply on the operation. Use $filter=atScope() to return all role
         assignments at or above the scope. Use $filter=principalId eq {id} to return all role
         assignments at, above or below the scope for the specified principal. Default value is None.
        :paramtype filter: str
        :keyword tenant_id: Tenant ID for cross-tenant request. Default value is None.
        :paramtype tenant_id: str
        :keyword skip_token: The skipToken to apply on the operation. Use $skipToken={skiptoken} to
         return paged role assignments following the skipToken passed. Only supported on provider level
         calls. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_role_assignments_list_for_scope_request(
                    scope=scope,
                    filter=filter,
                    tenant_id=tenant_id,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_by_id(self, role_assignment_id: str, *, tenant_id: Optional[str] = None, **kwargs: Any) -> JSON:
        """Get a role assignment by ID.

        :param role_assignment_id: The fully qualified ID of the role assignment including scope,
         resource name, and resource type. Format:
         /{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}. Example:
         /subscriptions/:code:`<SUB_ID>`/resourcegroups/:code:`<RESOURCE_GROUP>`/providers/Microsoft.Authorization/roleAssignments/:code:`<ROLE_ASSIGNMENT_NAME>`.
         Required.
        :type role_assignment_id: str
        :keyword tenant_id: Tenant ID for cross-tenant request. Default value is None.
        :paramtype tenant_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_role_assignments_get_by_id_request(
            role_assignment_id=role_assignment_id,
            tenant_id=tenant_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_by_id(
        self, role_assignment_id: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create or update a role assignment by ID.

        :param role_assignment_id: The fully qualified ID of the role assignment including scope,
         resource name, and resource type. Format:
         /{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}. Example:
         /subscriptions/:code:`<SUB_ID>`/resourcegroups/:code:`<RESOURCE_GROUP>`/providers/Microsoft.Authorization/roleAssignments/:code:`<ROLE_ASSIGNMENT_NAME>`.
         Required.
        :type role_assignment_id: str
        :param parameters: Parameters for the role assignment. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """

    @overload
    def create_by_id(
        self, role_assignment_id: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create or update a role assignment by ID.

        :param role_assignment_id: The fully qualified ID of the role assignment including scope,
         resource name, and resource type. Format:
         /{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}. Example:
         /subscriptions/:code:`<SUB_ID>`/resourcegroups/:code:`<RESOURCE_GROUP>`/providers/Microsoft.Authorization/roleAssignments/:code:`<ROLE_ASSIGNMENT_NAME>`.
         Required.
        :type role_assignment_id: str
        :param parameters: Parameters for the role assignment. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """

    @distributed_trace
    def create_by_id(self, role_assignment_id: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Create or update a role assignment by ID.

        :param role_assignment_id: The fully qualified ID of the role assignment including scope,
         resource name, and resource type. Format:
         /{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}. Example:
         /subscriptions/:code:`<SUB_ID>`/resourcegroups/:code:`<RESOURCE_GROUP>`/providers/Microsoft.Authorization/roleAssignments/:code:`<ROLE_ASSIGNMENT_NAME>`.
         Required.
        :type role_assignment_id: str
        :param parameters: Parameters for the role assignment. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_role_assignments_create_by_id_request(
            role_assignment_id=role_assignment_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete_by_id(
        self, role_assignment_id: str, *, tenant_id: Optional[str] = None, **kwargs: Any
    ) -> Optional[JSON]:
        """Delete a role assignment by ID.

        :param role_assignment_id: The fully qualified ID of the role assignment including scope,
         resource name, and resource type. Format:
         /{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}. Example:
         /subscriptions/:code:`<SUB_ID>`/resourcegroups/:code:`<RESOURCE_GROUP>`/providers/Microsoft.Authorization/roleAssignments/:code:`<ROLE_ASSIGNMENT_NAME>`.
         Required.
        :type role_assignment_id: str
        :keyword tenant_id: Tenant ID for cross-tenant request. Default value is None.
        :paramtype tenant_id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role assignment ID.
                    "name": "str",  # Optional. The role assignment name.
                    "properties": {
                        "principalId": "str",  # The principal ID. Required.
                        "roleDefinitionId": "str",  # The role definition ID. Required.
                        "condition": "str",  # Optional. The conditions on the role
                          assignment. This limits the resources it can be assigned to. e.g.:
                          @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName]
                          StringEqualsIgnoreCase 'foo_storage_container'.
                        "conditionVersion": "str",  # Optional. Version of the condition.
                          Currently the only accepted value is '2.0'.
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "delegatedManagedIdentityResourceId": "str",  # Optional. Id of the
                          delegated managed identity resource.
                        "description": "str",  # Optional. Description of role assignment.
                        "principalType": "User",  # Optional. Default value is "User". The
                          principal type of the assigned principal ID. Known values are: "User",
                          "Group", "ServicePrincipal", "ForeignGroup", and "Device".
                        "scope": "str",  # Optional. The role assignment scope.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role assignment type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        request = build_role_assignments_delete_by_id_request(
            role_assignment_id=role_assignment_id,
            tenant_id=tenant_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class PermissionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~authz.mgmt.AuthorizationManagementClient`'s
        :attr:`permissions` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_for_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Gets all permissions the caller has for a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actions": [
                        "str"  # Optional. Allowed actions.
                    ],
                    "dataActions": [
                        "str"  # Optional. Allowed Data actions.
                    ],
                    "notActions": [
                        "str"  # Optional. Denied actions.
                    ],
                    "notDataActions": [
                        "str"  # Optional. Denied Data actions.
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_permissions_list_for_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_for_resource(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets all permissions the caller has for a resource.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource identity. Required.
        :type parent_resource_path: str
        :param resource_type: The resource type of the resource. Required.
        :type resource_type: str
        :param resource_name: The name of the resource to get the permissions for. Required.
        :type resource_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actions": [
                        "str"  # Optional. Allowed actions.
                    ],
                    "dataActions": [
                        "str"  # Optional. Allowed Data actions.
                    ],
                    "notActions": [
                        "str"  # Optional. Denied actions.
                    ],
                    "notDataActions": [
                        "str"  # Optional. Denied Data actions.
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_permissions_list_for_resource_request(
                    resource_group_name=resource_group_name,
                    resource_provider_namespace=resource_provider_namespace,
                    parent_resource_path=parent_resource_path,
                    resource_type=resource_type,
                    resource_name=resource_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class RoleDefinitionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~authz.mgmt.AuthorizationManagementClient`'s
        :attr:`role_definitions` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def delete(self, scope: str, role_definition_id: str, **kwargs: Any) -> Optional[JSON]:
        """Deletes a role definition.

        :param scope: The scope of the role definition. Required.
        :type scope: str
        :param role_definition_id: The ID of the role definition to delete. Required.
        :type role_definition_id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role definition ID.
                    "name": "str",  # Optional. The role definition name.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. Role definition assignable scopes.
                        ],
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "description": "str",  # Optional. The role definition description.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Allowed actions.
                                ],
                                "dataActions": [
                                    "str"  # Optional. Allowed Data actions.
                                ],
                                "notActions": [
                                    "str"  # Optional. Denied actions.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Denied Data actions.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. The role name.
                        "type": "str",  # Optional. The role type.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role definition type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        request = build_role_definitions_delete_request(
            scope=scope,
            role_definition_id=role_definition_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get(self, scope: str, role_definition_id: str, **kwargs: Any) -> JSON:
        """Get role definition by name (GUID).

        :param scope: The scope of the role definition. Required.
        :type scope: str
        :param role_definition_id: The ID of the role definition. Required.
        :type role_definition_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role definition ID.
                    "name": "str",  # Optional. The role definition name.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. Role definition assignable scopes.
                        ],
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "description": "str",  # Optional. The role definition description.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Allowed actions.
                                ],
                                "dataActions": [
                                    "str"  # Optional. Allowed Data actions.
                                ],
                                "notActions": [
                                    "str"  # Optional. Denied actions.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Denied Data actions.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. The role name.
                        "type": "str",  # Optional. The role type.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role definition type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_role_definitions_get_request(
            scope=scope,
            role_definition_id=role_definition_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        scope: str,
        role_definition_id: str,
        role_definition: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a role definition.

        :param scope: The scope of the role definition. Required.
        :type scope: str
        :param role_definition_id: The ID of the role definition. Required.
        :type role_definition_id: str
        :param role_definition: The values for the role definition. Required.
        :type role_definition: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                role_definition = {
                    "id": "str",  # Optional. The role definition ID.
                    "name": "str",  # Optional. The role definition name.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. Role definition assignable scopes.
                        ],
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "description": "str",  # Optional. The role definition description.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Allowed actions.
                                ],
                                "dataActions": [
                                    "str"  # Optional. Allowed Data actions.
                                ],
                                "notActions": [
                                    "str"  # Optional. Denied actions.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Denied Data actions.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. The role name.
                        "type": "str",  # Optional. The role type.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role definition type.
                }

                # response body for status code(s): 201
                response == {
                    "id": "str",  # Optional. The role definition ID.
                    "name": "str",  # Optional. The role definition name.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. Role definition assignable scopes.
                        ],
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "description": "str",  # Optional. The role definition description.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Allowed actions.
                                ],
                                "dataActions": [
                                    "str"  # Optional. Allowed Data actions.
                                ],
                                "notActions": [
                                    "str"  # Optional. Denied actions.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Denied Data actions.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. The role name.
                        "type": "str",  # Optional. The role type.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role definition type.
                }
        """

    @overload
    def create_or_update(
        self,
        scope: str,
        role_definition_id: str,
        role_definition: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a role definition.

        :param scope: The scope of the role definition. Required.
        :type scope: str
        :param role_definition_id: The ID of the role definition. Required.
        :type role_definition_id: str
        :param role_definition: The values for the role definition. Required.
        :type role_definition: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "id": "str",  # Optional. The role definition ID.
                    "name": "str",  # Optional. The role definition name.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. Role definition assignable scopes.
                        ],
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "description": "str",  # Optional. The role definition description.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Allowed actions.
                                ],
                                "dataActions": [
                                    "str"  # Optional. Allowed Data actions.
                                ],
                                "notActions": [
                                    "str"  # Optional. Denied actions.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Denied Data actions.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. The role name.
                        "type": "str",  # Optional. The role type.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role definition type.
                }
        """

    @distributed_trace
    def create_or_update(
        self, scope: str, role_definition_id: str, role_definition: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or updates a role definition.

        :param scope: The scope of the role definition. Required.
        :type scope: str
        :param role_definition_id: The ID of the role definition. Required.
        :type role_definition_id: str
        :param role_definition: The values for the role definition. Is either a JSON type or a IO type.
         Required.
        :type role_definition: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                role_definition = {
                    "id": "str",  # Optional. The role definition ID.
                    "name": "str",  # Optional. The role definition name.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. Role definition assignable scopes.
                        ],
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "description": "str",  # Optional. The role definition description.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Allowed actions.
                                ],
                                "dataActions": [
                                    "str"  # Optional. Allowed Data actions.
                                ],
                                "notActions": [
                                    "str"  # Optional. Denied actions.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Denied Data actions.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. The role name.
                        "type": "str",  # Optional. The role type.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role definition type.
                }

                # response body for status code(s): 201
                response == {
                    "id": "str",  # Optional. The role definition ID.
                    "name": "str",  # Optional. The role definition name.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. Role definition assignable scopes.
                        ],
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "description": "str",  # Optional. The role definition description.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Allowed actions.
                                ],
                                "dataActions": [
                                    "str"  # Optional. Allowed Data actions.
                                ],
                                "notActions": [
                                    "str"  # Optional. Denied actions.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Denied Data actions.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. The role name.
                        "type": "str",  # Optional. The role type.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role definition type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(role_definition, (IOBase, bytes)):
            _content = role_definition
        else:
            _json = role_definition

        request = build_role_definitions_create_or_update_request(
            scope=scope,
            role_definition_id=role_definition_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list(self, scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> Iterable[JSON]:
        """Get all role definitions that are applicable at scope and above.

        :param scope: The scope of the role definition. Required.
        :type scope: str
        :keyword filter: The filter to apply on the operation. Use atScopeAndBelow filter to search
         below the given scope as well. Default value is None.
        :paramtype filter: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role definition ID.
                    "name": "str",  # Optional. The role definition name.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. Role definition assignable scopes.
                        ],
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "description": "str",  # Optional. The role definition description.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Allowed actions.
                                ],
                                "dataActions": [
                                    "str"  # Optional. Allowed Data actions.
                                ],
                                "notActions": [
                                    "str"  # Optional. Denied actions.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Denied Data actions.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. The role name.
                        "type": "str",  # Optional. The role type.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role definition type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_role_definitions_list_request(
                    scope=scope,
                    filter=filter,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_by_id(self, role_id: str, **kwargs: Any) -> JSON:
        """Gets a role definition by ID.

        :param role_id: The fully qualified role definition ID. Use the format,
         /subscriptions/{guid}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId} for
         subscription level role definitions, or
         /providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId} for tenant level role
         definitions. Required.
        :type role_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The role definition ID.
                    "name": "str",  # Optional. The role definition name.
                    "properties": {
                        "assignableScopes": [
                            "str"  # Optional. Role definition assignable scopes.
                        ],
                        "createdBy": "str",  # Optional. Id of the user who created the
                          assignment.
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Time it was created.
                        "description": "str",  # Optional. The role definition description.
                        "permissions": [
                            {
                                "actions": [
                                    "str"  # Optional. Allowed actions.
                                ],
                                "dataActions": [
                                    "str"  # Optional. Allowed Data actions.
                                ],
                                "notActions": [
                                    "str"  # Optional. Denied actions.
                                ],
                                "notDataActions": [
                                    "str"  # Optional. Denied Data actions.
                                ]
                            }
                        ],
                        "roleName": "str",  # Optional. The role name.
                        "type": "str",  # Optional. The role type.
                        "updatedBy": "str",  # Optional. Id of the user who updated the
                          assignment.
                        "updatedOn": "2020-02-20 00:00:00"  # Optional. Time it was updated.
                    },
                    "type": "str"  # Optional. The role definition type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_role_definitions_get_by_id_request(
            role_id=role_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)
