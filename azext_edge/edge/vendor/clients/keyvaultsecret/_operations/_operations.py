# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer
from .._vendor import KeyVaultClientMixinABC, _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_key_vault_full_backup_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/backup"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_full_backup_status_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/backup/{jobId}/pending"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_full_restore_operation_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/restore"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_restore_status_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/restore/{jobId}/pending"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_selective_key_restore_operation_request(key_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{keyName}/restore"
    path_format_arguments = {
        "keyName": _SERIALIZER.url("key_name", key_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_certificates_request(
    *, maxresults: Optional[int] = None, include_pending: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates"

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    if include_pending is not None:
        _params["includePending"] = _SERIALIZER.query("include_pending", include_pending, "bool")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_delete_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_set_certificate_contacts_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/contacts"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_certificate_contacts_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/contacts"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_delete_certificate_contacts_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/contacts"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_certificate_issuers_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/issuers"

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_set_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/issuers/{issuer-name}"
    path_format_arguments = {
        "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_update_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/issuers/{issuer-name}"
    path_format_arguments = {
        "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/issuers/{issuer-name}"
    path_format_arguments = {
        "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_delete_certificate_issuer_request(issuer_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/issuers/{issuer-name}"
    path_format_arguments = {
        "issuer-name": _SERIALIZER.url("issuer_name", issuer_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_create_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/create"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_import_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/import"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_certificate_versions_request(
    certificate_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/versions"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_certificate_policy_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/policy"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_update_certificate_policy_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/policy"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_update_certificate_request(
    certificate_name: str, certificate_version: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/{certificate-version}"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
        "certificate-version": _SERIALIZER.url("certificate_version", certificate_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_certificate_request(
    certificate_name: str, certificate_version: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/{certificate-version}"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
        "certificate-version": _SERIALIZER.url("certificate_version", certificate_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_update_certificate_operation_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/pending"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_certificate_operation_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/pending"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_delete_certificate_operation_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/pending"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_merge_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/pending/merge"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_backup_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/{certificate-name}/backup"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_restore_certificate_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/certificates/restore"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_certificates_request(
    *, maxresults: Optional[int] = None, include_pending: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedcertificates"

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    if include_pending is not None:
        _params["includePending"] = _SERIALIZER.query("include_pending", include_pending, "bool")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedcertificates/{certificate-name}"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_purge_deleted_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedcertificates/{certificate-name}"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_recover_deleted_certificate_request(certificate_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedcertificates/{certificate-name}/recover"
    path_format_arguments = {
        "certificate-name": _SERIALIZER.url("certificate_name", certificate_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_create_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/create"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_rotate_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/rotate"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_import_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_delete_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_update_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/{key-version}"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
        "key-version": _SERIALIZER.url("key_version", key_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/{key-version}"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
        "key-version": _SERIALIZER.url("key_version", key_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_key_versions_request(
    key_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/versions"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys"

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_backup_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/backup"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_restore_key_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/restore"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_encrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/{key-version}/encrypt"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
        "key-version": _SERIALIZER.url("key_version", key_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_decrypt_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/{key-version}/decrypt"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
        "key-version": _SERIALIZER.url("key_version", key_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_sign_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/{key-version}/sign"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
        "key-version": _SERIALIZER.url("key_version", key_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_verify_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/{key-version}/verify"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
        "key-version": _SERIALIZER.url("key_version", key_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_wrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/{key-version}/wrapkey"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
        "key-version": _SERIALIZER.url("key_version", key_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_unwrap_key_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/{key-version}/unwrapkey"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
        "key-version": _SERIALIZER.url("key_version", key_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_release_request(key_name: str, key_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/{key-version}/release"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
        "key-version": _SERIALIZER.url("key_version", key_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_keys_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedkeys"

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedkeys/{key-name}"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_purge_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedkeys/{key-name}"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_recover_deleted_key_request(key_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedkeys/{key-name}/recover"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_key_rotation_policy_request(key_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/rotationpolicy"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_update_key_rotation_policy_request(key_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/keys/{key-name}/rotationpolicy"
    path_format_arguments = {
        "key-name": _SERIALIZER.url("key_name", key_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_random_bytes_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/rng"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_set_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str", pattern=r"^[0-9a-zA-Z-]+$"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_delete_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_update_secret_request(secret_name: str, secret_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}/{secret-version}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
        "secret-version": _SERIALIZER.url("secret_version", secret_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_secret_request(secret_name: str, secret_version: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}/{secret-version}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
        "secret-version": _SERIALIZER.url("secret_version", secret_version, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_secrets_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets"

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_secret_versions_request(
    secret_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}/versions"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_secrets_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedsecrets"

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedsecrets/{secret-name}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_purge_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedsecrets/{secret-name}"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_recover_deleted_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedsecrets/{secret-name}/recover"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_backup_secret_request(secret_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/{secret-name}/backup"
    path_format_arguments = {
        "secret-name": _SERIALIZER.url("secret_name", secret_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_restore_secret_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/secrets/restore"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_update_setting_request(setting_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/settings/{setting-name}"
    path_format_arguments = {
        "setting-name": _SERIALIZER.url("setting_name", setting_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_setting_request(setting_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/settings/{setting-name}"
    path_format_arguments = {
        "setting-name": _SERIALIZER.url("setting_name", setting_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_settings_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/settings"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_storage_accounts_request(*, maxresults: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage"

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_storage_accounts_request(
    *, maxresults: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedstorage"

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedstorage/{storage-account-name}"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_purge_deleted_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedstorage/{storage-account-name}"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_recover_deleted_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedstorage/{storage-account-name}/recover"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_backup_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/{storage-account-name}/backup"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url("storage_account_name", storage_account_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_restore_storage_account_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/restore"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_delete_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/{storage-account-name}"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/{storage-account-name}"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_set_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/{storage-account-name}"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_update_storage_account_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/{storage-account-name}"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_regenerate_storage_account_key_request(storage_account_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/{storage-account-name}/regeneratekey"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_sas_definitions_request(
    storage_account_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/{storage-account-name}/sas"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_sas_definitions_request(
    storage_account_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedstorage/{storage-account-name}/sas"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    if maxresults is not None:
        _params["maxresults"] = _SERIALIZER.query("maxresults", maxresults, "int", maximum=25, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_deleted_sas_definition_request(
    storage_account_name: str, sas_definition_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
        "sas-definition-name": _SERIALIZER.url(
            "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_recover_deleted_sas_definition_request(
    storage_account_name: str, sas_definition_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
        "sas-definition-name": _SERIALIZER.url(
            "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_delete_sas_definition_request(
    storage_account_name: str, sas_definition_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/{storage-account-name}/sas/{sas-definition-name}"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
        "sas-definition-name": _SERIALIZER.url(
            "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_get_sas_definition_request(
    storage_account_name: str, sas_definition_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/{storage-account-name}/sas/{sas-definition-name}"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
        "sas-definition-name": _SERIALIZER.url(
            "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_set_sas_definition_request(
    storage_account_name: str, sas_definition_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/{storage-account-name}/sas/{sas-definition-name}"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
        "sas-definition-name": _SERIALIZER.url(
            "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_key_vault_update_sas_definition_request(
    storage_account_name: str, sas_definition_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "7.5"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/storage/{storage-account-name}/sas/{sas-definition-name}"
    path_format_arguments = {
        "storage-account-name": _SERIALIZER.url(
            "storage_account_name", storage_account_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
        "sas-definition-name": _SERIALIZER.url(
            "sas_definition_name", sas_definition_name, "str", pattern=r"^[0-9a-zA-Z]+$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


class KeyVaultClientOperationsMixin(KeyVaultClientMixinABC):  # pylint: disable=too-many-public-methods
    def _full_backup_initial(
        self, vault_base_url: str, azure_storage_blob_container_uri: Optional[Union[JSON, IO]] = None, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(azure_storage_blob_container_uri, (IOBase, bytes)):
            _content = azure_storage_blob_container_uri
        else:
            if azure_storage_blob_container_uri is not None:
                _json = azure_storage_blob_container_uri
            else:
                _json = None

        request = build_key_vault_full_backup_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
        response_headers["Azure-AsyncOperation"] = self._deserialize(
            "str", response.headers.get("Azure-AsyncOperation")
        )

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)

    @overload
    def begin_full_backup(
        self,
        vault_base_url: str,
        azure_storage_blob_container_uri: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a full backup using a user-provided SAS token to an Azure blob storage container.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
         valid Azure blob container where full backup needs to be stored. This token needs to be valid
         for at least next 24 hours from the time of making this call. Default value is None.
        :type azure_storage_blob_container_uri: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                azure_storage_blob_container_uri = {
                    "storageResourceUri": "str",  # Azure Blob storage container Uri. Required.
                    "token": "str",  # Optional. The SAS token pointing to an Azure Blob storage
                      container.
                    "useManagedIdentity": False  # Optional. Default value is False. Indicates
                      which authentication method should be used. If set to true, Managed HSM will use
                      the configured user-assigned managed identity to authenticate with Azure Storage.
                      Otherwise, a SAS token has to be specified.
                }

                # response body for status code(s): 202
                response == {
                    "azureStorageBlobContainerUri": "str",  # Optional. The Azure blob storage
                      container Uri which contains the full backup.
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the backup
                      operation in UTC.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "jobId": "str",  # Optional. Identifier for the full backup operation.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time of the backup
                      operation in UTC.
                    "status": "str",  # Optional. Status of the backup operation.
                    "statusDetails": "str"  # Optional. The status details of backup operation.
                }
        """

    @overload
    def begin_full_backup(
        self,
        vault_base_url: str,
        azure_storage_blob_container_uri: Optional[IO] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a full backup using a user-provided SAS token to an Azure blob storage container.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
         valid Azure blob container where full backup needs to be stored. This token needs to be valid
         for at least next 24 hours from the time of making this call. Default value is None.
        :type azure_storage_blob_container_uri: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "azureStorageBlobContainerUri": "str",  # Optional. The Azure blob storage
                      container Uri which contains the full backup.
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the backup
                      operation in UTC.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "jobId": "str",  # Optional. Identifier for the full backup operation.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time of the backup
                      operation in UTC.
                    "status": "str",  # Optional. Status of the backup operation.
                    "statusDetails": "str"  # Optional. The status details of backup operation.
                }
        """

    @distributed_trace
    def begin_full_backup(
        self, vault_base_url: str, azure_storage_blob_container_uri: Optional[Union[JSON, IO]] = None, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Creates a full backup using a user-provided SAS token to an Azure blob storage container.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param azure_storage_blob_container_uri: Azure blob shared access signature token pointing to a
         valid Azure blob container where full backup needs to be stored. This token needs to be valid
         for at least next 24 hours from the time of making this call. Is either a JSON type or a IO
         type. Default value is None.
        :type azure_storage_blob_container_uri: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                azure_storage_blob_container_uri = {
                    "storageResourceUri": "str",  # Azure Blob storage container Uri. Required.
                    "token": "str",  # Optional. The SAS token pointing to an Azure Blob storage
                      container.
                    "useManagedIdentity": False  # Optional. Default value is False. Indicates
                      which authentication method should be used. If set to true, Managed HSM will use
                      the configured user-assigned managed identity to authenticate with Azure Storage.
                      Otherwise, a SAS token has to be specified.
                }

                # response body for status code(s): 202
                response == {
                    "azureStorageBlobContainerUri": "str",  # Optional. The Azure blob storage
                      container Uri which contains the full backup.
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the backup
                      operation in UTC.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "jobId": "str",  # Optional. Identifier for the full backup operation.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time of the backup
                      operation in UTC.
                    "status": "str",  # Optional. Status of the backup operation.
                    "statusDetails": "str"  # Optional. The status details of backup operation.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._full_backup_initial(
                vault_base_url=vault_base_url,
                azure_storage_blob_container_uri=azure_storage_blob_container_uri,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod,
                ARMPolling(
                    lro_delay,
                    lro_options={"final-state-via": "azure-async-operation"},
                    path_format_arguments=path_format_arguments,
                    **kwargs
                ),
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def full_backup_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> JSON:
        """Returns the status of full backup operation.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param job_id: The id returned as part of the backup request. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "azureStorageBlobContainerUri": "str",  # Optional. The Azure blob storage
                      container Uri which contains the full backup.
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the backup
                      operation in UTC.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "jobId": "str",  # Optional. Identifier for the full backup operation.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time of the backup
                      operation in UTC.
                    "status": "str",  # Optional. Status of the backup operation.
                    "statusDetails": "str"  # Optional. The status details of backup operation.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_full_backup_status_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _full_restore_operation_initial(
        self, vault_base_url: str, restore_blob_details: Optional[Union[JSON, IO]] = None, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(restore_blob_details, (IOBase, bytes)):
            _content = restore_blob_details
        else:
            if restore_blob_details is not None:
                _json = restore_blob_details
            else:
                _json = None

        request = build_key_vault_full_restore_operation_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
        response_headers["Azure-AsyncOperation"] = self._deserialize(
            "str", response.headers.get("Azure-AsyncOperation")
        )

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)

    @overload
    def begin_full_restore_operation(
        self,
        vault_base_url: str,
        restore_blob_details: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
        storage backup folder.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
         successful full backup was stored. Default value is None.
        :type restore_blob_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                restore_blob_details = {
                    "folderToRestore": "str",  # The Folder name of the blob where the previous
                      successful full backup was stored. Required.
                    "sasTokenParameters": {
                        "storageResourceUri": "str",  # Azure Blob storage container Uri.
                          Required.
                        "token": "str",  # Optional. The SAS token pointing to an Azure Blob
                          storage container.
                        "useManagedIdentity": False  # Optional. Default value is False.
                          Indicates which authentication method should be used. If set to true, Managed
                          HSM will use the configured user-assigned managed identity to authenticate
                          with Azure Storage. Otherwise, a SAS token has to be specified.
                    }
                }

                # response body for status code(s): 202
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the restore
                      operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "jobId": "str",  # Optional. Identifier for the restore operation.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time of the
                      restore operation.
                    "status": "str",  # Optional. Status of the restore operation.
                    "statusDetails": "str"  # Optional. The status details of restore operation.
                }
        """

    @overload
    def begin_full_restore_operation(
        self,
        vault_base_url: str,
        restore_blob_details: Optional[IO] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
        storage backup folder.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
         successful full backup was stored. Default value is None.
        :type restore_blob_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the restore
                      operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "jobId": "str",  # Optional. Identifier for the restore operation.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time of the
                      restore operation.
                    "status": "str",  # Optional. Status of the restore operation.
                    "statusDetails": "str"  # Optional. The status details of restore operation.
                }
        """

    @distributed_trace
    def begin_full_restore_operation(
        self, vault_base_url: str, restore_blob_details: Optional[Union[JSON, IO]] = None, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Restores all key materials using the SAS token pointing to a previously stored Azure Blob
        storage backup folder.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
         successful full backup was stored. Is either a JSON type or a IO type. Default value is None.
        :type restore_blob_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                restore_blob_details = {
                    "folderToRestore": "str",  # The Folder name of the blob where the previous
                      successful full backup was stored. Required.
                    "sasTokenParameters": {
                        "storageResourceUri": "str",  # Azure Blob storage container Uri.
                          Required.
                        "token": "str",  # Optional. The SAS token pointing to an Azure Blob
                          storage container.
                        "useManagedIdentity": False  # Optional. Default value is False.
                          Indicates which authentication method should be used. If set to true, Managed
                          HSM will use the configured user-assigned managed identity to authenticate
                          with Azure Storage. Otherwise, a SAS token has to be specified.
                    }
                }

                # response body for status code(s): 202
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the restore
                      operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "jobId": "str",  # Optional. Identifier for the restore operation.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time of the
                      restore operation.
                    "status": "str",  # Optional. Status of the restore operation.
                    "statusDetails": "str"  # Optional. The status details of restore operation.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._full_restore_operation_initial(
                vault_base_url=vault_base_url,
                restore_blob_details=restore_blob_details,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod,
                ARMPolling(
                    lro_delay,
                    lro_options={"final-state-via": "azure-async-operation"},
                    path_format_arguments=path_format_arguments,
                    **kwargs
                ),
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def restore_status(self, vault_base_url: str, job_id: str, **kwargs: Any) -> JSON:
        """Returns the status of restore operation.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param job_id: The Job Id returned part of the restore operation. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the restore
                      operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "jobId": "str",  # Optional. Identifier for the restore operation.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time of the
                      restore operation.
                    "status": "str",  # Optional. Status of the restore operation.
                    "statusDetails": "str"  # Optional. The status details of restore operation.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_restore_status_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _selective_key_restore_operation_initial(
        self, vault_base_url: str, key_name: str, restore_blob_details: Optional[Union[JSON, IO]] = None, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(restore_blob_details, (IOBase, bytes)):
            _content = restore_blob_details
        else:
            if restore_blob_details is not None:
                _json = restore_blob_details
            else:
                _json = None

        request = build_key_vault_selective_key_restore_operation_request(
            key_name=key_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
        response_headers["Azure-AsyncOperation"] = self._deserialize(
            "str", response.headers.get("Azure-AsyncOperation")
        )

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)

    @overload
    def begin_selective_key_restore_operation(
        self,
        vault_base_url: str,
        key_name: str,
        restore_blob_details: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Restores all key versions of a given key using user supplied SAS token pointing to a previously
        stored Azure Blob storage backup folder.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key to be restored from the user supplied backup. Required.
        :type key_name: str
        :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
         successful full backup was stored. Default value is None.
        :type restore_blob_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                restore_blob_details = {
                    "folder": "str",  # The Folder name of the blob where the previous successful
                      full backup was stored. Required.
                    "sasTokenParameters": {
                        "storageResourceUri": "str",  # Azure Blob storage container Uri.
                          Required.
                        "token": "str",  # Optional. The SAS token pointing to an Azure Blob
                          storage container.
                        "useManagedIdentity": False  # Optional. Default value is False.
                          Indicates which authentication method should be used. If set to true, Managed
                          HSM will use the configured user-assigned managed identity to authenticate
                          with Azure Storage. Otherwise, a SAS token has to be specified.
                    }
                }

                # response body for status code(s): 202
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the restore
                      operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "jobId": "str",  # Optional. Identifier for the selective key restore
                      operation.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time of the
                      restore operation.
                    "status": "str",  # Optional. Status of the restore operation.
                    "statusDetails": "str"  # Optional. The status details of restore operation.
                }
        """

    @overload
    def begin_selective_key_restore_operation(
        self,
        vault_base_url: str,
        key_name: str,
        restore_blob_details: Optional[IO] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Restores all key versions of a given key using user supplied SAS token pointing to a previously
        stored Azure Blob storage backup folder.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key to be restored from the user supplied backup. Required.
        :type key_name: str
        :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
         successful full backup was stored. Default value is None.
        :type restore_blob_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the restore
                      operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "jobId": "str",  # Optional. Identifier for the selective key restore
                      operation.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time of the
                      restore operation.
                    "status": "str",  # Optional. Status of the restore operation.
                    "statusDetails": "str"  # Optional. The status details of restore operation.
                }
        """

    @distributed_trace
    def begin_selective_key_restore_operation(
        self, vault_base_url: str, key_name: str, restore_blob_details: Optional[Union[JSON, IO]] = None, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Restores all key versions of a given key using user supplied SAS token pointing to a previously
        stored Azure Blob storage backup folder.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key to be restored from the user supplied backup. Required.
        :type key_name: str
        :param restore_blob_details: The Azure blob SAS token pointing to a folder where the previous
         successful full backup was stored. Is either a JSON type or a IO type. Default value is None.
        :type restore_blob_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                restore_blob_details = {
                    "folder": "str",  # The Folder name of the blob where the previous successful
                      full backup was stored. Required.
                    "sasTokenParameters": {
                        "storageResourceUri": "str",  # Azure Blob storage container Uri.
                          Required.
                        "token": "str",  # Optional. The SAS token pointing to an Azure Blob
                          storage container.
                        "useManagedIdentity": False  # Optional. Default value is False.
                          Indicates which authentication method should be used. If set to true, Managed
                          HSM will use the configured user-assigned managed identity to authenticate
                          with Azure Storage. Otherwise, a SAS token has to be specified.
                    }
                }

                # response body for status code(s): 202
                response == {
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the restore
                      operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "jobId": "str",  # Optional. Identifier for the selective key restore
                      operation.
                    "startTime": "2020-02-20 00:00:00",  # Optional. The start time of the
                      restore operation.
                    "status": "str",  # Optional. Status of the restore operation.
                    "statusDetails": "str"  # Optional. The status details of restore operation.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._selective_key_restore_operation_initial(
                vault_base_url=vault_base_url,
                key_name=key_name,
                restore_blob_details=restore_blob_details,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod,
                ARMPolling(
                    lro_delay,
                    lro_options={"final-state-via": "azure-async-operation"},
                    path_format_arguments=path_format_arguments,
                    **kwargs
                ),
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_certificates(
        self,
        vault_base_url: str,
        *,
        maxresults: Optional[int] = None,
        include_pending: Optional[bool] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """List certificates in a specified key vault.

        The GetCertificates operation returns the set of certificates resources in the specified key
        vault. This operation requires the certificates/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :keyword include_pending: Specifies whether to include certificates which are not completely
         provisioned. Default value is None.
        :paramtype include_pending: bool
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. Certificate identifier.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_certificates_request(
                    maxresults=maxresults,
                    include_pending=include_pending,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def delete_certificate(self, vault_base_url: str, certificate_name: str, **kwargs: Any) -> JSON:
        """Deletes a certificate from a specified key vault.

        Deletes all versions of a certificate object along with its associated policy. Delete
        certificate cannot be used to remove individual versions of a certificate object. This
        operation requires the certificates/delete permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      certificate was deleted, in UTC.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted certificate.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      certificate is scheduled to be purged, in UTC.
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_delete_certificate_request(
            certificate_name=certificate_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def set_certificate_contacts(
        self, vault_base_url: str, contacts: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Sets the certificate contacts for the specified key vault.

        Sets the certificate contacts for the specified key vault. This operation requires the
        certificates/managecontacts permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param contacts: The contacts for the key vault certificate. Required.
        :type contacts: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                contacts = {
                    "contacts": [
                        {
                            "email": "str",  # Optional. Email address.
                            "name": "str",  # Optional. Name.
                            "phone": "str"  # Optional. Phone number.
                        }
                    ],
                    "id": "str"  # Optional. Identifier for the contacts collection.
                }

                # response body for status code(s): 200
                response == {
                    "contacts": [
                        {
                            "email": "str",  # Optional. Email address.
                            "name": "str",  # Optional. Name.
                            "phone": "str"  # Optional. Phone number.
                        }
                    ],
                    "id": "str"  # Optional. Identifier for the contacts collection.
                }
        """

    @overload
    def set_certificate_contacts(
        self, vault_base_url: str, contacts: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Sets the certificate contacts for the specified key vault.

        Sets the certificate contacts for the specified key vault. This operation requires the
        certificates/managecontacts permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param contacts: The contacts for the key vault certificate. Required.
        :type contacts: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "contacts": [
                        {
                            "email": "str",  # Optional. Email address.
                            "name": "str",  # Optional. Name.
                            "phone": "str"  # Optional. Phone number.
                        }
                    ],
                    "id": "str"  # Optional. Identifier for the contacts collection.
                }
        """

    @distributed_trace
    def set_certificate_contacts(self, vault_base_url: str, contacts: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Sets the certificate contacts for the specified key vault.

        Sets the certificate contacts for the specified key vault. This operation requires the
        certificates/managecontacts permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param contacts: The contacts for the key vault certificate. Is either a JSON type or a IO
         type. Required.
        :type contacts: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                contacts = {
                    "contacts": [
                        {
                            "email": "str",  # Optional. Email address.
                            "name": "str",  # Optional. Name.
                            "phone": "str"  # Optional. Phone number.
                        }
                    ],
                    "id": "str"  # Optional. Identifier for the contacts collection.
                }

                # response body for status code(s): 200
                response == {
                    "contacts": [
                        {
                            "email": "str",  # Optional. Email address.
                            "name": "str",  # Optional. Name.
                            "phone": "str"  # Optional. Phone number.
                        }
                    ],
                    "id": "str"  # Optional. Identifier for the contacts collection.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(contacts, (IOBase, bytes)):
            _content = contacts
        else:
            _json = contacts

        request = build_key_vault_set_certificate_contacts_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_certificate_contacts(self, vault_base_url: str, **kwargs: Any) -> JSON:
        """Lists the certificate contacts for a specified key vault.

        The GetCertificateContacts operation returns the set of certificate contact resources in the
        specified key vault. This operation requires the certificates/managecontacts permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "contacts": [
                        {
                            "email": "str",  # Optional. Email address.
                            "name": "str",  # Optional. Name.
                            "phone": "str"  # Optional. Phone number.
                        }
                    ],
                    "id": "str"  # Optional. Identifier for the contacts collection.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_certificate_contacts_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete_certificate_contacts(self, vault_base_url: str, **kwargs: Any) -> JSON:
        """Deletes the certificate contacts for a specified key vault.

        Deletes the certificate contacts for a specified key vault certificate. This operation requires
        the certificates/managecontacts permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "contacts": [
                        {
                            "email": "str",  # Optional. Email address.
                            "name": "str",  # Optional. Name.
                            "phone": "str"  # Optional. Phone number.
                        }
                    ],
                    "id": "str"  # Optional. Identifier for the contacts collection.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_delete_certificate_contacts_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_certificate_issuers(
        self, vault_base_url: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """List certificate issuers for a specified key vault.

        The GetCertificateIssuers operation returns the set of certificate issuer resources in the
        specified key vault. This operation requires the certificates/manageissuers/getissuers
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Certificate Identifier.
                    "provider": "str"  # Optional. The issuer provider.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_certificate_issuers_request(
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def set_certificate_issuer(
        self,
        vault_base_url: str,
        issuer_name: str,
        parameter: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets the specified certificate issuer.

        The SetCertificateIssuer operation adds or updates the specified certificate issuer. This
        operation requires the certificates/setissuers permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param issuer_name: The name of the issuer. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type issuer_name: str
        :param parameter: Certificate issuer set parameter. Required.
        :type parameter: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameter = {
                    "provider": "str",  # The issuer provider. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "id": "str",  # Optional. Identifier for the issuer object.
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    },
                    "provider": "str"  # Optional. The issuer provider.
                }
        """

    @overload
    def set_certificate_issuer(
        self,
        vault_base_url: str,
        issuer_name: str,
        parameter: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets the specified certificate issuer.

        The SetCertificateIssuer operation adds or updates the specified certificate issuer. This
        operation requires the certificates/setissuers permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param issuer_name: The name of the issuer. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type issuer_name: str
        :param parameter: Certificate issuer set parameter. Required.
        :type parameter: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "id": "str",  # Optional. Identifier for the issuer object.
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    },
                    "provider": "str"  # Optional. The issuer provider.
                }
        """

    @distributed_trace
    def set_certificate_issuer(
        self, vault_base_url: str, issuer_name: str, parameter: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Sets the specified certificate issuer.

        The SetCertificateIssuer operation adds or updates the specified certificate issuer. This
        operation requires the certificates/setissuers permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param issuer_name: The name of the issuer. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type issuer_name: str
        :param parameter: Certificate issuer set parameter. Is either a JSON type or a IO type.
         Required.
        :type parameter: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameter = {
                    "provider": "str",  # The issuer provider. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "id": "str",  # Optional. Identifier for the issuer object.
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    },
                    "provider": "str"  # Optional. The issuer provider.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameter, (IOBase, bytes)):
            _content = parameter
        else:
            _json = parameter

        request = build_key_vault_set_certificate_issuer_request(
            issuer_name=issuer_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update_certificate_issuer(
        self,
        vault_base_url: str,
        issuer_name: str,
        parameter: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the specified certificate issuer.

        The UpdateCertificateIssuer operation performs an update on the specified certificate issuer
        entity. This operation requires the certificates/setissuers permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param issuer_name: The name of the issuer. Required.
        :type issuer_name: str
        :param parameter: Certificate issuer update parameter. Required.
        :type parameter: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameter = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    },
                    "provider": "str"  # Optional. The issuer provider.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "id": "str",  # Optional. Identifier for the issuer object.
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    },
                    "provider": "str"  # Optional. The issuer provider.
                }
        """

    @overload
    def update_certificate_issuer(
        self,
        vault_base_url: str,
        issuer_name: str,
        parameter: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the specified certificate issuer.

        The UpdateCertificateIssuer operation performs an update on the specified certificate issuer
        entity. This operation requires the certificates/setissuers permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param issuer_name: The name of the issuer. Required.
        :type issuer_name: str
        :param parameter: Certificate issuer update parameter. Required.
        :type parameter: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "id": "str",  # Optional. Identifier for the issuer object.
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    },
                    "provider": "str"  # Optional. The issuer provider.
                }
        """

    @distributed_trace
    def update_certificate_issuer(
        self, vault_base_url: str, issuer_name: str, parameter: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates the specified certificate issuer.

        The UpdateCertificateIssuer operation performs an update on the specified certificate issuer
        entity. This operation requires the certificates/setissuers permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param issuer_name: The name of the issuer. Required.
        :type issuer_name: str
        :param parameter: Certificate issuer update parameter. Is either a JSON type or a IO type.
         Required.
        :type parameter: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameter = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    },
                    "provider": "str"  # Optional. The issuer provider.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "id": "str",  # Optional. Identifier for the issuer object.
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    },
                    "provider": "str"  # Optional. The issuer provider.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameter, (IOBase, bytes)):
            _content = parameter
        else:
            _json = parameter

        request = build_key_vault_update_certificate_issuer_request(
            issuer_name=issuer_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_certificate_issuer(self, vault_base_url: str, issuer_name: str, **kwargs: Any) -> JSON:
        """Lists the specified certificate issuer.

        The GetCertificateIssuer operation returns the specified certificate issuer resources in the
        specified key vault. This operation requires the certificates/manageissuers/getissuers
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param issuer_name: The name of the issuer. Required.
        :type issuer_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "id": "str",  # Optional. Identifier for the issuer object.
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    },
                    "provider": "str"  # Optional. The issuer provider.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_certificate_issuer_request(
            issuer_name=issuer_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete_certificate_issuer(self, vault_base_url: str, issuer_name: str, **kwargs: Any) -> JSON:
        """Deletes the specified certificate issuer.

        The DeleteCertificateIssuer operation permanently removes the specified certificate issuer from
        the vault. This operation requires the certificates/manageissuers/deleteissuers permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param issuer_name: The name of the issuer. Required.
        :type issuer_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the issuer is
                          enabled.
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "credentials": {
                        "account_id": "str",  # Optional. The user name/account name/account
                          id.
                        "pwd": "str"  # Optional. The password/secret/account key.
                    },
                    "id": "str",  # Optional. Identifier for the issuer object.
                    "org_details": {
                        "admin_details": [
                            {
                                "email": "str",  # Optional. Email address.
                                "first_name": "str",  # Optional. First name.
                                "last_name": "str",  # Optional. Last name.
                                "phone": "str"  # Optional. Phone number.
                            }
                        ],
                        "id": "str"  # Optional. Id of the organization.
                    },
                    "provider": "str"  # Optional. The issuer provider.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_delete_certificate_issuer_request(
            issuer_name=issuer_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_certificate(
        self,
        vault_base_url: str,
        certificate_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new certificate.

        If this is the first version, the certificate resource is created. This operation requires the
        certificates/create permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. The value you provide may be copied
         globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type certificate_name: str
        :param parameters: The parameters to create a certificate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 202
                response == {
                    "cancellation_requested": bool,  # Optional. Indicates if cancellation was
                      requested on the certificate operation.
                    "csr": bytes("bytes", encoding="utf-8"),  # Optional. The certificate signing
                      request (CSR) that is being used in the certificate operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "request_id": "str",  # Optional. Identifier for the certificate operation.
                    "status": "str",  # Optional. Status of the certificate operation.
                    "status_details": "str",  # Optional. The status details of the certificate
                      operation.
                    "target": "str"  # Optional. Location which contains the result of the
                      certificate operation.
                }
        """

    @overload
    def create_certificate(
        self,
        vault_base_url: str,
        certificate_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new certificate.

        If this is the first version, the certificate resource is created. This operation requires the
        certificates/create permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. The value you provide may be copied
         globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type certificate_name: str
        :param parameters: The parameters to create a certificate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "cancellation_requested": bool,  # Optional. Indicates if cancellation was
                      requested on the certificate operation.
                    "csr": bytes("bytes", encoding="utf-8"),  # Optional. The certificate signing
                      request (CSR) that is being used in the certificate operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "request_id": "str",  # Optional. Identifier for the certificate operation.
                    "status": "str",  # Optional. Status of the certificate operation.
                    "status_details": "str",  # Optional. The status details of the certificate
                      operation.
                    "target": "str"  # Optional. Location which contains the result of the
                      certificate operation.
                }
        """

    @distributed_trace
    def create_certificate(
        self, vault_base_url: str, certificate_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates a new certificate.

        If this is the first version, the certificate resource is created. This operation requires the
        certificates/create permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. The value you provide may be copied
         globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type certificate_name: str
        :param parameters: The parameters to create a certificate. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 202
                response == {
                    "cancellation_requested": bool,  # Optional. Indicates if cancellation was
                      requested on the certificate operation.
                    "csr": bytes("bytes", encoding="utf-8"),  # Optional. The certificate signing
                      request (CSR) that is being used in the certificate operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "request_id": "str",  # Optional. Identifier for the certificate operation.
                    "status": "str",  # Optional. Status of the certificate operation.
                    "status_details": "str",  # Optional. The status details of the certificate
                      operation.
                    "target": "str"  # Optional. Location which contains the result of the
                      certificate operation.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_create_certificate_request(
            certificate_name=certificate_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def import_certificate(
        self,
        vault_base_url: str,
        certificate_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Imports a certificate into a specified key vault.

        Imports an existing valid certificate, containing a private key, into Azure Key Vault. This
        operation requires the certificates/import permission. The certificate to be imported can be in
        either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key
        as well as x509 certificates. Key Vault will only accept a key in PKCS#8 format.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. The value you provide may be copied
         globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type certificate_name: str
        :param parameters: The parameters to import the certificate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": "str",  # Base64 encoded representation of the certificate object to
                      import. This certificate needs to contain the private key. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "pwd": "str",  # Optional. If the private key in base64EncodedCertificate is
                      encrypted, the password used for encryption.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """

    @overload
    def import_certificate(
        self,
        vault_base_url: str,
        certificate_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Imports a certificate into a specified key vault.

        Imports an existing valid certificate, containing a private key, into Azure Key Vault. This
        operation requires the certificates/import permission. The certificate to be imported can be in
        either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key
        as well as x509 certificates. Key Vault will only accept a key in PKCS#8 format.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. The value you provide may be copied
         globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type certificate_name: str
        :param parameters: The parameters to import the certificate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """

    @distributed_trace
    def import_certificate(
        self, vault_base_url: str, certificate_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Imports a certificate into a specified key vault.

        Imports an existing valid certificate, containing a private key, into Azure Key Vault. This
        operation requires the certificates/import permission. The certificate to be imported can be in
        either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key
        as well as x509 certificates. Key Vault will only accept a key in PKCS#8 format.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. The value you provide may be copied
         globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type certificate_name: str
        :param parameters: The parameters to import the certificate. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": "str",  # Base64 encoded representation of the certificate object to
                      import. This certificate needs to contain the private key. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "pwd": "str",  # Optional. If the private key in base64EncodedCertificate is
                      encrypted, the password used for encryption.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_import_certificate_request(
            certificate_name=certificate_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_certificate_versions(
        self, vault_base_url: str, certificate_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """List the versions of a certificate.

        The GetCertificateVersions operation returns the versions of a certificate in the specified key
        vault. This operation requires the certificates/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. Certificate identifier.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_certificate_versions_request(
                    certificate_name=certificate_name,
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_certificate_policy(self, vault_base_url: str, certificate_name: str, **kwargs: Any) -> JSON:
        """Lists the policy for a certificate.

        The GetCertificatePolicy operation returns the specified certificate policy resources in the
        specified key vault. This operation requires the certificates/get permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate in a given key vault. Required.
        :type certificate_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "key_props": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "key_size": 0,  # Optional. The key size in bits. For example: 2048,
                          3072, or 4096 for RSA.
                        "kty": "str",  # Optional. The type of key pair to be used for the
                          certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and
                          "oct-HSM".
                        "reuse_key": bool  # Optional. Indicates if the same key pair will be
                          used on certificate renewal.
                    },
                    "lifetime_actions": [
                        {
                            "action": {
                                "action_type": "str"  # Optional. The type of the
                                  action. Known values are: "EmailContacts", "AutoRenew", "Rotate", and
                                  "Notify".
                            },
                            "trigger": {
                                "days_before_expiry": 0,  # Optional. Days before
                                  expiry to attempt renewal. Value should be between 1 and
                                  validity_in_months multiplied by 27. If validity_in_months is 36,
                                  then value should be between 1 and 972 (36 * 27).
                                "lifetime_percentage": 0  # Optional. Percentage of
                                  lifetime at which to trigger. Value should be between 1 and 99.
                            }
                        }
                    ],
                    "secret_props": {
                        "contentType": "str"  # Optional. The media type (MIME type).
                    },
                    "x509_props": {
                        "ekus": [
                            "str"  # Optional. The enhanced key usage.
                        ],
                        "key_usage": [
                            "str"  # Optional. Defines how the certificate's key may be
                              used.
                        ],
                        "sans": {
                            "dns_names": [
                                "str"  # Optional. Domain names.
                            ],
                            "emails": [
                                "str"  # Optional. Email addresses.
                            ],
                            "upns": [
                                "str"  # Optional. User principal names.
                            ]
                        },
                        "subject": "str",  # Optional. The subject name. Should be a valid
                          X509 distinguished Name.
                        "validity_months": 0  # Optional. The duration that the certificate
                          is valid in months.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_certificate_policy_request(
            certificate_name=certificate_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update_certificate_policy(
        self,
        vault_base_url: str,
        certificate_name: str,
        certificate_policy: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the policy for a certificate.

        Set specified members in the certificate policy. Leave others as null. This operation requires
        the certificates/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate in the given vault. Required.
        :type certificate_name: str
        :param certificate_policy: The policy for the certificate. Required.
        :type certificate_policy: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                certificate_policy = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "key_props": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "key_size": 0,  # Optional. The key size in bits. For example: 2048,
                          3072, or 4096 for RSA.
                        "kty": "str",  # Optional. The type of key pair to be used for the
                          certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and
                          "oct-HSM".
                        "reuse_key": bool  # Optional. Indicates if the same key pair will be
                          used on certificate renewal.
                    },
                    "lifetime_actions": [
                        {
                            "action": {
                                "action_type": "str"  # Optional. The type of the
                                  action. Known values are: "EmailContacts", "AutoRenew", "Rotate", and
                                  "Notify".
                            },
                            "trigger": {
                                "days_before_expiry": 0,  # Optional. Days before
                                  expiry to attempt renewal. Value should be between 1 and
                                  validity_in_months multiplied by 27. If validity_in_months is 36,
                                  then value should be between 1 and 972 (36 * 27).
                                "lifetime_percentage": 0  # Optional. Percentage of
                                  lifetime at which to trigger. Value should be between 1 and 99.
                            }
                        }
                    ],
                    "secret_props": {
                        "contentType": "str"  # Optional. The media type (MIME type).
                    },
                    "x509_props": {
                        "ekus": [
                            "str"  # Optional. The enhanced key usage.
                        ],
                        "key_usage": [
                            "str"  # Optional. Defines how the certificate's key may be
                              used.
                        ],
                        "sans": {
                            "dns_names": [
                                "str"  # Optional. Domain names.
                            ],
                            "emails": [
                                "str"  # Optional. Email addresses.
                            ],
                            "upns": [
                                "str"  # Optional. User principal names.
                            ]
                        },
                        "subject": "str",  # Optional. The subject name. Should be a valid
                          X509 distinguished Name.
                        "validity_months": 0  # Optional. The duration that the certificate
                          is valid in months.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "key_props": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "key_size": 0,  # Optional. The key size in bits. For example: 2048,
                          3072, or 4096 for RSA.
                        "kty": "str",  # Optional. The type of key pair to be used for the
                          certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and
                          "oct-HSM".
                        "reuse_key": bool  # Optional. Indicates if the same key pair will be
                          used on certificate renewal.
                    },
                    "lifetime_actions": [
                        {
                            "action": {
                                "action_type": "str"  # Optional. The type of the
                                  action. Known values are: "EmailContacts", "AutoRenew", "Rotate", and
                                  "Notify".
                            },
                            "trigger": {
                                "days_before_expiry": 0,  # Optional. Days before
                                  expiry to attempt renewal. Value should be between 1 and
                                  validity_in_months multiplied by 27. If validity_in_months is 36,
                                  then value should be between 1 and 972 (36 * 27).
                                "lifetime_percentage": 0  # Optional. Percentage of
                                  lifetime at which to trigger. Value should be between 1 and 99.
                            }
                        }
                    ],
                    "secret_props": {
                        "contentType": "str"  # Optional. The media type (MIME type).
                    },
                    "x509_props": {
                        "ekus": [
                            "str"  # Optional. The enhanced key usage.
                        ],
                        "key_usage": [
                            "str"  # Optional. Defines how the certificate's key may be
                              used.
                        ],
                        "sans": {
                            "dns_names": [
                                "str"  # Optional. Domain names.
                            ],
                            "emails": [
                                "str"  # Optional. Email addresses.
                            ],
                            "upns": [
                                "str"  # Optional. User principal names.
                            ]
                        },
                        "subject": "str",  # Optional. The subject name. Should be a valid
                          X509 distinguished Name.
                        "validity_months": 0  # Optional. The duration that the certificate
                          is valid in months.
                    }
                }
        """

    @overload
    def update_certificate_policy(
        self,
        vault_base_url: str,
        certificate_name: str,
        certificate_policy: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the policy for a certificate.

        Set specified members in the certificate policy. Leave others as null. This operation requires
        the certificates/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate in the given vault. Required.
        :type certificate_name: str
        :param certificate_policy: The policy for the certificate. Required.
        :type certificate_policy: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "key_props": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "key_size": 0,  # Optional. The key size in bits. For example: 2048,
                          3072, or 4096 for RSA.
                        "kty": "str",  # Optional. The type of key pair to be used for the
                          certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and
                          "oct-HSM".
                        "reuse_key": bool  # Optional. Indicates if the same key pair will be
                          used on certificate renewal.
                    },
                    "lifetime_actions": [
                        {
                            "action": {
                                "action_type": "str"  # Optional. The type of the
                                  action. Known values are: "EmailContacts", "AutoRenew", "Rotate", and
                                  "Notify".
                            },
                            "trigger": {
                                "days_before_expiry": 0,  # Optional. Days before
                                  expiry to attempt renewal. Value should be between 1 and
                                  validity_in_months multiplied by 27. If validity_in_months is 36,
                                  then value should be between 1 and 972 (36 * 27).
                                "lifetime_percentage": 0  # Optional. Percentage of
                                  lifetime at which to trigger. Value should be between 1 and 99.
                            }
                        }
                    ],
                    "secret_props": {
                        "contentType": "str"  # Optional. The media type (MIME type).
                    },
                    "x509_props": {
                        "ekus": [
                            "str"  # Optional. The enhanced key usage.
                        ],
                        "key_usage": [
                            "str"  # Optional. Defines how the certificate's key may be
                              used.
                        ],
                        "sans": {
                            "dns_names": [
                                "str"  # Optional. Domain names.
                            ],
                            "emails": [
                                "str"  # Optional. Email addresses.
                            ],
                            "upns": [
                                "str"  # Optional. User principal names.
                            ]
                        },
                        "subject": "str",  # Optional. The subject name. Should be a valid
                          X509 distinguished Name.
                        "validity_months": 0  # Optional. The duration that the certificate
                          is valid in months.
                    }
                }
        """

    @distributed_trace
    def update_certificate_policy(
        self, vault_base_url: str, certificate_name: str, certificate_policy: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates the policy for a certificate.

        Set specified members in the certificate policy. Leave others as null. This operation requires
        the certificates/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate in the given vault. Required.
        :type certificate_name: str
        :param certificate_policy: The policy for the certificate. Is either a JSON type or a IO type.
         Required.
        :type certificate_policy: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                certificate_policy = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "key_props": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "key_size": 0,  # Optional. The key size in bits. For example: 2048,
                          3072, or 4096 for RSA.
                        "kty": "str",  # Optional. The type of key pair to be used for the
                          certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and
                          "oct-HSM".
                        "reuse_key": bool  # Optional. Indicates if the same key pair will be
                          used on certificate renewal.
                    },
                    "lifetime_actions": [
                        {
                            "action": {
                                "action_type": "str"  # Optional. The type of the
                                  action. Known values are: "EmailContacts", "AutoRenew", "Rotate", and
                                  "Notify".
                            },
                            "trigger": {
                                "days_before_expiry": 0,  # Optional. Days before
                                  expiry to attempt renewal. Value should be between 1 and
                                  validity_in_months multiplied by 27. If validity_in_months is 36,
                                  then value should be between 1 and 972 (36 * 27).
                                "lifetime_percentage": 0  # Optional. Percentage of
                                  lifetime at which to trigger. Value should be between 1 and 99.
                            }
                        }
                    ],
                    "secret_props": {
                        "contentType": "str"  # Optional. The media type (MIME type).
                    },
                    "x509_props": {
                        "ekus": [
                            "str"  # Optional. The enhanced key usage.
                        ],
                        "key_usage": [
                            "str"  # Optional. Defines how the certificate's key may be
                              used.
                        ],
                        "sans": {
                            "dns_names": [
                                "str"  # Optional. Domain names.
                            ],
                            "emails": [
                                "str"  # Optional. Email addresses.
                            ],
                            "upns": [
                                "str"  # Optional. User principal names.
                            ]
                        },
                        "subject": "str",  # Optional. The subject name. Should be a valid
                          X509 distinguished Name.
                        "validity_months": 0  # Optional. The duration that the certificate
                          is valid in months.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "key_props": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "key_size": 0,  # Optional. The key size in bits. For example: 2048,
                          3072, or 4096 for RSA.
                        "kty": "str",  # Optional. The type of key pair to be used for the
                          certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and
                          "oct-HSM".
                        "reuse_key": bool  # Optional. Indicates if the same key pair will be
                          used on certificate renewal.
                    },
                    "lifetime_actions": [
                        {
                            "action": {
                                "action_type": "str"  # Optional. The type of the
                                  action. Known values are: "EmailContacts", "AutoRenew", "Rotate", and
                                  "Notify".
                            },
                            "trigger": {
                                "days_before_expiry": 0,  # Optional. Days before
                                  expiry to attempt renewal. Value should be between 1 and
                                  validity_in_months multiplied by 27. If validity_in_months is 36,
                                  then value should be between 1 and 972 (36 * 27).
                                "lifetime_percentage": 0  # Optional. Percentage of
                                  lifetime at which to trigger. Value should be between 1 and 99.
                            }
                        }
                    ],
                    "secret_props": {
                        "contentType": "str"  # Optional. The media type (MIME type).
                    },
                    "x509_props": {
                        "ekus": [
                            "str"  # Optional. The enhanced key usage.
                        ],
                        "key_usage": [
                            "str"  # Optional. Defines how the certificate's key may be
                              used.
                        ],
                        "sans": {
                            "dns_names": [
                                "str"  # Optional. Domain names.
                            ],
                            "emails": [
                                "str"  # Optional. Email addresses.
                            ],
                            "upns": [
                                "str"  # Optional. User principal names.
                            ]
                        },
                        "subject": "str",  # Optional. The subject name. Should be a valid
                          X509 distinguished Name.
                        "validity_months": 0  # Optional. The duration that the certificate
                          is valid in months.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(certificate_policy, (IOBase, bytes)):
            _content = certificate_policy
        else:
            _json = certificate_policy

        request = build_key_vault_update_certificate_policy_request(
            certificate_name=certificate_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update_certificate(
        self,
        vault_base_url: str,
        certificate_name: str,
        certificate_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the specified attributes associated with the given certificate.

        The UpdateCertificate operation applies the specified update on the given certificate; the only
        elements updated are the certificate's attributes. This operation requires the
        certificates/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate in the given key vault. Required.
        :type certificate_name: str
        :param certificate_version: The version of the certificate. Required.
        :type certificate_version: str
        :param parameters: The parameters for certificate update. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """

    @overload
    def update_certificate(
        self,
        vault_base_url: str,
        certificate_name: str,
        certificate_version: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the specified attributes associated with the given certificate.

        The UpdateCertificate operation applies the specified update on the given certificate; the only
        elements updated are the certificate's attributes. This operation requires the
        certificates/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate in the given key vault. Required.
        :type certificate_name: str
        :param certificate_version: The version of the certificate. Required.
        :type certificate_version: str
        :param parameters: The parameters for certificate update. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """

    @distributed_trace
    def update_certificate(
        self,
        vault_base_url: str,
        certificate_name: str,
        certificate_version: str,
        parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Updates the specified attributes associated with the given certificate.

        The UpdateCertificate operation applies the specified update on the given certificate; the only
        elements updated are the certificate's attributes. This operation requires the
        certificates/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate in the given key vault. Required.
        :type certificate_name: str
        :param certificate_version: The version of the certificate. Required.
        :type certificate_version: str
        :param parameters: The parameters for certificate update. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_update_certificate_request(
            certificate_name=certificate_name,
            certificate_version=certificate_version,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_certificate(
        self, vault_base_url: str, certificate_name: str, certificate_version: str, **kwargs: Any
    ) -> JSON:
        """Gets information about a certificate.

        Gets information about a specific certificate. This operation requires the certificates/get
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate in the given vault. Required.
        :type certificate_name: str
        :param certificate_version: The version of the certificate. This URI fragment is optional. If
         not specified, the latest version of the certificate is returned. Required.
        :type certificate_version: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_certificate_request(
            certificate_name=certificate_name,
            certificate_version=certificate_version,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update_certificate_operation(
        self,
        vault_base_url: str,
        certificate_name: str,
        certificate_operation: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates a certificate operation.

        Updates a certificate creation operation that is already in progress. This operation requires
        the certificates/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :param certificate_operation: The certificate operation response. Required.
        :type certificate_operation: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                certificate_operation = {
                    "cancellation_requested": bool  # Indicates if cancellation was requested on
                      the certificate operation. Required.
                }

                # response body for status code(s): 200
                response == {
                    "cancellation_requested": bool,  # Optional. Indicates if cancellation was
                      requested on the certificate operation.
                    "csr": bytes("bytes", encoding="utf-8"),  # Optional. The certificate signing
                      request (CSR) that is being used in the certificate operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "request_id": "str",  # Optional. Identifier for the certificate operation.
                    "status": "str",  # Optional. Status of the certificate operation.
                    "status_details": "str",  # Optional. The status details of the certificate
                      operation.
                    "target": "str"  # Optional. Location which contains the result of the
                      certificate operation.
                }
        """

    @overload
    def update_certificate_operation(
        self,
        vault_base_url: str,
        certificate_name: str,
        certificate_operation: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates a certificate operation.

        Updates a certificate creation operation that is already in progress. This operation requires
        the certificates/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :param certificate_operation: The certificate operation response. Required.
        :type certificate_operation: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "cancellation_requested": bool,  # Optional. Indicates if cancellation was
                      requested on the certificate operation.
                    "csr": bytes("bytes", encoding="utf-8"),  # Optional. The certificate signing
                      request (CSR) that is being used in the certificate operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "request_id": "str",  # Optional. Identifier for the certificate operation.
                    "status": "str",  # Optional. Status of the certificate operation.
                    "status_details": "str",  # Optional. The status details of the certificate
                      operation.
                    "target": "str"  # Optional. Location which contains the result of the
                      certificate operation.
                }
        """

    @distributed_trace
    def update_certificate_operation(
        self, vault_base_url: str, certificate_name: str, certificate_operation: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates a certificate operation.

        Updates a certificate creation operation that is already in progress. This operation requires
        the certificates/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :param certificate_operation: The certificate operation response. Is either a JSON type or a IO
         type. Required.
        :type certificate_operation: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                certificate_operation = {
                    "cancellation_requested": bool  # Indicates if cancellation was requested on
                      the certificate operation. Required.
                }

                # response body for status code(s): 200
                response == {
                    "cancellation_requested": bool,  # Optional. Indicates if cancellation was
                      requested on the certificate operation.
                    "csr": bytes("bytes", encoding="utf-8"),  # Optional. The certificate signing
                      request (CSR) that is being used in the certificate operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "request_id": "str",  # Optional. Identifier for the certificate operation.
                    "status": "str",  # Optional. Status of the certificate operation.
                    "status_details": "str",  # Optional. The status details of the certificate
                      operation.
                    "target": "str"  # Optional. Location which contains the result of the
                      certificate operation.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(certificate_operation, (IOBase, bytes)):
            _content = certificate_operation
        else:
            _json = certificate_operation

        request = build_key_vault_update_certificate_operation_request(
            certificate_name=certificate_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_certificate_operation(self, vault_base_url: str, certificate_name: str, **kwargs: Any) -> JSON:
        """Gets the creation operation of a certificate.

        Gets the creation operation associated with a specified certificate. This operation requires
        the certificates/get permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "cancellation_requested": bool,  # Optional. Indicates if cancellation was
                      requested on the certificate operation.
                    "csr": bytes("bytes", encoding="utf-8"),  # Optional. The certificate signing
                      request (CSR) that is being used in the certificate operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "request_id": "str",  # Optional. Identifier for the certificate operation.
                    "status": "str",  # Optional. Status of the certificate operation.
                    "status_details": "str",  # Optional. The status details of the certificate
                      operation.
                    "target": "str"  # Optional. Location which contains the result of the
                      certificate operation.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_certificate_operation_request(
            certificate_name=certificate_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete_certificate_operation(self, vault_base_url: str, certificate_name: str, **kwargs: Any) -> JSON:
        """Deletes the creation operation for a specific certificate.

        Deletes the creation operation for a specified certificate that is in the process of being
        created. The certificate is no longer created. This operation requires the certificates/update
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "cancellation_requested": bool,  # Optional. Indicates if cancellation was
                      requested on the certificate operation.
                    "csr": bytes("bytes", encoding="utf-8"),  # Optional. The certificate signing
                      request (CSR) that is being used in the certificate operation.
                    "error": {
                        "code": "str",  # Optional. The error code.
                        "innererror": ...,
                        "message": "str"  # Optional. The error message.
                    },
                    "id": "str",  # Optional. The certificate id.
                    "issuer": {
                        "cert_transparency": bool,  # Optional. Indicates if the certificates
                          generated under this policy should be published to certificate transparency
                          logs.
                        "cty": "str",  # Optional. Certificate type as supported by the
                          provider (optional); for example 'OV-SSL', 'EV-SSL'.
                        "name": "str"  # Optional. Name of the referenced issuer object or
                          reserved names; for example, 'Self' or 'Unknown'.
                    },
                    "request_id": "str",  # Optional. Identifier for the certificate operation.
                    "status": "str",  # Optional. Status of the certificate operation.
                    "status_details": "str",  # Optional. The status details of the certificate
                      operation.
                    "target": "str"  # Optional. Location which contains the result of the
                      certificate operation.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_delete_certificate_operation_request(
            certificate_name=certificate_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def merge_certificate(
        self,
        vault_base_url: str,
        certificate_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Merges a certificate or a certificate chain with a key pair existing on the server.

        The MergeCertificate operation performs the merging of a certificate or certificate chain with
        a key pair currently available in the service. This operation requires the certificates/create
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :param parameters: The parameters to merge certificate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "x5c": [
                        bytes("bytes", encoding="utf-8")  # The certificate or the
                          certificate chain to merge. Required.
                    ],
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 201
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """

    @overload
    def merge_certificate(
        self,
        vault_base_url: str,
        certificate_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Merges a certificate or a certificate chain with a key pair existing on the server.

        The MergeCertificate operation performs the merging of a certificate or certificate chain with
        a key pair currently available in the service. This operation requires the certificates/create
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :param parameters: The parameters to merge certificate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """

    @distributed_trace
    def merge_certificate(
        self, vault_base_url: str, certificate_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Merges a certificate or a certificate chain with a key pair existing on the server.

        The MergeCertificate operation performs the merging of a certificate or certificate chain with
        a key pair currently available in the service. This operation requires the certificates/create
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :param parameters: The parameters to merge certificate. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "x5c": [
                        bytes("bytes", encoding="utf-8")  # The certificate or the
                          certificate chain to merge. Required.
                    ],
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 201
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_merge_certificate_request(
            certificate_name=certificate_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def backup_certificate(self, vault_base_url: str, certificate_name: str, **kwargs: Any) -> JSON:
        """Backs up the specified certificate.

        Requests that a backup of the specified certificate be downloaded to the client. All versions
        of the certificate will be downloaded. This operation requires the certificates/backup
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": bytes("bytes", encoding="utf-8")  # Optional. The backup blob
                      containing the backed up certificate.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_backup_certificate_request(
            certificate_name=certificate_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def restore_certificate(
        self, vault_base_url: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Restores a backed up certificate to a vault.

        Restores a backed up certificate, and all its versions, to a vault. This operation requires the
        certificates/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the certificate. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": bytes("bytes", encoding="utf-8")  # The backup blob associated with
                      a certificate bundle. Required.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """

    @overload
    def restore_certificate(
        self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Restores a backed up certificate to a vault.

        Restores a backed up certificate, and all its versions, to a vault. This operation requires the
        certificates/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the certificate. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """

    @distributed_trace
    def restore_certificate(self, vault_base_url: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Restores a backed up certificate to a vault.

        Restores a backed up certificate, and all its versions, to a vault. This operation requires the
        certificates/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the certificate. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": bytes("bytes", encoding="utf-8")  # The backup blob associated with
                      a certificate bundle. Required.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_restore_certificate_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_deleted_certificates(
        self,
        vault_base_url: str,
        *,
        maxresults: Optional[int] = None,
        include_pending: Optional[bool] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists the deleted certificates in the specified vault currently available for recovery.

        The GetDeletedCertificates operation retrieves the certificates in the current vault which are
        in a deleted state and ready for recovery or purging. This operation includes deletion-specific
        information. This operation requires the certificates/get/list permission. This operation can
        only be enabled on soft-delete enabled vaults.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :keyword include_pending: Specifies whether to include certificates which are not completely
         provisioned. Default value is None.
        :paramtype include_pending: bool
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      certificate was deleted, in UTC.
                    "id": "str",  # Optional. Certificate identifier.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted certificate.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      certificate is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_deleted_certificates_request(
                    maxresults=maxresults,
                    include_pending=include_pending,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deleted_certificate(self, vault_base_url: str, certificate_name: str, **kwargs: Any) -> JSON:
        """Retrieves information about the specified deleted certificate.

        The GetDeletedCertificate operation retrieves the deleted certificate information plus its
        attributes, such as retention interval, scheduled permanent deletion and the current deletion
        recovery level. This operation requires the certificates/get permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      certificate was deleted, in UTC.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted certificate.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      certificate is scheduled to be purged, in UTC.
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_deleted_certificate_request(
            certificate_name=certificate_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def purge_deleted_certificate(  # pylint: disable=inconsistent-return-statements
        self, vault_base_url: str, certificate_name: str, **kwargs: Any
    ) -> None:
        """Permanently deletes the specified deleted certificate.

        The PurgeDeletedCertificate operation performs an irreversible deletion of the specified
        certificate, without possibility for recovery. The operation is not available if the recovery
        level does not specify 'Purgeable'. This operation requires the certificate/purge permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the certificate. Required.
        :type certificate_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_key_vault_purge_deleted_certificate_request(
            certificate_name=certificate_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def recover_deleted_certificate(self, vault_base_url: str, certificate_name: str, **kwargs: Any) -> JSON:
        """Recovers the deleted certificate back to its current version under /certificates.

        The RecoverDeletedCertificate operation performs the reversal of the Delete operation. The
        operation is applicable in vaults enabled for soft-delete, and must be issued during the
        retention interval (available in the deleted certificate's attributes). This operation requires
        the certificates/recover permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param certificate_name: The name of the deleted certificate. Required.
        :type certificate_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for certificates in the current vault. If it
                          contains 'Purgeable', the certificate can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the certificate, at the
                          end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "cer": bytes("bytes", encoding="utf-8"),  # Optional. CER contents of x509
                      certificate.
                    "contentType": "str",  # Optional. The content type of the secret. eg.
                      'application/x-pem-file' or 'application/x-pkcs12',.
                    "id": "str",  # Optional. The certificate id.
                    "kid": "str",  # Optional. The key id.
                    "policy": {
                        "attributes": {
                            "created": "2020-02-20 00:00:00",  # Optional. Creation time
                              in UTC.
                            "enabled": bool,  # Optional. Determines whether the object
                              is enabled.
                            "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in
                              UTC.
                            "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in
                              UTC.
                            "recoverableDays": 0,  # Optional. softDelete data retention
                              days. Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                            "recoveryLevel": "str",  # Optional. Reflects the deletion
                              recovery level currently in effect for certificates in the current vault.
                              If it contains 'Purgeable', the certificate can be permanently deleted by
                              a privileged user; otherwise, only the system can purge the certificate,
                              at the end of the retention interval. Known values are: "Purgeable",
                              "Recoverable+Purgeable", "Recoverable",
                              "Recoverable+ProtectedSubscription", "CustomizedRecoverable+Purgeable",
                              "CustomizedRecoverable", and
                              "CustomizedRecoverable+ProtectedSubscription".
                            "updated": "2020-02-20 00:00:00"  # Optional. Last updated
                              time in UTC.
                        },
                        "id": "str",  # Optional. The certificate id.
                        "issuer": {
                            "cert_transparency": bool,  # Optional. Indicates if the
                              certificates generated under this policy should be published to
                              certificate transparency logs.
                            "cty": "str",  # Optional. Certificate type as supported by
                              the provider (optional); for example 'OV-SSL', 'EV-SSL'.
                            "name": "str"  # Optional. Name of the referenced issuer
                              object or reserved names; for example, 'Self' or 'Unknown'.
                        },
                        "key_props": {
                            "crv": "str",  # Optional. Elliptic curve name. For valid
                              values, see JsonWebKeyCurveName. Known values are: "P-256", "P-384",
                              "P-521", and "P-256K".
                            "exportable": bool,  # Optional. Indicates if the private key
                              can be exported. Release policy must be provided when creating the first
                              version of an exportable key.
                            "key_size": 0,  # Optional. The key size in bits. For
                              example: 2048, 3072, or 4096 for RSA.
                            "kty": "str",  # Optional. The type of key pair to be used
                              for the certificate. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                              "oct", and "oct-HSM".
                            "reuse_key": bool  # Optional. Indicates if the same key pair
                              will be used on certificate renewal.
                        },
                        "lifetime_actions": [
                            {
                                "action": {
                                    "action_type": "str"  # Optional. The type of
                                      the action. Known values are: "EmailContacts", "AutoRenew",
                                      "Rotate", and "Notify".
                                },
                                "trigger": {
                                    "days_before_expiry": 0,  # Optional. Days
                                      before expiry to attempt renewal. Value should be between 1 and
                                      validity_in_months multiplied by 27. If validity_in_months is 36,
                                      then value should be between 1 and 972 (36 * 27).
                                    "lifetime_percentage": 0  # Optional.
                                      Percentage of lifetime at which to trigger. Value should be
                                      between 1 and 99.
                                }
                            }
                        ],
                        "secret_props": {
                            "contentType": "str"  # Optional. The media type (MIME type).
                        },
                        "x509_props": {
                            "ekus": [
                                "str"  # Optional. The enhanced key usage.
                            ],
                            "key_usage": [
                                "str"  # Optional. Defines how the certificate's key
                                  may be used.
                            ],
                            "sans": {
                                "dns_names": [
                                    "str"  # Optional. Domain names.
                                ],
                                "emails": [
                                    "str"  # Optional. Email addresses.
                                ],
                                "upns": [
                                    "str"  # Optional. User principal names.
                                ]
                            },
                            "subject": "str",  # Optional. The subject name. Should be a
                              valid X509 distinguished Name.
                            "validity_months": 0  # Optional. The duration that the
                              certificate is valid in months.
                        }
                    },
                    "sid": "str",  # Optional. The secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "x5t": bytes("bytes", encoding="utf-8")  # Optional. Thumbprint of the
                      certificate.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_recover_deleted_certificate_request(
            certificate_name=certificate_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_key(
        self,
        vault_base_url: str,
        key_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new key, stores it, then returns key parameters and attributes to the client.

        The create key operation can be used to create any key type in Azure Key Vault. If the named
        key already exists, Azure Key Vault creates a new version of the key. It requires the
        keys/create permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name for the new key. The system will generate the version name for the
         new key. The value you provide may be copied globally for the purpose of running the service.
         The value provided should not include personally identifiable or sensitive information.
         Required.
        :type key_name: str
        :param parameters: The parameters to create a key. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "kty": "str",  # The type of key to create. For valid values, see
                      JsonWebKeyType. Required. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                      "oct", and "oct-HSM".
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                      JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and "P-256K".
                    "key_ops": [
                        "str"  # Optional.
                    ],
                    "key_size": 0,  # Optional. The key size in bits. For example: 2048, 3072, or
                      4096 for RSA.
                    "public_exponent": 0,  # Optional. The public exponent for a RSA key.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @overload
    def create_key(
        self,
        vault_base_url: str,
        key_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new key, stores it, then returns key parameters and attributes to the client.

        The create key operation can be used to create any key type in Azure Key Vault. If the named
        key already exists, Azure Key Vault creates a new version of the key. It requires the
        keys/create permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name for the new key. The system will generate the version name for the
         new key. The value you provide may be copied globally for the purpose of running the service.
         The value provided should not include personally identifiable or sensitive information.
         Required.
        :type key_name: str
        :param parameters: The parameters to create a key. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @distributed_trace
    def create_key(self, vault_base_url: str, key_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates a new key, stores it, then returns key parameters and attributes to the client.

        The create key operation can be used to create any key type in Azure Key Vault. If the named
        key already exists, Azure Key Vault creates a new version of the key. It requires the
        keys/create permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name for the new key. The system will generate the version name for the
         new key. The value you provide may be copied globally for the purpose of running the service.
         The value provided should not include personally identifiable or sensitive information.
         Required.
        :type key_name: str
        :param parameters: The parameters to create a key. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "kty": "str",  # The type of key to create. For valid values, see
                      JsonWebKeyType. Required. Known values are: "EC", "EC-HSM", "RSA", "RSA-HSM",
                      "oct", and "oct-HSM".
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                      JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and "P-256K".
                    "key_ops": [
                        "str"  # Optional.
                    ],
                    "key_size": 0,  # Optional. The key size in bits. For example: 2048, 3072, or
                      4096 for RSA.
                    "public_exponent": 0,  # Optional. The public exponent for a RSA key.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_create_key_request(
            key_name=key_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def rotate_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> JSON:
        """Creates a new key version, stores it, then returns key parameters, attributes and policy to the
        client.

        The operation will rotate the key based on the key policy. It requires the keys/rotate
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of key to be rotated. The system will generate a new version in the
         specified key. Required.
        :type key_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_rotate_key_request(
            key_name=key_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def import_key(
        self,
        vault_base_url: str,
        key_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Imports an externally created key, stores it, and returns key parameters and attributes to the
        client.

        The import key operation may be used to import any key type into an Azure Key Vault. If the
        named key already exists, Azure Key Vault creates a new version of the key. This operation
        requires the keys/import permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: Name for the imported key. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type key_name: str
        :param parameters: The parameters to import a key. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key. Required.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "Hsm": bool,  # Optional. Whether to import as a hardware key (HSM) or
                      software key.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @overload
    def import_key(
        self,
        vault_base_url: str,
        key_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Imports an externally created key, stores it, and returns key parameters and attributes to the
        client.

        The import key operation may be used to import any key type into an Azure Key Vault. If the
        named key already exists, Azure Key Vault creates a new version of the key. This operation
        requires the keys/import permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: Name for the imported key. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type key_name: str
        :param parameters: The parameters to import a key. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @distributed_trace
    def import_key(self, vault_base_url: str, key_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Imports an externally created key, stores it, and returns key parameters and attributes to the
        client.

        The import key operation may be used to import any key type into an Azure Key Vault. If the
        named key already exists, Azure Key Vault creates a new version of the key. This operation
        requires the keys/import permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: Name for the imported key. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type key_name: str
        :param parameters: The parameters to import a key. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key. Required.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "Hsm": bool,  # Optional. Whether to import as a hardware key (HSM) or
                      software key.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_import_key_request(
            key_name=key_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> JSON:
        """Deletes a key of any type from storage in Azure Key Vault.

        The delete key operation cannot be used to remove individual versions of a key. This operation
        removes the cryptographic material associated with the key, which means the key is not usable
        for Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations. This operation requires the
        keys/delete permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key to delete. Required.
        :type key_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the key was
                      deleted, in UTC.
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted key.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      key is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_delete_key_request(
            key_name=key_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update_key(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """The update key operation changes specified attributes of a stored key and can be applied to any
        key type and key version stored in Azure Key Vault.

        In order to perform this operation, the key must already exist in the Key Vault. Note: The
        cryptographic material of a key itself cannot be changed. This operation requires the
        keys/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of key to update. Required.
        :type key_name: str
        :param key_version: The version of the key to update. Required.
        :type key_version: str
        :param parameters: The parameters of the key to update. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key_ops": [
                        "str"  # Optional. Json web key operations. For more information on
                          possible key operations, see JsonWebKeyOperation.
                    ],
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @overload
    def update_key(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """The update key operation changes specified attributes of a stored key and can be applied to any
        key type and key version stored in Azure Key Vault.

        In order to perform this operation, the key must already exist in the Key Vault. Note: The
        cryptographic material of a key itself cannot be changed. This operation requires the
        keys/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of key to update. Required.
        :type key_name: str
        :param key_version: The version of the key to update. Required.
        :type key_version: str
        :param parameters: The parameters of the key to update. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @distributed_trace
    def update_key(
        self, vault_base_url: str, key_name: str, key_version: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """The update key operation changes specified attributes of a stored key and can be applied to any
        key type and key version stored in Azure Key Vault.

        In order to perform this operation, the key must already exist in the Key Vault. Note: The
        cryptographic material of a key itself cannot be changed. This operation requires the
        keys/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of key to update. Required.
        :type key_name: str
        :param key_version: The version of the key to update. Required.
        :type key_version: str
        :param parameters: The parameters of the key to update. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key_ops": [
                        "str"  # Optional. Json web key operations. For more information on
                          possible key operations, see JsonWebKeyOperation.
                    ],
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_update_key_request(
            key_name=key_name,
            key_version=key_version,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_key(self, vault_base_url: str, key_name: str, key_version: str, **kwargs: Any) -> JSON:
        """Gets the public part of a stored key.

        The get key operation is applicable to all key types. If the requested key is symmetric, then
        no key material is released in the response. This operation requires the keys/get permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key to get. Required.
        :type key_name: str
        :param key_version: Adding the version parameter retrieves a specific version of a key. This
         URI fragment is optional. If not specified, the latest version of the key is returned.
         Required.
        :type key_version: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_key_request(
            key_name=key_name,
            key_version=key_version,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_key_versions(
        self, vault_base_url: str, key_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Retrieves a list of individual key versions with the same key name.

        The full key identifier, attributes, and tags are provided in the response. This operation
        requires the keys/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "kid": "str",  # Optional. Key identifier.
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_key_versions_request(
                    key_name=key_name,
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_keys(self, vault_base_url: str, *, maxresults: Optional[int] = None, **kwargs: Any) -> Iterable[JSON]:
        """List keys in the specified vault.

        Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
        public part of a stored key. The LIST operation is applicable to all key types, however only
        the base key identifier, attributes, and tags are provided in the response. Individual versions
        of a key are not listed in the response. This operation requires the keys/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "kid": "str",  # Optional. Key identifier.
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_keys_request(
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def backup_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> JSON:
        """Requests that a backup of the specified key be downloaded to the client.

        The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
        operation does NOT return key material in a form that can be used outside the Azure Key Vault
        system, the returned key material is either protected to a Azure Key Vault HSM or to Azure Key
        Vault itself. The intent of this operation is to allow a client to GENERATE a key in one Azure
        Key Vault instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance.
        The BACKUP operation may be used to export, in protected form, any key type from Azure Key
        Vault. Individual versions of a key cannot be backed up. BACKUP / RESTORE can be performed
        within geographical boundaries only; meaning that a BACKUP from one geographical area cannot be
        restored to another geographical area. For example, a backup from the US geographical area
        cannot be restored in an EU geographical area. This operation requires the key/backup
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": bytes("bytes", encoding="utf-8")  # Optional. The backup blob
                      containing the backed up key.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_backup_key_request(
            key_name=key_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def restore_key(
        self, vault_base_url: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Restores a backed up key to a vault.

        Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier,
        attributes and access control policies. The RESTORE operation may be used to import a
        previously backed up key. Individual versions of a key cannot be restored. The key is restored
        in its entirety with the same key name as it had when it was backed up. If the key name is not
        available in the target Key Vault, the RESTORE operation will be rejected. While the key name
        is retained during restore, the final key identifier will change if the key is restored to a
        different vault. Restore will restore all versions and preserve version identifiers. The
        RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
        same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
        in the target Key Vault. This operation requires the keys/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the key. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": bytes("bytes", encoding="utf-8")  # The backup blob associated with
                      a key bundle. Required.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @overload
    def restore_key(
        self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Restores a backed up key to a vault.

        Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier,
        attributes and access control policies. The RESTORE operation may be used to import a
        previously backed up key. Individual versions of a key cannot be restored. The key is restored
        in its entirety with the same key name as it had when it was backed up. If the key name is not
        available in the target Key Vault, the RESTORE operation will be rejected. While the key name
        is retained during restore, the final key identifier will change if the key is restored to a
        different vault. Restore will restore all versions and preserve version identifiers. The
        RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
        same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
        in the target Key Vault. This operation requires the keys/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the key. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @distributed_trace
    def restore_key(self, vault_base_url: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Restores a backed up key to a vault.

        Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier,
        attributes and access control policies. The RESTORE operation may be used to import a
        previously backed up key. Individual versions of a key cannot be restored. The key is restored
        in its entirety with the same key name as it had when it was backed up. If the key name is not
        available in the target Key Vault, the RESTORE operation will be rejected. While the key name
        is retained during restore, the final key identifier will change if the key is restored to a
        different vault. Restore will restore all versions and preserve version identifiers. The
        RESTORE operation is subject to security constraints: The target Key Vault must be owned by the
        same Microsoft Azure Subscription as the source Key Vault The user must have RESTORE permission
        in the target Key Vault. This operation requires the keys/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the key. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": bytes("bytes", encoding="utf-8")  # The backup blob associated with
                      a key bundle. Required.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_restore_key_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def encrypt(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Encrypts an arbitrary sequence of bytes using an encryption key that is stored in a key vault.

        The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is
        stored in Azure Key Vault. Note that the ENCRYPT operation only supports a single block of
        data, the size of which is dependent on the target key and the encryption algorithm to be used.
        The ENCRYPT operation is only strictly necessary for symmetric keys stored in Azure Key Vault
        since protection with an asymmetric key can be performed using public portion of the key. This
        operation is supported for asymmetric keys as a convenience for callers that have a
        key-reference but do not have access to the public key material. This operation requires the
        keys/encrypt permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the encryption operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # algorithm identifier. Required. Known values are:
                      "RSA-OAEP", "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW",
                      "A192KW", "A256KW", "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD",
                      and "A256CBCPAD".
                    "value": bytes("bytes", encoding="utf-8"),  # Required.
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional. Additional data to
                      authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional. Cryptographically
                      random, non-repeating initialization vector for symmetric algorithms.
                    "tag": bytes("bytes", encoding="utf-8")  # Optional. The tag to authenticate
                      when performing decryption with an authenticated algorithm.
                }

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """

    @overload
    def encrypt(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Encrypts an arbitrary sequence of bytes using an encryption key that is stored in a key vault.

        The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is
        stored in Azure Key Vault. Note that the ENCRYPT operation only supports a single block of
        data, the size of which is dependent on the target key and the encryption algorithm to be used.
        The ENCRYPT operation is only strictly necessary for symmetric keys stored in Azure Key Vault
        since protection with an asymmetric key can be performed using public portion of the key. This
        operation is supported for asymmetric keys as a convenience for callers that have a
        key-reference but do not have access to the public key material. This operation requires the
        keys/encrypt permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the encryption operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """

    @distributed_trace
    def encrypt(
        self, vault_base_url: str, key_name: str, key_version: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Encrypts an arbitrary sequence of bytes using an encryption key that is stored in a key vault.

        The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is
        stored in Azure Key Vault. Note that the ENCRYPT operation only supports a single block of
        data, the size of which is dependent on the target key and the encryption algorithm to be used.
        The ENCRYPT operation is only strictly necessary for symmetric keys stored in Azure Key Vault
        since protection with an asymmetric key can be performed using public portion of the key. This
        operation is supported for asymmetric keys as a convenience for callers that have a
        key-reference but do not have access to the public key material. This operation requires the
        keys/encrypt permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the encryption operation. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # algorithm identifier. Required. Known values are:
                      "RSA-OAEP", "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW",
                      "A192KW", "A256KW", "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD",
                      and "A256CBCPAD".
                    "value": bytes("bytes", encoding="utf-8"),  # Required.
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional. Additional data to
                      authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional. Cryptographically
                      random, non-repeating initialization vector for symmetric algorithms.
                    "tag": bytes("bytes", encoding="utf-8")  # Optional. The tag to authenticate
                      when performing decryption with an authenticated algorithm.
                }

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_encrypt_request(
            key_name=key_name,
            key_version=key_version,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def decrypt(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Decrypts a single block of encrypted data.

        The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption
        key and specified algorithm. This operation is the reverse of the ENCRYPT operation; only a
        single block of data may be decrypted, the size of this block is dependent on the target key
        and the algorithm to be used. The DECRYPT operation applies to asymmetric and symmetric keys
        stored in Azure Key Vault since it uses the private portion of the key. This operation requires
        the keys/decrypt permission. Microsoft recommends not to use CBC algorithms for decryption
        without first ensuring the integrity of the ciphertext using an HMAC, for example. See
        https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more
        information.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the decryption operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # algorithm identifier. Required. Known values are:
                      "RSA-OAEP", "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW",
                      "A192KW", "A256KW", "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD",
                      and "A256CBCPAD".
                    "value": bytes("bytes", encoding="utf-8"),  # Required.
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional. Additional data to
                      authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional. Cryptographically
                      random, non-repeating initialization vector for symmetric algorithms.
                    "tag": bytes("bytes", encoding="utf-8")  # Optional. The tag to authenticate
                      when performing decryption with an authenticated algorithm.
                }

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """

    @overload
    def decrypt(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Decrypts a single block of encrypted data.

        The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption
        key and specified algorithm. This operation is the reverse of the ENCRYPT operation; only a
        single block of data may be decrypted, the size of this block is dependent on the target key
        and the algorithm to be used. The DECRYPT operation applies to asymmetric and symmetric keys
        stored in Azure Key Vault since it uses the private portion of the key. This operation requires
        the keys/decrypt permission. Microsoft recommends not to use CBC algorithms for decryption
        without first ensuring the integrity of the ciphertext using an HMAC, for example. See
        https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more
        information.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the decryption operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """

    @distributed_trace
    def decrypt(
        self, vault_base_url: str, key_name: str, key_version: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Decrypts a single block of encrypted data.

        The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption
        key and specified algorithm. This operation is the reverse of the ENCRYPT operation; only a
        single block of data may be decrypted, the size of this block is dependent on the target key
        and the algorithm to be used. The DECRYPT operation applies to asymmetric and symmetric keys
        stored in Azure Key Vault since it uses the private portion of the key. This operation requires
        the keys/decrypt permission. Microsoft recommends not to use CBC algorithms for decryption
        without first ensuring the integrity of the ciphertext using an HMAC, for example. See
        https://docs.microsoft.com/dotnet/standard/security/vulnerabilities-cbc-mode for more
        information.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the decryption operation. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # algorithm identifier. Required. Known values are:
                      "RSA-OAEP", "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW",
                      "A192KW", "A256KW", "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD",
                      and "A256CBCPAD".
                    "value": bytes("bytes", encoding="utf-8"),  # Required.
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional. Additional data to
                      authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional. Cryptographically
                      random, non-repeating initialization vector for symmetric algorithms.
                    "tag": bytes("bytes", encoding="utf-8")  # Optional. The tag to authenticate
                      when performing decryption with an authenticated algorithm.
                }

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_decrypt_request(
            key_name=key_name,
            key_version=key_version,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def sign(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a signature from a digest using the specified key.

        The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault
        since this operation uses the private portion of the key. This operation requires the keys/sign
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the signing operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # The signing/verification algorithm identifier. For more
                      information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
                      Required. Known values are: "PS256", "PS384", "PS512", "RS256", "RS384", "RS512",
                      "RSNULL", "ES256", "ES384", "ES512", and "ES256K".
                    "value": bytes("bytes", encoding="utf-8")  # Required.
                }

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """

    @overload
    def sign(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a signature from a digest using the specified key.

        The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault
        since this operation uses the private portion of the key. This operation requires the keys/sign
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the signing operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """

    @distributed_trace
    def sign(
        self, vault_base_url: str, key_name: str, key_version: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates a signature from a digest using the specified key.

        The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault
        since this operation uses the private portion of the key. This operation requires the keys/sign
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the signing operation. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # The signing/verification algorithm identifier. For more
                      information on possible algorithm types, see JsonWebKeySignatureAlgorithm.
                      Required. Known values are: "PS256", "PS384", "PS512", "RS256", "RS384", "RS512",
                      "RSNULL", "ES256", "ES384", "ES512", and "ES256K".
                    "value": bytes("bytes", encoding="utf-8")  # Required.
                }

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_sign_request(
            key_name=key_name,
            key_version=key_version,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def verify(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Verifies a signature using a specified key.

        The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not
        strictly necessary for asymmetric keys stored in Azure Key Vault since signature verification
        can be performed using the public portion of the key but this operation is supported as a
        convenience for callers that only have a key-reference and not the public portion of the key.
        This operation requires the keys/verify permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for verify operations. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # The signing/verification algorithm. For more information on
                      possible algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known
                      values are: "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL",
                      "ES256", "ES384", "ES512", and "ES256K".
                    "digest": bytes("bytes", encoding="utf-8"),  # The digest used for signing.
                      Required.
                    "value": bytes("bytes", encoding="utf-8")  # The signature to be verified.
                      Required.
                }

                # response body for status code(s): 200
                response == {
                    "value": bool  # Optional. True if the signature is verified, otherwise
                      false.
                }
        """

    @overload
    def verify(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Verifies a signature using a specified key.

        The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not
        strictly necessary for asymmetric keys stored in Azure Key Vault since signature verification
        can be performed using the public portion of the key but this operation is supported as a
        convenience for callers that only have a key-reference and not the public portion of the key.
        This operation requires the keys/verify permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for verify operations. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": bool  # Optional. True if the signature is verified, otherwise
                      false.
                }
        """

    @distributed_trace
    def verify(
        self, vault_base_url: str, key_name: str, key_version: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Verifies a signature using a specified key.

        The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not
        strictly necessary for asymmetric keys stored in Azure Key Vault since signature verification
        can be performed using the public portion of the key but this operation is supported as a
        convenience for callers that only have a key-reference and not the public portion of the key.
        This operation requires the keys/verify permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for verify operations. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # The signing/verification algorithm. For more information on
                      possible algorithm types, see JsonWebKeySignatureAlgorithm. Required. Known
                      values are: "PS256", "PS384", "PS512", "RS256", "RS384", "RS512", "RSNULL",
                      "ES256", "ES384", "ES512", and "ES256K".
                    "digest": bytes("bytes", encoding="utf-8"),  # The digest used for signing.
                      Required.
                    "value": bytes("bytes", encoding="utf-8")  # The signature to be verified.
                      Required.
                }

                # response body for status code(s): 200
                response == {
                    "value": bool  # Optional. True if the signature is verified, otherwise
                      false.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_verify_request(
            key_name=key_name,
            key_version=key_version,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def wrap_key(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Wraps a symmetric key using a specified key.

        The WRAP operation supports encryption of a symmetric key using a key encryption key that has
        previously been stored in an Azure Key Vault. The WRAP operation is only strictly necessary for
        symmetric keys stored in Azure Key Vault since protection with an asymmetric key can be
        performed using the public portion of the key. This operation is supported for asymmetric keys
        as a convenience for callers that have a key-reference but do not have access to the public key
        material. This operation requires the keys/wrapKey permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for wrap operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # algorithm identifier. Required. Known values are:
                      "RSA-OAEP", "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW",
                      "A192KW", "A256KW", "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD",
                      and "A256CBCPAD".
                    "value": bytes("bytes", encoding="utf-8"),  # Required.
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional. Additional data to
                      authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional. Cryptographically
                      random, non-repeating initialization vector for symmetric algorithms.
                    "tag": bytes("bytes", encoding="utf-8")  # Optional. The tag to authenticate
                      when performing decryption with an authenticated algorithm.
                }

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """

    @overload
    def wrap_key(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Wraps a symmetric key using a specified key.

        The WRAP operation supports encryption of a symmetric key using a key encryption key that has
        previously been stored in an Azure Key Vault. The WRAP operation is only strictly necessary for
        symmetric keys stored in Azure Key Vault since protection with an asymmetric key can be
        performed using the public portion of the key. This operation is supported for asymmetric keys
        as a convenience for callers that have a key-reference but do not have access to the public key
        material. This operation requires the keys/wrapKey permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for wrap operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """

    @distributed_trace
    def wrap_key(
        self, vault_base_url: str, key_name: str, key_version: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Wraps a symmetric key using a specified key.

        The WRAP operation supports encryption of a symmetric key using a key encryption key that has
        previously been stored in an Azure Key Vault. The WRAP operation is only strictly necessary for
        symmetric keys stored in Azure Key Vault since protection with an asymmetric key can be
        performed using the public portion of the key. This operation is supported for asymmetric keys
        as a convenience for callers that have a key-reference but do not have access to the public key
        material. This operation requires the keys/wrapKey permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for wrap operation. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # algorithm identifier. Required. Known values are:
                      "RSA-OAEP", "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW",
                      "A192KW", "A256KW", "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD",
                      and "A256CBCPAD".
                    "value": bytes("bytes", encoding="utf-8"),  # Required.
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional. Additional data to
                      authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional. Cryptographically
                      random, non-repeating initialization vector for symmetric algorithms.
                    "tag": bytes("bytes", encoding="utf-8")  # Optional. The tag to authenticate
                      when performing decryption with an authenticated algorithm.
                }

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_wrap_key_request(
            key_name=key_name,
            key_version=key_version,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def unwrap_key(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Unwraps a symmetric key using the specified key that was initially used for wrapping that key.

        The UNWRAP operation supports decryption of a symmetric key using the target key encryption
        key. This operation is the reverse of the WRAP operation. The UNWRAP operation applies to
        asymmetric and symmetric keys stored in Azure Key Vault since it uses the private portion of
        the key. This operation requires the keys/unwrapKey permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the key operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # algorithm identifier. Required. Known values are:
                      "RSA-OAEP", "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW",
                      "A192KW", "A256KW", "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD",
                      and "A256CBCPAD".
                    "value": bytes("bytes", encoding="utf-8"),  # Required.
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional. Additional data to
                      authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional. Cryptographically
                      random, non-repeating initialization vector for symmetric algorithms.
                    "tag": bytes("bytes", encoding="utf-8")  # Optional. The tag to authenticate
                      when performing decryption with an authenticated algorithm.
                }

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """

    @overload
    def unwrap_key(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Unwraps a symmetric key using the specified key that was initially used for wrapping that key.

        The UNWRAP operation supports decryption of a symmetric key using the target key encryption
        key. This operation is the reverse of the WRAP operation. The UNWRAP operation applies to
        asymmetric and symmetric keys stored in Azure Key Vault since it uses the private portion of
        the key. This operation requires the keys/unwrapKey permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the key operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """

    @distributed_trace
    def unwrap_key(
        self, vault_base_url: str, key_name: str, key_version: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Unwraps a symmetric key using the specified key that was initially used for wrapping that key.

        The UNWRAP operation supports decryption of a symmetric key using the target key encryption
        key. This operation is the reverse of the WRAP operation. The UNWRAP operation applies to
        asymmetric and symmetric keys stored in Azure Key Vault since it uses the private portion of
        the key. This operation requires the keys/unwrapKey permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :param key_version: The version of the key. Required.
        :type key_version: str
        :param parameters: The parameters for the key operation. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "alg": "str",  # algorithm identifier. Required. Known values are:
                      "RSA-OAEP", "RSA-OAEP-256", "RSA1_5", "A128GCM", "A192GCM", "A256GCM", "A128KW",
                      "A192KW", "A256KW", "A128CBC", "A192CBC", "A256CBC", "A128CBCPAD", "A192CBCPAD",
                      and "A256CBCPAD".
                    "value": bytes("bytes", encoding="utf-8"),  # Required.
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional. Additional data to
                      authenticate but not encrypt/decrypt when using authenticated crypto algorithms.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional. Cryptographically
                      random, non-repeating initialization vector for symmetric algorithms.
                    "tag": bytes("bytes", encoding="utf-8")  # Optional. The tag to authenticate
                      when performing decryption with an authenticated algorithm.
                }

                # response body for status code(s): 200
                response == {
                    "aad": bytes("bytes", encoding="utf-8"),  # Optional.
                    "iv": bytes("bytes", encoding="utf-8"),  # Optional.
                    "kid": "str",  # Optional. Key identifier.
                    "tag": bytes("bytes", encoding="utf-8"),  # Optional.
                    "value": bytes("bytes", encoding="utf-8")  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_unwrap_key_request(
            key_name=key_name,
            key_version=key_version,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def release(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Releases a key.

        The release key operation is applicable to all key types. The target key must be marked
        exportable. This operation requires the keys/release permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key to get. Required.
        :type key_name: str
        :param key_version: Adding the version parameter retrieves a specific version of a key.
         Required.
        :type key_version: str
        :param parameters: The parameters for the key release operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "target": "str",  # The attestation assertion for the target of the key
                      release. Required.
                    "enc": "str",  # Optional. The encryption algorithm to use to protected the
                      exported key material. Known values are: "CKM_RSA_AES_KEY_WRAP",
                      "RSA_AES_KEY_WRAP_256", and "RSA_AES_KEY_WRAP_384".
                    "nonce": "str"  # Optional. A client provided nonce for freshness.
                }

                # response body for status code(s): 200
                response == {
                    "value": "str"  # Optional. A signed object containing the released key.
                }
        """

    @overload
    def release(
        self,
        vault_base_url: str,
        key_name: str,
        key_version: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Releases a key.

        The release key operation is applicable to all key types. The target key must be marked
        exportable. This operation requires the keys/release permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key to get. Required.
        :type key_name: str
        :param key_version: Adding the version parameter retrieves a specific version of a key.
         Required.
        :type key_version: str
        :param parameters: The parameters for the key release operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": "str"  # Optional. A signed object containing the released key.
                }
        """

    @distributed_trace
    def release(
        self, vault_base_url: str, key_name: str, key_version: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Releases a key.

        The release key operation is applicable to all key types. The target key must be marked
        exportable. This operation requires the keys/release permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key to get. Required.
        :type key_name: str
        :param key_version: Adding the version parameter retrieves a specific version of a key.
         Required.
        :type key_version: str
        :param parameters: The parameters for the key release operation. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "target": "str",  # The attestation assertion for the target of the key
                      release. Required.
                    "enc": "str",  # Optional. The encryption algorithm to use to protected the
                      exported key material. Known values are: "CKM_RSA_AES_KEY_WRAP",
                      "RSA_AES_KEY_WRAP_256", and "RSA_AES_KEY_WRAP_384".
                    "nonce": "str"  # Optional. A client provided nonce for freshness.
                }

                # response body for status code(s): 200
                response == {
                    "value": "str"  # Optional. A signed object containing the released key.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_release_request(
            key_name=key_name,
            key_version=key_version,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_deleted_keys(
        self, vault_base_url: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists the deleted keys in the specified vault.

        Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the
        public part of a deleted key. This operation includes deletion-specific information. The Get
        Deleted Keys operation is applicable for vaults enabled for soft-delete. While the operation
        can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
        vault. This operation requires the keys/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the key was
                      deleted, in UTC.
                    "kid": "str",  # Optional. Key identifier.
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted key.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      key is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_deleted_keys_request(
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> JSON:
        """Gets the public part of a deleted key.

        The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
        can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled
        vault. This operation requires the keys/get permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the key was
                      deleted, in UTC.
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted key.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      key is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_deleted_key_request(
            key_name=key_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def purge_deleted_key(  # pylint: disable=inconsistent-return-statements
        self, vault_base_url: str, key_name: str, **kwargs: Any
    ) -> None:
        """Permanently deletes the specified key.

        The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the
        operation can be invoked on any vault, it will return an error if invoked on a non soft-delete
        enabled vault. This operation requires the keys/purge permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key. Required.
        :type key_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_key_vault_purge_deleted_key_request(
            key_name=key_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def recover_deleted_key(self, vault_base_url: str, key_name: str, **kwargs: Any) -> JSON:
        """Recovers the deleted key to its latest version.

        The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults.
        It recovers the deleted key back to its latest version under /keys. An attempt to recover an
        non-deleted key will return an error. Consider this the inverse of the delete operation on
        soft-delete enabled vaults. This operation requires the keys/recover permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the deleted key. Required.
        :type key_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "exportable": bool,  # Optional. Indicates if the private key can be
                          exported. Release policy must be provided when creating the first version of
                          an exportable key.
                        "hsmPlatform": "str",  # Optional. The underlying HSM Platform.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for keys in the current vault. If it contains
                          'Purgeable' the key can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the key, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "key": {
                        "crv": "str",  # Optional. Elliptic curve name. For valid values, see
                          JsonWebKeyCurveName. Known values are: "P-256", "P-384", "P-521", and
                          "P-256K".
                        "d": bytes("bytes", encoding="utf-8"),  # Optional. RSA private
                          exponent, or the D component of an EC private key.
                        "dp": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "dq": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "e": bytes("bytes", encoding="utf-8"),  # Optional. RSA public
                          exponent.
                        "k": bytes("bytes", encoding="utf-8"),  # Optional. Symmetric key.
                        "key_hsm": bytes("bytes", encoding="utf-8"),  # Optional. Protected
                          Key, used with 'Bring Your Own Key'.
                        "key_ops": [
                            "str"  # Optional. The Json web key.
                        ],
                        "kid": "str",  # Optional. Key identifier.
                        "kty": "str",  # Optional. JsonWebKey Key Type (kty), as defined in
                          https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Known
                          values are: "EC", "EC-HSM", "RSA", "RSA-HSM", "oct", and "oct-HSM".
                        "n": bytes("bytes", encoding="utf-8"),  # Optional. RSA modulus.
                        "p": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime.
                        "q": bytes("bytes", encoding="utf-8"),  # Optional. RSA secret prime,
                          with p < q.
                        "qi": bytes("bytes", encoding="utf-8"),  # Optional. RSA private key
                          parameter.
                        "x": bytes("bytes", encoding="utf-8"),  # Optional. X component of an
                          EC public key.
                        "y": bytes("bytes", encoding="utf-8")  # Optional. Y component of an
                          EC public key.
                    },
                    "managed": bool,  # Optional. True if the key's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "release_policy": {
                        "contentType": "application/json; charset=utf-8",  # Optional.
                          Default value is "application/json; charset=utf-8". Content type and version
                          of key release policy.
                        "data": bytes("bytes", encoding="utf-8"),  # Optional. Blob encoding
                          the policy rules under which the key can be released. Blob must be base64 URL
                          encoded.
                        "immutable": bool  # Optional. Defines the mutability state of the
                          policy. Once marked immutable, this flag cannot be reset and the policy
                          cannot be changed under any circumstances.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_recover_deleted_key_request(
            key_name=key_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_key_rotation_policy(self, vault_base_url: str, key_name: str, **kwargs: Any) -> JSON:
        """Lists the policy for a key.

        The GetKeyRotationPolicy operation returns the specified key policy resources in the specified
        key vault. This operation requires the keys/get permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key in a given key vault. Required.
        :type key_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. The key rotation
                          policy created time in UTC.
                        "expiryTime": "str",  # Optional. The expiryTime will be applied on
                          the new key version. It should be at least 28 days. It will be in ISO 8601
                          Format. Examples: 90 days: P90D, 3 months: P3M, 48 hours: PT48H, 1 year and
                          10 days: P1Y10D.
                        "updated": "2020-02-20 00:00:00"  # Optional. The key rotation
                          policy's last updated time in UTC.
                    },
                    "id": "str",  # Optional. The key policy id.
                    "lifetimeActions": [
                        {
                            "action": {
                                "type": "str"  # Optional. The type of the action.
                                  The value should be compared case-insensitively. Known values are:
                                  "EmailContacts", "AutoRenew", "Rotate", and "Notify".
                            },
                            "trigger": {
                                "timeAfterCreate": "str",  # Optional. Time after
                                  creation to attempt to rotate. It only applies to rotate. It will be
                                  in ISO 8601 duration format. Example: 90 days : "P90D".
                                "timeBeforeExpiry": "str"  # Optional. Time before
                                  expiry to attempt to rotate or notify. It will be in ISO 8601
                                  duration format. Example: 90 days : "P90D".
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_key_rotation_policy_request(
            key_name=key_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update_key_rotation_policy(
        self,
        vault_base_url: str,
        key_name: str,
        key_rotation_policy: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the rotation policy for a key.

        Set specified members in the key policy. Leave others as undefined. This operation requires the
        keys/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key in the given vault. Required.
        :type key_name: str
        :param key_rotation_policy: The policy for the key. Required.
        :type key_rotation_policy: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                key_rotation_policy = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. The key rotation
                          policy created time in UTC.
                        "expiryTime": "str",  # Optional. The expiryTime will be applied on
                          the new key version. It should be at least 28 days. It will be in ISO 8601
                          Format. Examples: 90 days: P90D, 3 months: P3M, 48 hours: PT48H, 1 year and
                          10 days: P1Y10D.
                        "updated": "2020-02-20 00:00:00"  # Optional. The key rotation
                          policy's last updated time in UTC.
                    },
                    "id": "str",  # Optional. The key policy id.
                    "lifetimeActions": [
                        {
                            "action": {
                                "type": "str"  # Optional. The type of the action.
                                  The value should be compared case-insensitively. Known values are:
                                  "EmailContacts", "AutoRenew", "Rotate", and "Notify".
                            },
                            "trigger": {
                                "timeAfterCreate": "str",  # Optional. Time after
                                  creation to attempt to rotate. It only applies to rotate. It will be
                                  in ISO 8601 duration format. Example: 90 days : "P90D".
                                "timeBeforeExpiry": "str"  # Optional. Time before
                                  expiry to attempt to rotate or notify. It will be in ISO 8601
                                  duration format. Example: 90 days : "P90D".
                            }
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. The key rotation
                          policy created time in UTC.
                        "expiryTime": "str",  # Optional. The expiryTime will be applied on
                          the new key version. It should be at least 28 days. It will be in ISO 8601
                          Format. Examples: 90 days: P90D, 3 months: P3M, 48 hours: PT48H, 1 year and
                          10 days: P1Y10D.
                        "updated": "2020-02-20 00:00:00"  # Optional. The key rotation
                          policy's last updated time in UTC.
                    },
                    "id": "str",  # Optional. The key policy id.
                    "lifetimeActions": [
                        {
                            "action": {
                                "type": "str"  # Optional. The type of the action.
                                  The value should be compared case-insensitively. Known values are:
                                  "EmailContacts", "AutoRenew", "Rotate", and "Notify".
                            },
                            "trigger": {
                                "timeAfterCreate": "str",  # Optional. Time after
                                  creation to attempt to rotate. It only applies to rotate. It will be
                                  in ISO 8601 duration format. Example: 90 days : "P90D".
                                "timeBeforeExpiry": "str"  # Optional. Time before
                                  expiry to attempt to rotate or notify. It will be in ISO 8601
                                  duration format. Example: 90 days : "P90D".
                            }
                        }
                    ]
                }
        """

    @overload
    def update_key_rotation_policy(
        self,
        vault_base_url: str,
        key_name: str,
        key_rotation_policy: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the rotation policy for a key.

        Set specified members in the key policy. Leave others as undefined. This operation requires the
        keys/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key in the given vault. Required.
        :type key_name: str
        :param key_rotation_policy: The policy for the key. Required.
        :type key_rotation_policy: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. The key rotation
                          policy created time in UTC.
                        "expiryTime": "str",  # Optional. The expiryTime will be applied on
                          the new key version. It should be at least 28 days. It will be in ISO 8601
                          Format. Examples: 90 days: P90D, 3 months: P3M, 48 hours: PT48H, 1 year and
                          10 days: P1Y10D.
                        "updated": "2020-02-20 00:00:00"  # Optional. The key rotation
                          policy's last updated time in UTC.
                    },
                    "id": "str",  # Optional. The key policy id.
                    "lifetimeActions": [
                        {
                            "action": {
                                "type": "str"  # Optional. The type of the action.
                                  The value should be compared case-insensitively. Known values are:
                                  "EmailContacts", "AutoRenew", "Rotate", and "Notify".
                            },
                            "trigger": {
                                "timeAfterCreate": "str",  # Optional. Time after
                                  creation to attempt to rotate. It only applies to rotate. It will be
                                  in ISO 8601 duration format. Example: 90 days : "P90D".
                                "timeBeforeExpiry": "str"  # Optional. Time before
                                  expiry to attempt to rotate or notify. It will be in ISO 8601
                                  duration format. Example: 90 days : "P90D".
                            }
                        }
                    ]
                }
        """

    @distributed_trace
    def update_key_rotation_policy(
        self, vault_base_url: str, key_name: str, key_rotation_policy: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates the rotation policy for a key.

        Set specified members in the key policy. Leave others as undefined. This operation requires the
        keys/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param key_name: The name of the key in the given vault. Required.
        :type key_name: str
        :param key_rotation_policy: The policy for the key. Is either a JSON type or a IO type.
         Required.
        :type key_rotation_policy: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                key_rotation_policy = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. The key rotation
                          policy created time in UTC.
                        "expiryTime": "str",  # Optional. The expiryTime will be applied on
                          the new key version. It should be at least 28 days. It will be in ISO 8601
                          Format. Examples: 90 days: P90D, 3 months: P3M, 48 hours: PT48H, 1 year and
                          10 days: P1Y10D.
                        "updated": "2020-02-20 00:00:00"  # Optional. The key rotation
                          policy's last updated time in UTC.
                    },
                    "id": "str",  # Optional. The key policy id.
                    "lifetimeActions": [
                        {
                            "action": {
                                "type": "str"  # Optional. The type of the action.
                                  The value should be compared case-insensitively. Known values are:
                                  "EmailContacts", "AutoRenew", "Rotate", and "Notify".
                            },
                            "trigger": {
                                "timeAfterCreate": "str",  # Optional. Time after
                                  creation to attempt to rotate. It only applies to rotate. It will be
                                  in ISO 8601 duration format. Example: 90 days : "P90D".
                                "timeBeforeExpiry": "str"  # Optional. Time before
                                  expiry to attempt to rotate or notify. It will be in ISO 8601
                                  duration format. Example: 90 days : "P90D".
                            }
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. The key rotation
                          policy created time in UTC.
                        "expiryTime": "str",  # Optional. The expiryTime will be applied on
                          the new key version. It should be at least 28 days. It will be in ISO 8601
                          Format. Examples: 90 days: P90D, 3 months: P3M, 48 hours: PT48H, 1 year and
                          10 days: P1Y10D.
                        "updated": "2020-02-20 00:00:00"  # Optional. The key rotation
                          policy's last updated time in UTC.
                    },
                    "id": "str",  # Optional. The key policy id.
                    "lifetimeActions": [
                        {
                            "action": {
                                "type": "str"  # Optional. The type of the action.
                                  The value should be compared case-insensitively. Known values are:
                                  "EmailContacts", "AutoRenew", "Rotate", and "Notify".
                            },
                            "trigger": {
                                "timeAfterCreate": "str",  # Optional. Time after
                                  creation to attempt to rotate. It only applies to rotate. It will be
                                  in ISO 8601 duration format. Example: 90 days : "P90D".
                                "timeBeforeExpiry": "str"  # Optional. Time before
                                  expiry to attempt to rotate or notify. It will be in ISO 8601
                                  duration format. Example: 90 days : "P90D".
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(key_rotation_policy, (IOBase, bytes)):
            _content = key_rotation_policy
        else:
            _json = key_rotation_policy

        request = build_key_vault_update_key_rotation_policy_request(
            key_name=key_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def get_random_bytes(
        self, vault_base_url: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Get the requested number of bytes containing random values.

        Get the requested number of bytes containing random values from a managed HSM.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The request object to get random bytes. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "count": 0  # The requested number of random bytes. Required.
                }

                # response body for status code(s): 200
                response == {
                    "value": bytes("bytes", encoding="utf-8")  # The bytes encoded as a base64url
                      string. Required.
                }
        """

    @overload
    def get_random_bytes(
        self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Get the requested number of bytes containing random values.

        Get the requested number of bytes containing random values from a managed HSM.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The request object to get random bytes. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": bytes("bytes", encoding="utf-8")  # The bytes encoded as a base64url
                      string. Required.
                }
        """

    @distributed_trace
    def get_random_bytes(self, vault_base_url: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Get the requested number of bytes containing random values.

        Get the requested number of bytes containing random values from a managed HSM.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The request object to get random bytes. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "count": 0  # The requested number of random bytes. Required.
                }

                # response body for status code(s): 200
                response == {
                    "value": bytes("bytes", encoding="utf-8")  # The bytes encoded as a base64url
                      string. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_get_random_bytes_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def set_secret(
        self,
        vault_base_url: str,
        secret_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets a secret in a specified key vault.

        The SET operation adds a secret to the Azure Key Vault. If the named secret already exists,
        Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type secret_name: str
        :param parameters: The parameters for setting the secret. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": "str",  # The value of the secret. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @overload
    def set_secret(
        self,
        vault_base_url: str,
        secret_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets a secret in a specified key vault.

        The SET operation adds a secret to the Azure Key Vault. If the named secret already exists,
        Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type secret_name: str
        :param parameters: The parameters for setting the secret. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @distributed_trace
    def set_secret(self, vault_base_url: str, secret_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Sets a secret in a specified key vault.

        The SET operation adds a secret to the Azure Key Vault. If the named secret already exists,
        Azure Key Vault creates a new version of that secret. This operation requires the secrets/set
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. The value you provide may be copied globally for
         the purpose of running the service. The value provided should not include personally
         identifiable or sensitive information. Required.
        :type secret_name: str
        :param parameters: The parameters for setting the secret. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": "str",  # The value of the secret. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_set_secret_request(
            secret_name=secret_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> JSON:
        """Deletes a secret from a specified key vault.

        The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied
        to an individual version of a secret. This operation requires the secrets/delete permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the secret
                      was deleted, in UTC.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted secret.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      secret is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_delete_secret_request(
            secret_name=secret_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update_secret(
        self,
        vault_base_url: str,
        secret_name: str,
        secret_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the attributes associated with a specified secret in a given key vault.

        The UPDATE operation changes specified attributes of an existing stored secret. Attributes that
        are not specified in the request are left unchanged. The value of a secret itself cannot be
        changed. This operation requires the secrets/set permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :param secret_version: The version of the secret. Required.
        :type secret_version: str
        :param parameters: The parameters for update secret operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @overload
    def update_secret(
        self,
        vault_base_url: str,
        secret_name: str,
        secret_version: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the attributes associated with a specified secret in a given key vault.

        The UPDATE operation changes specified attributes of an existing stored secret. Attributes that
        are not specified in the request are left unchanged. The value of a secret itself cannot be
        changed. This operation requires the secrets/set permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :param secret_version: The version of the secret. Required.
        :type secret_version: str
        :param parameters: The parameters for update secret operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @distributed_trace
    def update_secret(
        self, vault_base_url: str, secret_name: str, secret_version: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates the attributes associated with a specified secret in a given key vault.

        The UPDATE operation changes specified attributes of an existing stored secret. Attributes that
        are not specified in the request are left unchanged. The value of a secret itself cannot be
        changed. This operation requires the secrets/set permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :param secret_version: The version of the secret. Required.
        :type secret_version: str
        :param parameters: The parameters for update secret operation. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_update_secret_request(
            secret_name=secret_name,
            secret_version=secret_version,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_secret(self, vault_base_url: str, secret_name: str, secret_version: str, **kwargs: Any) -> JSON:
        """Get a specified secret from a given key vault.

        The GET operation is applicable to any secret stored in Azure Key Vault. This operation
        requires the secrets/get permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :param secret_version: The version of the secret. This URI fragment is optional. If not
         specified, the latest version of the secret is returned. Required.
        :type secret_version: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_secret_request(
            secret_name=secret_name,
            secret_version=secret_version,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_secrets(self, vault_base_url: str, *, maxresults: Optional[int] = None, **kwargs: Any) -> Iterable[JSON]:
        """List secrets in a specified key vault.

        The Get Secrets operation is applicable to the entire vault. However, only the base secret
        identifier and its attributes are provided in the response. Individual secret versions are not
        listed in the response. This operation requires the secrets/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified, the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "id": "str",  # Optional. Secret identifier.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_secrets_request(
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_secret_versions(
        self, vault_base_url: str, secret_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """List all versions of the specified secret.

        The full secret identifier and attributes are provided in the response. No values are returned
        for the secrets. This operations requires the secrets/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified, the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "id": "str",  # Optional. Secret identifier.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_secret_versions_request(
                    secret_name=secret_name,
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deleted_secrets(
        self, vault_base_url: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists deleted secrets for the specified vault.

        The Get Deleted Secrets operation returns the secrets that have been deleted for a vault
        enabled for soft-delete. This operation requires the secrets/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. Type of the secret value such as a
                      password.
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the secret
                      was deleted, in UTC.
                    "id": "str",  # Optional. Secret identifier.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a key backing a certificate, then managed will be true.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted secret.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      secret is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_deleted_secrets_request(
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deleted_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> JSON:
        """Gets the specified deleted secret.

        The Get Deleted Secret operation returns the specified deleted secret along with its
        attributes. This operation requires the secrets/get permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the secret
                      was deleted, in UTC.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted secret.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      secret is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_deleted_secret_request(
            secret_name=secret_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def purge_deleted_secret(  # pylint: disable=inconsistent-return-statements
        self, vault_base_url: str, secret_name: str, **kwargs: Any
    ) -> None:
        """Permanently deletes the specified secret.

        The purge deleted secret operation removes the secret permanently, without the possibility of
        recovery. This operation can only be enabled on a soft-delete enabled vault. This operation
        requires the secrets/purge permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_key_vault_purge_deleted_secret_request(
            secret_name=secret_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def recover_deleted_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> JSON:
        """Recovers the deleted secret to the latest version.

        Recovers the deleted secret in the specified vault. This operation can only be performed on a
        soft-delete enabled vault. This operation requires the secrets/recover permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the deleted secret. Required.
        :type secret_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_recover_deleted_secret_request(
            secret_name=secret_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def backup_secret(self, vault_base_url: str, secret_name: str, **kwargs: Any) -> JSON:
        """Backs up the specified secret.

        Requests that a backup of the specified secret be downloaded to the client. All versions of the
        secret will be downloaded. This operation requires the secrets/backup permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param secret_name: The name of the secret. Required.
        :type secret_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": bytes("bytes", encoding="utf-8")  # Optional. The backup blob
                      containing the backed up secret.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_backup_secret_request(
            secret_name=secret_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def restore_secret(
        self, vault_base_url: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Restores a backed up secret to a vault.

        Restores a backed up secret, and all its versions, to a vault. This operation requires the
        secrets/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the secret. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": bytes("bytes", encoding="utf-8")  # The backup blob associated with
                      a secret bundle. Required.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @overload
    def restore_secret(
        self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Restores a backed up secret to a vault.

        Restores a backed up secret, and all its versions, to a vault. This operation requires the
        secrets/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the secret. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """

    @distributed_trace
    def restore_secret(self, vault_base_url: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Restores a backed up secret to a vault.

        Restores a backed up secret, and all its versions, to a vault. This operation requires the
        secrets/restore permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the secret. Is either a JSON type or a IO type.
         Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": bytes("bytes", encoding="utf-8")  # The backup blob associated with
                      a secret bundle. Required.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. Determines whether the object is
                          enabled.
                        "exp": "2020-02-20 00:00:00",  # Optional. Expiry date in UTC.
                        "nbf": "2020-02-20 00:00:00",  # Optional. Not before date in UTC.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for secrets in the current vault. If it contains
                          'Purgeable', the secret can be permanently deleted by a privileged user;
                          otherwise, only the system can purge the secret, at the end of the retention
                          interval. Known values are: "Purgeable", "Recoverable+Purgeable",
                          "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "contentType": "str",  # Optional. The content type of the secret.
                    "id": "str",  # Optional. The secret id.
                    "kid": "str",  # Optional. If this is a secret backing a KV certificate, then
                      this field specifies the corresponding key backing the KV certificate.
                    "managed": bool,  # Optional. True if the secret's lifetime is managed by key
                      vault. If this is a secret backing a certificate, then managed will be true.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "value": "str"  # Optional. The secret value.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_restore_secret_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update_setting(
        self,
        vault_base_url: str,
        setting_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates key vault account setting, stores it, then returns the setting name and value to the
        client.

        Description of the pool setting to be updated.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param setting_name: The name of the account setting. Must be a valid settings option.
         Required.
        :type setting_name: str
        :param parameters: The parameters to update an account setting. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": "str"  # The value of the pool setting. Required.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The account setting to be updated. Required.
                    "value": "str",  # The value of the pool setting. Required.
                    "type": "str"  # Optional. The type specifier of the value. "boolean"
                }
        """

    @overload
    def update_setting(
        self,
        vault_base_url: str,
        setting_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates key vault account setting, stores it, then returns the setting name and value to the
        client.

        Description of the pool setting to be updated.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param setting_name: The name of the account setting. Must be a valid settings option.
         Required.
        :type setting_name: str
        :param parameters: The parameters to update an account setting. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The account setting to be updated. Required.
                    "value": "str",  # The value of the pool setting. Required.
                    "type": "str"  # Optional. The type specifier of the value. "boolean"
                }
        """

    @distributed_trace
    def update_setting(
        self, vault_base_url: str, setting_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates key vault account setting, stores it, then returns the setting name and value to the
        client.

        Description of the pool setting to be updated.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param setting_name: The name of the account setting. Must be a valid settings option.
         Required.
        :type setting_name: str
        :param parameters: The parameters to update an account setting. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": "str"  # The value of the pool setting. Required.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The account setting to be updated. Required.
                    "value": "str",  # The value of the pool setting. Required.
                    "type": "str"  # Optional. The type specifier of the value. "boolean"
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_update_setting_request(
            setting_name=setting_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_setting(self, vault_base_url: str, setting_name: str, **kwargs: Any) -> JSON:
        """Get specified account setting object.

        Retrieves the setting object of a specified setting name.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param setting_name: The name of the account setting. Must be a valid settings option.
         Required.
        :type setting_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The account setting to be updated. Required.
                    "value": "str",  # The value of the pool setting. Required.
                    "type": "str"  # Optional. The type specifier of the value. "boolean"
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_setting_request(
            setting_name=setting_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_settings(self, vault_base_url: str, **kwargs: Any) -> JSON:
        """List account settings.

        Retrieves a list of all the available account settings that can be configured.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "settings": [
                        {
                            "name": "str",  # The account setting to be updated.
                              Required.
                            "value": "str",  # The value of the pool setting. Required.
                            "type": "str"  # Optional. The type specifier of the value.
                              "boolean"
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_settings_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_storage_accounts(
        self, vault_base_url: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """List storage accounts managed by the specified key vault. This operation requires the
        storage/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. Storage identifier.
                    "resourceId": "str",  # Optional. Storage account resource Id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_storage_accounts_request(
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deleted_storage_accounts(
        self, vault_base_url: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists deleted storage accounts for the specified vault.

        The Get Deleted Storage Accounts operation returns the storage accounts that have been deleted
        for a vault enabled for soft-delete. This operation requires the storage/list permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the storage
                      account was deleted, in UTC.
                    "id": "str",  # Optional. Storage identifier.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted storage account.
                    "resourceId": "str",  # Optional. Storage account resource Id.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      storage account is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_deleted_storage_accounts_request(
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deleted_storage_account(self, vault_base_url: str, storage_account_name: str, **kwargs: Any) -> JSON:
        """Gets the specified deleted storage account.

        The Get Deleted Storage Account operation returns the specified deleted storage account along
        with its attributes. This operation requires the storage/get permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the storage
                      account was deleted, in UTC.
                    "id": "str",  # Optional. The storage account id.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted storage account.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      storage account is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_deleted_storage_account_request(
            storage_account_name=storage_account_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def purge_deleted_storage_account(  # pylint: disable=inconsistent-return-statements
        self, vault_base_url: str, storage_account_name: str, **kwargs: Any
    ) -> None:
        """Permanently deletes the specified storage account.

        The purge deleted storage account operation removes the secret permanently, without the
        possibility of recovery. This operation can only be performed on a soft-delete enabled vault.
        This operation requires the storage/purge permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_key_vault_purge_deleted_storage_account_request(
            storage_account_name=storage_account_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def recover_deleted_storage_account(self, vault_base_url: str, storage_account_name: str, **kwargs: Any) -> JSON:
        """Recovers the deleted storage account.

        Recovers the deleted storage account in the specified vault. This operation can only be
        performed on a soft-delete enabled vault. This operation requires the storage/recover
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_recover_deleted_storage_account_request(
            storage_account_name=storage_account_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def backup_storage_account(self, vault_base_url: str, storage_account_name: str, **kwargs: Any) -> JSON:
        """Backs up the specified storage account.

        Requests that a backup of the specified storage account be downloaded to the client. This
        operation requires the storage/backup permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": bytes("bytes", encoding="utf-8")  # Optional. The backup blob
                      containing the backed up storage account.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_backup_storage_account_request(
            storage_account_name=storage_account_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def restore_storage_account(
        self, vault_base_url: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Restores a backed up storage account to a vault.

        Restores a backed up storage account to a vault. This operation requires the storage/restore
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the storage account. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": bytes("bytes", encoding="utf-8")  # The backup blob associated with
                      a storage account. Required.
                }

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @overload
    def restore_storage_account(
        self, vault_base_url: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Restores a backed up storage account to a vault.

        Restores a backed up storage account to a vault. This operation requires the storage/restore
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the storage account. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @distributed_trace
    def restore_storage_account(self, vault_base_url: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Restores a backed up storage account to a vault.

        Restores a backed up storage account to a vault. This operation requires the storage/restore
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param parameters: The parameters to restore the storage account. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "value": bytes("bytes", encoding="utf-8")  # The backup blob associated with
                      a storage account. Required.
                }

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_restore_storage_account_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete_storage_account(self, vault_base_url: str, storage_account_name: str, **kwargs: Any) -> JSON:
        """Deletes a storage account. This operation requires the storage/delete permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the storage
                      account was deleted, in UTC.
                    "id": "str",  # Optional. The storage account id.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted storage account.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      storage account is scheduled to be purged, in UTC.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_delete_storage_account_request(
            storage_account_name=storage_account_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_storage_account(self, vault_base_url: str, storage_account_name: str, **kwargs: Any) -> JSON:
        """Gets information about a specified storage account. This operation requires the storage/get
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_storage_account_request(
            storage_account_name=storage_account_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def set_storage_account(
        self,
        vault_base_url: str,
        storage_account_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a new storage account. This operation requires the storage/set permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. The value you provide may be
         copied globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type storage_account_name: str
        :param parameters: The parameters to create a storage account. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "activeKeyName": "str",  # Current active storage account key name. Required.
                    "autoRegenerateKey": bool,  # whether keyvault should manage the storage
                      account for the user. Required.
                    "resourceId": "str",  # Storage account resource id. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @overload
    def set_storage_account(
        self,
        vault_base_url: str,
        storage_account_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a new storage account. This operation requires the storage/set permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. The value you provide may be
         copied globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type storage_account_name: str
        :param parameters: The parameters to create a storage account. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @distributed_trace
    def set_storage_account(
        self, vault_base_url: str, storage_account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or updates a new storage account. This operation requires the storage/set permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. The value you provide may be
         copied globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type storage_account_name: str
        :param parameters: The parameters to create a storage account. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "activeKeyName": "str",  # Current active storage account key name. Required.
                    "autoRegenerateKey": bool,  # whether keyvault should manage the storage
                      account for the user. Required.
                    "resourceId": "str",  # Storage account resource id. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_set_storage_account_request(
            storage_account_name=storage_account_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update_storage_account(
        self,
        vault_base_url: str,
        storage_account_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the specified attributes associated with the given storage account. This operation
        requires the storage/set/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param parameters: The parameters to update a storage account. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @overload
    def update_storage_account(
        self,
        vault_base_url: str,
        storage_account_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the specified attributes associated with the given storage account. This operation
        requires the storage/set/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param parameters: The parameters to update a storage account. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @distributed_trace
    def update_storage_account(
        self, vault_base_url: str, storage_account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Updates the specified attributes associated with the given storage account. This operation
        requires the storage/set/update permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param parameters: The parameters to update a storage account. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_update_storage_account_request(
            storage_account_name=storage_account_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def regenerate_storage_account_key(
        self,
        vault_base_url: str,
        storage_account_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Regenerates the specified key value for the given storage account. This operation requires the
        storage/regeneratekey permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param parameters: The parameters to regenerate storage account key. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "keyName": "str"  # The storage account key name. Required.
                }

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @overload
    def regenerate_storage_account_key(
        self,
        vault_base_url: str,
        storage_account_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Regenerates the specified key value for the given storage account. This operation requires the
        storage/regeneratekey permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param parameters: The parameters to regenerate storage account key. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """

    @distributed_trace
    def regenerate_storage_account_key(
        self, vault_base_url: str, storage_account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Regenerates the specified key value for the given storage account. This operation requires the
        storage/regeneratekey permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param parameters: The parameters to regenerate storage account key. Is either a JSON type or a
         IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "keyName": "str"  # The storage account key name. Required.
                }

                # response body for status code(s): 200
                response == {
                    "activeKeyName": "str",  # Optional. The current active storage account key
                      name.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for storage accounts in the current vault. If it
                          contains 'Purgeable' the storage account can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the storage account, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "autoRegenerateKey": bool,  # Optional. whether keyvault should manage the
                      storage account for the user.
                    "id": "str",  # Optional. The storage account id.
                    "regenerationPeriod": "str",  # Optional. The key regeneration time duration
                      specified in ISO-8601 format.
                    "resourceId": "str",  # Optional. The storage account resource id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_regenerate_storage_account_key_request(
            storage_account_name=storage_account_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_sas_definitions(
        self, vault_base_url: str, storage_account_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """List storage SAS definitions for the given storage account. This operation requires the
        storage/listsas permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The storage SAS identifier.
                    "sid": "str",  # Optional. The storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_sas_definitions_request(
                    storage_account_name=storage_account_name,
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deleted_sas_definitions(
        self, vault_base_url: str, storage_account_name: str, *, maxresults: Optional[int] = None, **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists deleted SAS definitions for the specified vault and storage account.

        The Get Deleted Sas Definitions operation returns the SAS definitions that have been deleted
        for a vault enabled for soft-delete. This operation requires the storage/listsas permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :keyword maxresults: Maximum number of results to return in a page. If not specified the
         service will return up to 25 results. Default value is None.
        :paramtype maxresults: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the SAS
                      definition was deleted, in UTC.
                    "id": "str",  # Optional. The storage SAS identifier.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted SAS definition.
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      SAS definition is scheduled to be purged, in UTC.
                    "sid": "str",  # Optional. The storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_key_vault_get_deleted_sas_definitions_request(
                    storage_account_name=storage_account_name,
                    maxresults=maxresults,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_deleted_sas_definition(
        self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the specified deleted sas definition.

        The Get Deleted SAS Definition operation returns the specified deleted SAS definition along
        with its attributes. This operation requires the storage/getsas permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param sas_definition_name: The name of the SAS definition. Required.
        :type sas_definition_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the SAS
                      definition was deleted, in UTC.
                    "id": "str",  # Optional. The SAS definition id.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted SAS definition.
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      SAS definition is scheduled to be purged, in UTC.
                    "sid": "str",  # Optional. Storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_deleted_sas_definition_request(
            storage_account_name=storage_account_name,
            sas_definition_name=sas_definition_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def recover_deleted_sas_definition(
        self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
    ) -> JSON:
        """Recovers the deleted SAS definition.

        Recovers the deleted SAS definition for the specified storage account. This operation can only
        be performed on a soft-delete enabled vault. This operation requires the storage/recover
        permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param sas_definition_name: The name of the SAS definition. Required.
        :type sas_definition_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The SAS definition id.
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "sid": "str",  # Optional. Storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_recover_deleted_sas_definition_request(
            storage_account_name=storage_account_name,
            sas_definition_name=sas_definition_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete_sas_definition(
        self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
    ) -> JSON:
        """Deletes a SAS definition from a specified storage account. This operation requires the
        storage/deletesas permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param sas_definition_name: The name of the SAS definition. Required.
        :type sas_definition_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "deletedDate": "2020-02-20 00:00:00",  # Optional. The time when the SAS
                      definition was deleted, in UTC.
                    "id": "str",  # Optional. The SAS definition id.
                    "recoveryId": "str",  # Optional. The url of the recovery object, used to
                      identify and recover the deleted SAS definition.
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "scheduledPurgeDate": "2020-02-20 00:00:00",  # Optional. The time when the
                      SAS definition is scheduled to be purged, in UTC.
                    "sid": "str",  # Optional. Storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_delete_sas_definition_request(
            storage_account_name=storage_account_name,
            sas_definition_name=sas_definition_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_sas_definition(
        self, vault_base_url: str, storage_account_name: str, sas_definition_name: str, **kwargs: Any
    ) -> JSON:
        """Gets information about a SAS definition for the specified storage account. This operation
        requires the storage/getsas permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param sas_definition_name: The name of the SAS definition. Required.
        :type sas_definition_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The SAS definition id.
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "sid": "str",  # Optional. Storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_key_vault_get_sas_definition_request(
            storage_account_name=storage_account_name,
            sas_definition_name=sas_definition_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def set_sas_definition(
        self,
        vault_base_url: str,
        storage_account_name: str,
        sas_definition_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a new SAS definition for the specified storage account. This operation
        requires the storage/setsas permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param sas_definition_name: The name of the SAS definition. The value you provide may be copied
         globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type sas_definition_name: str
        :param parameters: The parameters to create a SAS definition. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "sasType": "str",  # The type of SAS token the SAS definition will create.
                      Required. Known values are: "account" and "service".
                    "templateUri": "str",  # The SAS definition token template signed with an
                      arbitrary key.  Tokens created according to the SAS definition will have the same
                      properties as the template. Required.
                    "validityPeriod": "str",  # The validity period of SAS tokens created
                      according to the SAS definition. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The SAS definition id.
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "sid": "str",  # Optional. Storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }
        """

    @overload
    def set_sas_definition(
        self,
        vault_base_url: str,
        storage_account_name: str,
        sas_definition_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a new SAS definition for the specified storage account. This operation
        requires the storage/setsas permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param sas_definition_name: The name of the SAS definition. The value you provide may be copied
         globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type sas_definition_name: str
        :param parameters: The parameters to create a SAS definition. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The SAS definition id.
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "sid": "str",  # Optional. Storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }
        """

    @distributed_trace
    def set_sas_definition(
        self,
        vault_base_url: str,
        storage_account_name: str,
        sas_definition_name: str,
        parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a new SAS definition for the specified storage account. This operation
        requires the storage/setsas permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param sas_definition_name: The name of the SAS definition. The value you provide may be copied
         globally for the purpose of running the service. The value provided should not include
         personally identifiable or sensitive information. Required.
        :type sas_definition_name: str
        :param parameters: The parameters to create a SAS definition. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "sasType": "str",  # The type of SAS token the SAS definition will create.
                      Required. Known values are: "account" and "service".
                    "templateUri": "str",  # The SAS definition token template signed with an
                      arbitrary key.  Tokens created according to the SAS definition will have the same
                      properties as the template. Required.
                    "validityPeriod": "str",  # The validity period of SAS tokens created
                      according to the SAS definition. Required.
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The SAS definition id.
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "sid": "str",  # Optional. Storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_set_sas_definition_request(
            storage_account_name=storage_account_name,
            sas_definition_name=sas_definition_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update_sas_definition(
        self,
        vault_base_url: str,
        storage_account_name: str,
        sas_definition_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the specified attributes associated with the given SAS definition. This operation
        requires the storage/setsas permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param sas_definition_name: The name of the SAS definition. Required.
        :type sas_definition_name: str
        :param parameters: The parameters to update a SAS definition. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The SAS definition id.
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "sid": "str",  # Optional. Storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }
        """

    @overload
    def update_sas_definition(
        self,
        vault_base_url: str,
        storage_account_name: str,
        sas_definition_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates the specified attributes associated with the given SAS definition. This operation
        requires the storage/setsas permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param sas_definition_name: The name of the SAS definition. Required.
        :type sas_definition_name: str
        :param parameters: The parameters to update a SAS definition. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The SAS definition id.
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "sid": "str",  # Optional. Storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }
        """

    @distributed_trace
    def update_sas_definition(
        self,
        vault_base_url: str,
        storage_account_name: str,
        sas_definition_name: str,
        parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Updates the specified attributes associated with the given SAS definition. This operation
        requires the storage/setsas permission.

        :param vault_base_url: The vault name, for example https://myvault.vault.azure.net. Required.
        :type vault_base_url: str
        :param storage_account_name: The name of the storage account. Required.
        :type storage_account_name: str
        :param sas_definition_name: The name of the SAS definition. Required.
        :type sas_definition_name: str
        :param parameters: The parameters to update a SAS definition. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }

                # response body for status code(s): 200
                response == {
                    "attributes": {
                        "created": "2020-02-20 00:00:00",  # Optional. Creation time in UTC.
                        "enabled": bool,  # Optional. the enabled state of the object.
                        "recoverableDays": 0,  # Optional. softDelete data retention days.
                          Value should be >=7 and <=90 when softDelete enabled, otherwise 0.
                        "recoveryLevel": "str",  # Optional. Reflects the deletion recovery
                          level currently in effect for SAS definitions in the current vault. If it
                          contains 'Purgeable' the SAS definition can be permanently deleted by a
                          privileged user; otherwise, only the system can purge the SAS definition, at
                          the end of the retention interval. Known values are: "Purgeable",
                          "Recoverable+Purgeable", "Recoverable", "Recoverable+ProtectedSubscription",
                          "CustomizedRecoverable+Purgeable", "CustomizedRecoverable", and
                          "CustomizedRecoverable+ProtectedSubscription".
                        "updated": "2020-02-20 00:00:00"  # Optional. Last updated time in
                          UTC.
                    },
                    "id": "str",  # Optional. The SAS definition id.
                    "sasType": "str",  # Optional. The type of SAS token the SAS definition will
                      create. Known values are: "account" and "service".
                    "sid": "str",  # Optional. Storage account SAS definition secret id.
                    "tags": {
                        "str": "str"  # Optional. Application specific metadata in the form
                          of key-value pairs.
                    },
                    "templateUri": "str",  # Optional. The SAS definition token template signed
                      with an arbitrary key.  Tokens created according to the SAS definition will have
                      the same properties as the template.
                    "validityPeriod": "str"  # Optional. The validity period of SAS tokens
                      created according to the SAS definition.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_key_vault_update_sas_definition_request(
            storage_account_name=storage_account_name,
            sas_definition_name=sas_definition_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "vaultBaseUrl": self._serialize.url("vault_base_url", vault_base_url, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)
