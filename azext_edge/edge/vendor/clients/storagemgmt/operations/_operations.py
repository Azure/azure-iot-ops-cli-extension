# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer
from .._vendor import _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
if sys.version_info >= (3, 8):
    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
else:
    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_blob_services_list_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_services_set_service_properties_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    blob_services_name: Literal["default"] = kwargs.pop("blob_services_name", "default")
    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/{BlobServicesName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "BlobServicesName": _SERIALIZER.url("blob_services_name", blob_services_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_services_get_service_properties_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    blob_services_name: Literal["default"] = kwargs.pop("blob_services_name", "default")
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/{BlobServicesName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "BlobServicesName": _SERIALIZER.url("blob_services_name", blob_services_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_list_request(
    resource_group_name: str,
    account_name: str,
    subscription_id: str,
    *,
    filter: Optional[str] = None,
    include: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if include is not None:
        _params["$include"] = _SERIALIZER.query("include", include, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_create_request(
    resource_group_name: str, account_name: str, container_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_update_request(
    resource_group_name: str, account_name: str, container_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_get_request(
    resource_group_name: str, account_name: str, container_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_delete_request(
    resource_group_name: str, account_name: str, container_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)


def build_blob_containers_set_legal_hold_request(
    resource_group_name: str, account_name: str, container_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/setLegalHold"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_clear_legal_hold_request(
    resource_group_name: str, account_name: str, container_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/clearLegalHold"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_create_or_update_immutability_policy_request(
    resource_group_name: str,
    account_name: str,
    container_name: str,
    subscription_id: str,
    *,
    if_match: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    immutability_policy_name: Literal["default"] = kwargs.pop("immutability_policy_name", "default")
    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "immutabilityPolicyName": _SERIALIZER.url("immutability_policy_name", immutability_policy_name, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_get_immutability_policy_request(
    resource_group_name: str,
    account_name: str,
    container_name: str,
    subscription_id: str,
    *,
    if_match: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    immutability_policy_name: Literal["default"] = kwargs.pop("immutability_policy_name", "default")
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "immutabilityPolicyName": _SERIALIZER.url("immutability_policy_name", immutability_policy_name, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if if_match is not None:
        _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_delete_immutability_policy_request(
    resource_group_name: str,
    account_name: str,
    container_name: str,
    subscription_id: str,
    *,
    if_match: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    immutability_policy_name: Literal["default"] = kwargs.pop("immutability_policy_name", "default")
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "immutabilityPolicyName": _SERIALIZER.url("immutability_policy_name", immutability_policy_name, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_lock_immutability_policy_request(
    resource_group_name: str,
    account_name: str,
    container_name: str,
    subscription_id: str,
    *,
    if_match: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/default/lock"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_extend_immutability_policy_request(
    resource_group_name: str,
    account_name: str,
    container_name: str,
    subscription_id: str,
    *,
    if_match: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/default/extend"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["If-Match"] = _SERIALIZER.header("if_match", if_match, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_lease_request(
    resource_group_name: str, account_name: str, container_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/lease"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_containers_object_level_worm_request(
    resource_group_name: str, account_name: str, container_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/migrate"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "containerName": _SERIALIZER.url("container_name", container_name, "str", max_length=63, min_length=3),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Storage/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_skus_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/skus"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_check_name_availability_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/checkNameAvailability"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_create_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_delete_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)


def build_storage_accounts_get_properties_request(
    resource_group_name: str, account_name: str, subscription_id: str, *, expand: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_update_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/storageAccounts"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts"
    )
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_list_keys_request(
    resource_group_name: str,
    account_name: str,
    subscription_id: str,
    *,
    expand: Optional[Literal["kerb"]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/listKeys"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_regenerate_key_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/regenerateKey"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_list_account_sas_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListAccountSas"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_list_service_sas_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/ListServiceSas"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_failover_request(
    resource_group_name: str,
    account_name: str,
    subscription_id: str,
    *,
    failover_type: Optional[Literal["Planned"]] = None,
    **kwargs: Any
) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/failover"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if failover_type is not None:
        _params["failoverType"] = _SERIALIZER.query("failover_type", failover_type, "str")

    return HttpRequest(method="POST", url=_url, params=_params, **kwargs)


def build_storage_accounts_hierarchical_namespace_migration_request(
    resource_group_name: str, account_name: str, subscription_id: str, *, request_type: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/hnsonmigration"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["requestType"] = _SERIALIZER.query("request_type", request_type, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_abort_hierarchical_namespace_migration_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/aborthnsonmigration"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_customer_initiated_migration_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/startAccountMigration"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_get_customer_initiated_migration_request(
    resource_group_name: str, account_name: str, migration_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/accountMigrations/{migrationName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "migrationName": _SERIALIZER.url("migration_name", migration_name, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_restore_blob_ranges_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/restoreBlobRanges"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_storage_accounts_revoke_user_delegation_keys_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/revokeUserDelegationKeys"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url("account_name", account_name, "str", max_length=24, min_length=3),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    return HttpRequest(method="POST", url=_url, params=_params, **kwargs)


def build_deleted_accounts_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/deletedAccounts"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_deleted_accounts_get_request(
    deleted_account_name: str, location: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/locations/{location}/deletedAccounts/{deletedAccountName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "deletedAccountName": _SERIALIZER.url(
            "deleted_account_name", deleted_account_name, "str", max_length=24, min_length=3
        ),
        "location": _SERIALIZER.url("location", location, "str"),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_usages_list_by_location_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/locations/{location}/usages"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "location": _SERIALIZER.url("location", location, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_management_policies_get_request(
    resource_group_name: str, account_name: str, management_policy_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/managementPolicies/{managementPolicyName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "managementPolicyName": _SERIALIZER.url("management_policy_name", management_policy_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_management_policies_create_or_update_request(
    resource_group_name: str, account_name: str, management_policy_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/managementPolicies/{managementPolicyName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "managementPolicyName": _SERIALIZER.url("management_policy_name", management_policy_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_management_policies_delete_request(
    resource_group_name: str, account_name: str, management_policy_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/managementPolicies/{managementPolicyName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "managementPolicyName": _SERIALIZER.url("management_policy_name", management_policy_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, **kwargs)


def build_blob_inventory_policies_get_request(
    resource_group_name: str, account_name: str, blob_inventory_policy_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/inventoryPolicies/{blobInventoryPolicyName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "blobInventoryPolicyName": _SERIALIZER.url("blob_inventory_policy_name", blob_inventory_policy_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_inventory_policies_create_or_update_request(
    resource_group_name: str, account_name: str, blob_inventory_policy_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/inventoryPolicies/{blobInventoryPolicyName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "blobInventoryPolicyName": _SERIALIZER.url("blob_inventory_policy_name", blob_inventory_policy_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_inventory_policies_delete_request(
    resource_group_name: str, account_name: str, blob_inventory_policy_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/inventoryPolicies/{blobInventoryPolicyName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "blobInventoryPolicyName": _SERIALIZER.url("blob_inventory_policy_name", blob_inventory_policy_name, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_blob_inventory_policies_list_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/inventoryPolicies"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_private_endpoint_connections_list_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/privateEndpointConnections"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_private_endpoint_connections_get_request(
    resource_group_name: str,
    account_name: str,
    private_endpoint_connection_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "privateEndpointConnectionName": _SERIALIZER.url(
            "private_endpoint_connection_name", private_endpoint_connection_name, "str"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_private_endpoint_connections_put_request(
    resource_group_name: str,
    account_name: str,
    private_endpoint_connection_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "privateEndpointConnectionName": _SERIALIZER.url(
            "private_endpoint_connection_name", private_endpoint_connection_name, "str"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_private_endpoint_connections_delete_request(
    resource_group_name: str,
    account_name: str,
    private_endpoint_connection_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "privateEndpointConnectionName": _SERIALIZER.url(
            "private_endpoint_connection_name", private_endpoint_connection_name, "str"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_private_link_resources_list_by_storage_account_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/privateLinkResources"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_object_replication_policies_list_request(
    resource_group_name: str, account_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/objectReplicationPolicies"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_object_replication_policies_get_request(
    resource_group_name: str, account_name: str, object_replication_policy_id: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/objectReplicationPolicies/{objectReplicationPolicyId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "objectReplicationPolicyId": _SERIALIZER.url(
            "object_replication_policy_id", object_replication_policy_id, "str", min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_object_replication_policies_create_or_update_request(
    resource_group_name: str, account_name: str, object_replication_policy_id: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/objectReplicationPolicies/{objectReplicationPolicyId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "objectReplicationPolicyId": _SERIALIZER.url(
            "object_replication_policy_id", object_replication_policy_id, "str", min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_object_replication_policies_delete_request(
    resource_group_name: str, account_name: str, object_replication_policy_id: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/objectReplicationPolicies/{objectReplicationPolicyId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "objectReplicationPolicyId": _SERIALIZER.url(
            "object_replication_policy_id", object_replication_policy_id, "str", min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_local_users_list_request(
    resource_group_name: str,
    account_name: str,
    subscription_id: str,
    *,
    filter: Optional[str] = None,
    include: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if include is not None:
        _params["$include"] = _SERIALIZER.query("include", include, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_local_users_get_request(
    resource_group_name: str, account_name: str, username: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers/{username}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "username": _SERIALIZER.url("username", username, "str", max_length=64, min_length=3),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_local_users_create_or_update_request(
    resource_group_name: str, account_name: str, username: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers/{username}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "username": _SERIALIZER.url("username", username, "str", max_length=64, min_length=3),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_local_users_delete_request(
    resource_group_name: str, account_name: str, username: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers/{username}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "username": _SERIALIZER.url("username", username, "str", max_length=64, min_length=3),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_local_users_list_keys_request(
    resource_group_name: str, account_name: str, username: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers/{username}/listKeys"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "username": _SERIALIZER.url("username", username, "str", max_length=64, min_length=3),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_local_users_regenerate_password_request(
    resource_group_name: str, account_name: str, username: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/localUsers/{username}/regeneratePassword"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "username": _SERIALIZER.url("username", username, "str", max_length=64, min_length=3),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_encryption_scopes_put_request(
    resource_group_name: str, account_name: str, encryption_scope_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/encryptionScopes/{encryptionScopeName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "encryptionScopeName": _SERIALIZER.url(
            "encryption_scope_name", encryption_scope_name, "str", max_length=63, min_length=3
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_encryption_scopes_patch_request(
    resource_group_name: str, account_name: str, encryption_scope_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/encryptionScopes/{encryptionScopeName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "encryptionScopeName": _SERIALIZER.url(
            "encryption_scope_name", encryption_scope_name, "str", max_length=63, min_length=3
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_encryption_scopes_get_request(
    resource_group_name: str, account_name: str, encryption_scope_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/encryptionScopes/{encryptionScopeName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
        "encryptionScopeName": _SERIALIZER.url(
            "encryption_scope_name", encryption_scope_name, "str", max_length=63, min_length=3
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_encryption_scopes_list_request(
    resource_group_name: str,
    account_name: str,
    subscription_id: str,
    *,
    filter: Optional[str] = None,
    include: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-01"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/encryptionScopes"  # pylint: disable=line-too-long
    path_format_arguments = {
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1, pattern=r"^[-\w\._\(\)]+$"
        ),
        "accountName": _SERIALIZER.url(
            "account_name", account_name, "str", max_length=24, min_length=3, pattern=r"^[a-z0-9]+$"
        ),
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if include is not None:
        _params["$include"] = _SERIALIZER.query("include", include, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class BlobServicesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`blob_services` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, account_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List blob services of storage account. It returns a collection of one object named default.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "automaticSnapshotPolicyEnabled": bool,  # Optional. Deprecated in
                          favor of isVersioningEnabled property.
                        "changeFeed": {
                            "enabled": bool,  # Optional. Indicates whether change feed
                              event logging is enabled for the Blob service.
                            "retentionInDays": 0  # Optional. Indicates the duration of
                              changeFeed retention in days. Minimum value is 1 day and maximum value is
                              146000 days (400 years). A null value indicates an infinite retention of
                              the change feed.
                        },
                        "containerDeleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "cors": {
                            "corsRules": [
                                {
                                    "allowedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of headers allowed to be part of the
                                          cross-origin request. Required.
                                    ],
                                    "allowedMethods": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of HTTP methods that are allowed to be
                                          executed by the origin. Required.
                                    ],
                                    "allowedOrigins": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of origin domains that will be allowed via
                                          CORS, or "*" to allow all domains. Required.
                                    ],
                                    "exposedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of response headers to expose to CORS
                                          clients. Required.
                                    ],
                                    "maxAgeInSeconds": 0  # Required if CorsRule
                                      element is present. The number of seconds that the client/browser
                                      should cache a preflight response. Required.
                                }
                            ]
                        },
                        "defaultServiceVersion": "str",  # Optional. DefaultServiceVersion
                          indicates the default version to use for requests to the Blob service if an
                          incoming request"u2019s version is not specified. Possible values include
                          version 2008-10-27 and all more recent versions.
                        "deleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "isVersioningEnabled": bool,  # Optional. Versioning is enabled if
                          set to true.
                        "lastAccessTimeTrackingPolicy": {
                            "enable": bool,  # When set to true last access time based
                              tracking is enabled. Required.
                            "blobType": [
                                "str"  # Optional. An array of predefined supported
                                  blob types. Only blockBlob is the supported value. This field is
                                  currently read only.
                            ],
                            "name": "str",  # Optional. Name of the policy. The valid
                              value is AccessTimeTracking. This field is currently read only.
                              "AccessTimeTracking"
                            "trackingGranularityInDays": 0  # Optional. The field
                              specifies blob object tracking granularity in days, typically how often
                              the blob object should be tracked.This field is currently read only with
                              value as 1.
                        },
                        "restorePolicy": {
                            "enabled": bool,  # Blob restore is enabled if set to true.
                              Required.
                            "days": 0,  # Optional. how long this blob can be restored.
                              It should be great than zero and less than DeleteRetentionPolicy.days.
                            "lastEnabledTime": "2020-02-20 00:00:00",  # Optional.
                              Deprecated in favor of minRestoreTime property.
                            "minRestoreTime": "2020-02-20 00:00:00"  # Optional. Returns
                              the minimum date and time that the restore can be started.
                        }
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_blob_services_list_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def set_service_properties(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets the properties of a storage account’s Blob service, including properties for Storage
        Analytics and CORS (Cross-Origin Resource Sharing) rules.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The properties of a storage account’s Blob service, including properties for
         Storage Analytics and CORS (Cross-Origin Resource Sharing) rules. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword blob_services_name: The name of the blob Service within the specified storage account.
         Blob Service Name must be 'default'. Default value is "default". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype blob_services_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "automaticSnapshotPolicyEnabled": bool,  # Optional. Deprecated in
                          favor of isVersioningEnabled property.
                        "changeFeed": {
                            "enabled": bool,  # Optional. Indicates whether change feed
                              event logging is enabled for the Blob service.
                            "retentionInDays": 0  # Optional. Indicates the duration of
                              changeFeed retention in days. Minimum value is 1 day and maximum value is
                              146000 days (400 years). A null value indicates an infinite retention of
                              the change feed.
                        },
                        "containerDeleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "cors": {
                            "corsRules": [
                                {
                                    "allowedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of headers allowed to be part of the
                                          cross-origin request. Required.
                                    ],
                                    "allowedMethods": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of HTTP methods that are allowed to be
                                          executed by the origin. Required.
                                    ],
                                    "allowedOrigins": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of origin domains that will be allowed via
                                          CORS, or "*" to allow all domains. Required.
                                    ],
                                    "exposedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of response headers to expose to CORS
                                          clients. Required.
                                    ],
                                    "maxAgeInSeconds": 0  # Required if CorsRule
                                      element is present. The number of seconds that the client/browser
                                      should cache a preflight response. Required.
                                }
                            ]
                        },
                        "defaultServiceVersion": "str",  # Optional. DefaultServiceVersion
                          indicates the default version to use for requests to the Blob service if an
                          incoming request"u2019s version is not specified. Possible values include
                          version 2008-10-27 and all more recent versions.
                        "deleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "isVersioningEnabled": bool,  # Optional. Versioning is enabled if
                          set to true.
                        "lastAccessTimeTrackingPolicy": {
                            "enable": bool,  # When set to true last access time based
                              tracking is enabled. Required.
                            "blobType": [
                                "str"  # Optional. An array of predefined supported
                                  blob types. Only blockBlob is the supported value. This field is
                                  currently read only.
                            ],
                            "name": "str",  # Optional. Name of the policy. The valid
                              value is AccessTimeTracking. This field is currently read only.
                              "AccessTimeTracking"
                            "trackingGranularityInDays": 0  # Optional. The field
                              specifies blob object tracking granularity in days, typically how often
                              the blob object should be tracked.This field is currently read only with
                              value as 1.
                        },
                        "restorePolicy": {
                            "enabled": bool,  # Blob restore is enabled if set to true.
                              Required.
                            "days": 0,  # Optional. how long this blob can be restored.
                              It should be great than zero and less than DeleteRetentionPolicy.days.
                            "lastEnabledTime": "2020-02-20 00:00:00",  # Optional.
                              Deprecated in favor of minRestoreTime property.
                            "minRestoreTime": "2020-02-20 00:00:00"  # Optional. Returns
                              the minimum date and time that the restore can be started.
                        }
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "automaticSnapshotPolicyEnabled": bool,  # Optional. Deprecated in
                          favor of isVersioningEnabled property.
                        "changeFeed": {
                            "enabled": bool,  # Optional. Indicates whether change feed
                              event logging is enabled for the Blob service.
                            "retentionInDays": 0  # Optional. Indicates the duration of
                              changeFeed retention in days. Minimum value is 1 day and maximum value is
                              146000 days (400 years). A null value indicates an infinite retention of
                              the change feed.
                        },
                        "containerDeleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "cors": {
                            "corsRules": [
                                {
                                    "allowedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of headers allowed to be part of the
                                          cross-origin request. Required.
                                    ],
                                    "allowedMethods": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of HTTP methods that are allowed to be
                                          executed by the origin. Required.
                                    ],
                                    "allowedOrigins": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of origin domains that will be allowed via
                                          CORS, or "*" to allow all domains. Required.
                                    ],
                                    "exposedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of response headers to expose to CORS
                                          clients. Required.
                                    ],
                                    "maxAgeInSeconds": 0  # Required if CorsRule
                                      element is present. The number of seconds that the client/browser
                                      should cache a preflight response. Required.
                                }
                            ]
                        },
                        "defaultServiceVersion": "str",  # Optional. DefaultServiceVersion
                          indicates the default version to use for requests to the Blob service if an
                          incoming request"u2019s version is not specified. Possible values include
                          version 2008-10-27 and all more recent versions.
                        "deleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "isVersioningEnabled": bool,  # Optional. Versioning is enabled if
                          set to true.
                        "lastAccessTimeTrackingPolicy": {
                            "enable": bool,  # When set to true last access time based
                              tracking is enabled. Required.
                            "blobType": [
                                "str"  # Optional. An array of predefined supported
                                  blob types. Only blockBlob is the supported value. This field is
                                  currently read only.
                            ],
                            "name": "str",  # Optional. Name of the policy. The valid
                              value is AccessTimeTracking. This field is currently read only.
                              "AccessTimeTracking"
                            "trackingGranularityInDays": 0  # Optional. The field
                              specifies blob object tracking granularity in days, typically how often
                              the blob object should be tracked.This field is currently read only with
                              value as 1.
                        },
                        "restorePolicy": {
                            "enabled": bool,  # Blob restore is enabled if set to true.
                              Required.
                            "days": 0,  # Optional. how long this blob can be restored.
                              It should be great than zero and less than DeleteRetentionPolicy.days.
                            "lastEnabledTime": "2020-02-20 00:00:00",  # Optional.
                              Deprecated in favor of minRestoreTime property.
                            "minRestoreTime": "2020-02-20 00:00:00"  # Optional. Returns
                              the minimum date and time that the restore can be started.
                        }
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def set_service_properties(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets the properties of a storage account’s Blob service, including properties for Storage
        Analytics and CORS (Cross-Origin Resource Sharing) rules.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The properties of a storage account’s Blob service, including properties for
         Storage Analytics and CORS (Cross-Origin Resource Sharing) rules. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword blob_services_name: The name of the blob Service within the specified storage account.
         Blob Service Name must be 'default'. Default value is "default". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype blob_services_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "automaticSnapshotPolicyEnabled": bool,  # Optional. Deprecated in
                          favor of isVersioningEnabled property.
                        "changeFeed": {
                            "enabled": bool,  # Optional. Indicates whether change feed
                              event logging is enabled for the Blob service.
                            "retentionInDays": 0  # Optional. Indicates the duration of
                              changeFeed retention in days. Minimum value is 1 day and maximum value is
                              146000 days (400 years). A null value indicates an infinite retention of
                              the change feed.
                        },
                        "containerDeleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "cors": {
                            "corsRules": [
                                {
                                    "allowedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of headers allowed to be part of the
                                          cross-origin request. Required.
                                    ],
                                    "allowedMethods": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of HTTP methods that are allowed to be
                                          executed by the origin. Required.
                                    ],
                                    "allowedOrigins": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of origin domains that will be allowed via
                                          CORS, or "*" to allow all domains. Required.
                                    ],
                                    "exposedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of response headers to expose to CORS
                                          clients. Required.
                                    ],
                                    "maxAgeInSeconds": 0  # Required if CorsRule
                                      element is present. The number of seconds that the client/browser
                                      should cache a preflight response. Required.
                                }
                            ]
                        },
                        "defaultServiceVersion": "str",  # Optional. DefaultServiceVersion
                          indicates the default version to use for requests to the Blob service if an
                          incoming request"u2019s version is not specified. Possible values include
                          version 2008-10-27 and all more recent versions.
                        "deleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "isVersioningEnabled": bool,  # Optional. Versioning is enabled if
                          set to true.
                        "lastAccessTimeTrackingPolicy": {
                            "enable": bool,  # When set to true last access time based
                              tracking is enabled. Required.
                            "blobType": [
                                "str"  # Optional. An array of predefined supported
                                  blob types. Only blockBlob is the supported value. This field is
                                  currently read only.
                            ],
                            "name": "str",  # Optional. Name of the policy. The valid
                              value is AccessTimeTracking. This field is currently read only.
                              "AccessTimeTracking"
                            "trackingGranularityInDays": 0  # Optional. The field
                              specifies blob object tracking granularity in days, typically how often
                              the blob object should be tracked.This field is currently read only with
                              value as 1.
                        },
                        "restorePolicy": {
                            "enabled": bool,  # Blob restore is enabled if set to true.
                              Required.
                            "days": 0,  # Optional. how long this blob can be restored.
                              It should be great than zero and less than DeleteRetentionPolicy.days.
                            "lastEnabledTime": "2020-02-20 00:00:00",  # Optional.
                              Deprecated in favor of minRestoreTime property.
                            "minRestoreTime": "2020-02-20 00:00:00"  # Optional. Returns
                              the minimum date and time that the restore can be started.
                        }
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def set_service_properties(
        self, resource_group_name: str, account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Sets the properties of a storage account’s Blob service, including properties for Storage
        Analytics and CORS (Cross-Origin Resource Sharing) rules.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The properties of a storage account’s Blob service, including properties for
         Storage Analytics and CORS (Cross-Origin Resource Sharing) rules. Is either a JSON type or a IO
         type. Required.
        :type parameters: JSON or IO
        :keyword blob_services_name: The name of the blob Service within the specified storage account.
         Blob Service Name must be 'default'. Default value is "default". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype blob_services_name: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "automaticSnapshotPolicyEnabled": bool,  # Optional. Deprecated in
                          favor of isVersioningEnabled property.
                        "changeFeed": {
                            "enabled": bool,  # Optional. Indicates whether change feed
                              event logging is enabled for the Blob service.
                            "retentionInDays": 0  # Optional. Indicates the duration of
                              changeFeed retention in days. Minimum value is 1 day and maximum value is
                              146000 days (400 years). A null value indicates an infinite retention of
                              the change feed.
                        },
                        "containerDeleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "cors": {
                            "corsRules": [
                                {
                                    "allowedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of headers allowed to be part of the
                                          cross-origin request. Required.
                                    ],
                                    "allowedMethods": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of HTTP methods that are allowed to be
                                          executed by the origin. Required.
                                    ],
                                    "allowedOrigins": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of origin domains that will be allowed via
                                          CORS, or "*" to allow all domains. Required.
                                    ],
                                    "exposedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of response headers to expose to CORS
                                          clients. Required.
                                    ],
                                    "maxAgeInSeconds": 0  # Required if CorsRule
                                      element is present. The number of seconds that the client/browser
                                      should cache a preflight response. Required.
                                }
                            ]
                        },
                        "defaultServiceVersion": "str",  # Optional. DefaultServiceVersion
                          indicates the default version to use for requests to the Blob service if an
                          incoming request"u2019s version is not specified. Possible values include
                          version 2008-10-27 and all more recent versions.
                        "deleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "isVersioningEnabled": bool,  # Optional. Versioning is enabled if
                          set to true.
                        "lastAccessTimeTrackingPolicy": {
                            "enable": bool,  # When set to true last access time based
                              tracking is enabled. Required.
                            "blobType": [
                                "str"  # Optional. An array of predefined supported
                                  blob types. Only blockBlob is the supported value. This field is
                                  currently read only.
                            ],
                            "name": "str",  # Optional. Name of the policy. The valid
                              value is AccessTimeTracking. This field is currently read only.
                              "AccessTimeTracking"
                            "trackingGranularityInDays": 0  # Optional. The field
                              specifies blob object tracking granularity in days, typically how often
                              the blob object should be tracked.This field is currently read only with
                              value as 1.
                        },
                        "restorePolicy": {
                            "enabled": bool,  # Blob restore is enabled if set to true.
                              Required.
                            "days": 0,  # Optional. how long this blob can be restored.
                              It should be great than zero and less than DeleteRetentionPolicy.days.
                            "lastEnabledTime": "2020-02-20 00:00:00",  # Optional.
                              Deprecated in favor of minRestoreTime property.
                            "minRestoreTime": "2020-02-20 00:00:00"  # Optional. Returns
                              the minimum date and time that the restore can be started.
                        }
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "automaticSnapshotPolicyEnabled": bool,  # Optional. Deprecated in
                          favor of isVersioningEnabled property.
                        "changeFeed": {
                            "enabled": bool,  # Optional. Indicates whether change feed
                              event logging is enabled for the Blob service.
                            "retentionInDays": 0  # Optional. Indicates the duration of
                              changeFeed retention in days. Minimum value is 1 day and maximum value is
                              146000 days (400 years). A null value indicates an infinite retention of
                              the change feed.
                        },
                        "containerDeleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "cors": {
                            "corsRules": [
                                {
                                    "allowedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of headers allowed to be part of the
                                          cross-origin request. Required.
                                    ],
                                    "allowedMethods": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of HTTP methods that are allowed to be
                                          executed by the origin. Required.
                                    ],
                                    "allowedOrigins": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of origin domains that will be allowed via
                                          CORS, or "*" to allow all domains. Required.
                                    ],
                                    "exposedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of response headers to expose to CORS
                                          clients. Required.
                                    ],
                                    "maxAgeInSeconds": 0  # Required if CorsRule
                                      element is present. The number of seconds that the client/browser
                                      should cache a preflight response. Required.
                                }
                            ]
                        },
                        "defaultServiceVersion": "str",  # Optional. DefaultServiceVersion
                          indicates the default version to use for requests to the Blob service if an
                          incoming request"u2019s version is not specified. Possible values include
                          version 2008-10-27 and all more recent versions.
                        "deleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "isVersioningEnabled": bool,  # Optional. Versioning is enabled if
                          set to true.
                        "lastAccessTimeTrackingPolicy": {
                            "enable": bool,  # When set to true last access time based
                              tracking is enabled. Required.
                            "blobType": [
                                "str"  # Optional. An array of predefined supported
                                  blob types. Only blockBlob is the supported value. This field is
                                  currently read only.
                            ],
                            "name": "str",  # Optional. Name of the policy. The valid
                              value is AccessTimeTracking. This field is currently read only.
                              "AccessTimeTracking"
                            "trackingGranularityInDays": 0  # Optional. The field
                              specifies blob object tracking granularity in days, typically how often
                              the blob object should be tracked.This field is currently read only with
                              value as 1.
                        },
                        "restorePolicy": {
                            "enabled": bool,  # Blob restore is enabled if set to true.
                              Required.
                            "days": 0,  # Optional. how long this blob can be restored.
                              It should be great than zero and less than DeleteRetentionPolicy.days.
                            "lastEnabledTime": "2020-02-20 00:00:00",  # Optional.
                              Deprecated in favor of minRestoreTime property.
                            "minRestoreTime": "2020-02-20 00:00:00"  # Optional. Returns
                              the minimum date and time that the restore can be started.
                        }
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        blob_services_name: Literal["default"] = kwargs.pop("blob_services_name", "default")
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_blob_services_set_service_properties_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            blob_services_name=blob_services_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_service_properties(self, resource_group_name: str, account_name: str, **kwargs: Any) -> JSON:
        """Gets the properties of a storage account’s Blob service, including properties for Storage
        Analytics and CORS (Cross-Origin Resource Sharing) rules.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :keyword blob_services_name: The name of the blob Service within the specified storage account.
         Blob Service Name must be 'default'. Default value is "default". Note that overriding this
         default value may result in unsupported behavior.
        :paramtype blob_services_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "automaticSnapshotPolicyEnabled": bool,  # Optional. Deprecated in
                          favor of isVersioningEnabled property.
                        "changeFeed": {
                            "enabled": bool,  # Optional. Indicates whether change feed
                              event logging is enabled for the Blob service.
                            "retentionInDays": 0  # Optional. Indicates the duration of
                              changeFeed retention in days. Minimum value is 1 day and maximum value is
                              146000 days (400 years). A null value indicates an infinite retention of
                              the change feed.
                        },
                        "containerDeleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "cors": {
                            "corsRules": [
                                {
                                    "allowedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of headers allowed to be part of the
                                          cross-origin request. Required.
                                    ],
                                    "allowedMethods": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of HTTP methods that are allowed to be
                                          executed by the origin. Required.
                                    ],
                                    "allowedOrigins": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of origin domains that will be allowed via
                                          CORS, or "*" to allow all domains. Required.
                                    ],
                                    "exposedHeaders": [
                                        "str"  # Required if CorsRule element
                                          is present. A list of response headers to expose to CORS
                                          clients. Required.
                                    ],
                                    "maxAgeInSeconds": 0  # Required if CorsRule
                                      element is present. The number of seconds that the client/browser
                                      should cache a preflight response. Required.
                                }
                            ]
                        },
                        "defaultServiceVersion": "str",  # Optional. DefaultServiceVersion
                          indicates the default version to use for requests to the Blob service if an
                          incoming request"u2019s version is not specified. Possible values include
                          version 2008-10-27 and all more recent versions.
                        "deleteRetentionPolicy": {
                            "allowPermanentDelete": bool,  # Optional. This property when
                              set to true allows deletion of the soft deleted blob versions and
                              snapshots. This property cannot be used blob restore policy. This
                              property only applies to blob service and does not apply to containers or
                              file share.
                            "days": 0,  # Optional. Indicates the number of days that the
                              deleted item should be retained. The minimum specified value can be 1 and
                              the maximum value can be 365.
                            "enabled": bool  # Optional. Indicates whether
                              DeleteRetentionPolicy is enabled.
                        },
                        "isVersioningEnabled": bool,  # Optional. Versioning is enabled if
                          set to true.
                        "lastAccessTimeTrackingPolicy": {
                            "enable": bool,  # When set to true last access time based
                              tracking is enabled. Required.
                            "blobType": [
                                "str"  # Optional. An array of predefined supported
                                  blob types. Only blockBlob is the supported value. This field is
                                  currently read only.
                            ],
                            "name": "str",  # Optional. Name of the policy. The valid
                              value is AccessTimeTracking. This field is currently read only.
                              "AccessTimeTracking"
                            "trackingGranularityInDays": 0  # Optional. The field
                              specifies blob object tracking granularity in days, typically how often
                              the blob object should be tracked.This field is currently read only with
                              value as 1.
                        },
                        "restorePolicy": {
                            "enabled": bool,  # Blob restore is enabled if set to true.
                              Required.
                            "days": 0,  # Optional. how long this blob can be restored.
                              It should be great than zero and less than DeleteRetentionPolicy.days.
                            "lastEnabledTime": "2020-02-20 00:00:00",  # Optional.
                              Deprecated in favor of minRestoreTime property.
                            "minRestoreTime": "2020-02-20 00:00:00"  # Optional. Returns
                              the minimum date and time that the restore can be started.
                        }
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        blob_services_name: Literal["default"] = kwargs.pop("blob_services_name", "default")
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_blob_services_get_service_properties_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            blob_services_name=blob_services_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class BlobContainersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`blob_containers` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        resource_group_name: str,
        account_name: str,
        *,
        filter: Optional[str] = None,
        include: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists all containers and does not support a prefix like data plane. Also SRP today does not
        return continuation token.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :keyword filter: Optional. When specified, only container names starting with the filter will
         be listed. Default value is None.
        :paramtype filter: str
        :keyword include: Optional, used to include the properties for soft deleted blob containers.
         "deleted" Default value is None.
        :paramtype include: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_blob_containers_list_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    include=include,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        blob_container: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new container under the specified account as described by request body. The container
        resource includes metadata and properties for that container. It does not include a list of the
        blobs contained by the container.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param blob_container: Properties of the blob container to create. Required.
        :type blob_container: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                blob_container = {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def create(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        blob_container: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new container under the specified account as described by request body. The container
        resource includes metadata and properties for that container. It does not include a list of the
        blobs contained by the container.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param blob_container: Properties of the blob container to create. Required.
        :type blob_container: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def create(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        blob_container: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Creates a new container under the specified account as described by request body. The container
        resource includes metadata and properties for that container. It does not include a list of the
        blobs contained by the container.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param blob_container: Properties of the blob container to create. Is either a JSON type or a
         IO type. Required.
        :type blob_container: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                blob_container = {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(blob_container, (IOBase, bytes)):
            _content = blob_container
        else:
            _json = blob_container

        request = build_blob_containers_create_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def update(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        blob_container: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates container properties as specified in request body. Properties not mentioned in the
        request will be unchanged. Update fails if the specified container doesn't already exist.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param blob_container: Properties to update for the blob container. Required.
        :type blob_container: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                blob_container = {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        blob_container: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Updates container properties as specified in request body. Properties not mentioned in the
        request will be unchanged. Update fails if the specified container doesn't already exist.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param blob_container: Properties to update for the blob container. Required.
        :type blob_container: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def update(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        blob_container: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Updates container properties as specified in request body. Properties not mentioned in the
        request will be unchanged. Update fails if the specified container doesn't already exist.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param blob_container: Properties to update for the blob container. Is either a JSON type or a
         IO type. Required.
        :type blob_container: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                blob_container = {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(blob_container, (IOBase, bytes)):
            _content = blob_container
        else:
            _json = blob_container

        request = build_blob_containers_update_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(self, resource_group_name: str, account_name: str, container_name: str, **kwargs: Any) -> JSON:
        """Gets properties of a specified container.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "defaultEncryptionScope": "str",  # Optional. Default the container
                          to use specified encryption scope for all writes.
                        "deleted": bool,  # Optional. Indicates whether the blob container
                          was deleted.
                        "deletedTime": "2020-02-20 00:00:00",  # Optional. Blob container
                          deletion time.
                        "denyEncryptionScopeOverride": bool,  # Optional. Block override of
                          encryption scope from the container default.
                        "enableNfsV3AllSquash": bool,  # Optional. Enable NFSv3 all squash on
                          blob container.
                        "enableNfsV3RootSquash": bool,  # Optional. Enable NFSv3 root squash
                          on blob container.
                        "hasImmutabilityPolicy": bool,  # Optional. The hasImmutabilityPolicy
                          public property is set to true by SRP if ImmutabilityPolicy has been created
                          for this container. The hasImmutabilityPolicy public property is set to false
                          by SRP if ImmutabilityPolicy has not been created for this container.
                        "hasLegalHold": bool,  # Optional. The hasLegalHold public property
                          is set to true by SRP if there are at least one existing tag. The
                          hasLegalHold public property is set to false by SRP if all existing legal
                          hold tags are cleared out. There can be a maximum of 1000 blob containers
                          with hasLegalHold=true for a given account.
                        "immutabilityPolicy": {
                            "etag": "str",  # Optional. ImmutabilityPolicy Etag.
                            "properties": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to an append blob
                                  while maintaining immutability protection and compliance. Only new
                                  blocks can be added and any existing blocks cannot be modified or
                                  deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API.
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  This property can only be changed for unlocked time-based retention
                                  policies. When enabled, new blocks can be written to both 'Append and
                                  Bock Blobs' while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted. This property cannot be changed with
                                  ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and
                                  'allowProtectedAppendWritesAll' properties are mutually exclusive.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state of a blob container, possible values include: Locked and
                                  Unlocked. Known values are: "Locked" and "Unlocked".
                            },
                            "updateHistory": [
                                {
                                    "allowProtectedAppendWrites": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to an append blob while maintaining immutability
                                      protection and compliance. Only new blocks can be added and any
                                      existing blocks cannot be modified or deleted. This property
                                      cannot be changed with ExtendImmutabilityPolicy API.
                                    "allowProtectedAppendWritesAll": bool,  #
                                      Optional. This property can only be changed for unlocked
                                      time-based retention policies. When enabled, new blocks can be
                                      written to both 'Append and Bock Blobs' while maintaining
                                      immutability protection and compliance. Only new blocks can be
                                      added and any existing blocks cannot be modified or deleted. This
                                      property cannot be changed with ExtendImmutabilityPolicy API. The
                                      'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll'
                                      properties are mutually exclusive.
                                    "immutabilityPeriodSinceCreationInDays": 0,
                                      # Optional. The immutability period for the blobs in the
                                      container since the policy creation, in days.
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who updated the
                                      ImmutabilityPolicy.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who updated the
                                      ImmutabilityPolicy.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the ImmutabilityPolicy was
                                      updated.
                                    "update": "str",  # Optional. The
                                      ImmutabilityPolicy update type of a blob container, possible
                                      values include: put, lock and extend. Known values are: "put",
                                      "lock", and "extend".
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who updated the ImmutabilityPolicy.
                                }
                            ]
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. This is an immutable property,
                              when set to true it enables object level immutability at the container
                              level.
                            "migrationState": "str",  # Optional. This property denotes
                              the container level immutability to object level immutability migration
                              state. Known values are: "InProgress" and "Completed".
                            "timeStamp": "2020-02-20 00:00:00"  # Optional. Returns the
                              date and time the object level immutability was enabled.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Returns the
                          date and time the container was last modified.
                        "leaseDuration": "str",  # Optional. Specifies whether the lease on a
                          container is of infinite or fixed duration, only when the container is
                          leased. Known values are: "Infinite" and "Fixed".
                        "leaseState": "str",  # Optional. Lease state of the container. Known
                          values are: "Available", "Leased", "Expired", "Breaking", and "Broken".
                        "leaseStatus": "str",  # Optional. The lease status of the container.
                          Known values are: "Locked" and "Unlocked".
                        "legalHold": {
                            "hasLegalHold": bool,  # Optional. The hasLegalHold public
                              property is set to true by SRP if there are at least one existing tag.
                              The hasLegalHold public property is set to false by SRP if all existing
                              legal hold tags are cleared out. There can be a maximum of 1000 blob
                              containers with hasLegalHold=true for a given account.
                            "protectedAppendWritesHistory": {
                                "allowProtectedAppendWritesAll": bool,  # Optional.
                                  When enabled, new blocks can be written to both 'Append and Bock
                                  Blobs' while maintaining legal hold protection and compliance. Only
                                  new blocks can be added and any existing blocks cannot be modified or
                                  deleted.
                                "timestamp": "2020-02-20 00:00:00"  # Optional.
                                  Returns the date and time the tag was added.
                            },
                            "tags": [
                                {
                                    "objectIdentifier": "str",  # Optional.
                                      Returns the Object ID of the user who added the tag.
                                    "tag": "str",  # Optional. The tag value.
                                    "tenantId": "str",  # Optional. Returns the
                                      Tenant ID that issued the token for the user who added the tag.
                                    "timestamp": "2020-02-20 00:00:00",  #
                                      Optional. Returns the date and time the tag was added.
                                    "upn": "str"  # Optional. Returns the User
                                      Principal Name of the user who added the tag.
                                }
                            ]
                        },
                        "metadata": {
                            "str": "str"  # Optional. A name-value pair to associate with
                              the container as metadata.
                        },
                        "publicAccess": "str",  # Optional. Specifies whether data in the
                          container may be accessed publicly and the level of access. Known values are:
                          "Container", "Blob", and "None".
                        "remainingRetentionDays": 0,  # Optional. Remaining retention days
                          for soft deleted blob container.
                        "version": "str"  # Optional. The version of the deleted blob
                          container.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_blob_containers_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, container_name: str, **kwargs: Any
    ) -> None:
        """Deletes specified container under its account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_blob_containers_delete_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    def set_legal_hold(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        legal_hold: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets legal hold tags. Setting the same tag results in an idempotent operation. SetLegalHold
        follows an append pattern and does not clear out the existing tags that are not specified in
        the request.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param legal_hold: The LegalHold property that will be set to a blob container. Required.
        :type legal_hold: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                legal_hold = {
                    "tags": [
                        "str"  # Each tag should be 3 to 23 alphanumeric characters and is
                          normalized to lower case at SRP. Required.
                    ],
                    "allowProtectedAppendWritesAll": bool,  # Optional. When enabled, new blocks
                      can be written to both 'Append and Bock Blobs' while maintaining legal hold
                      protection and compliance. Only new blocks can be added and any existing blocks
                      cannot be modified or deleted.
                    "hasLegalHold": bool  # Optional. The hasLegalHold public property is set to
                      true by SRP if there are at least one existing tag. The hasLegalHold public
                      property is set to false by SRP if all existing legal hold tags are cleared out.
                      There can be a maximum of 1000 blob containers with hasLegalHold=true for a given
                      account.
                }

                # response body for status code(s): 200
                response == {
                    "tags": [
                        "str"  # Each tag should be 3 to 23 alphanumeric characters and is
                          normalized to lower case at SRP. Required.
                    ],
                    "allowProtectedAppendWritesAll": bool,  # Optional. When enabled, new blocks
                      can be written to both 'Append and Bock Blobs' while maintaining legal hold
                      protection and compliance. Only new blocks can be added and any existing blocks
                      cannot be modified or deleted.
                    "hasLegalHold": bool  # Optional. The hasLegalHold public property is set to
                      true by SRP if there are at least one existing tag. The hasLegalHold public
                      property is set to false by SRP if all existing legal hold tags are cleared out.
                      There can be a maximum of 1000 blob containers with hasLegalHold=true for a given
                      account.
                }
        """

    @overload
    def set_legal_hold(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        legal_hold: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets legal hold tags. Setting the same tag results in an idempotent operation. SetLegalHold
        follows an append pattern and does not clear out the existing tags that are not specified in
        the request.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param legal_hold: The LegalHold property that will be set to a blob container. Required.
        :type legal_hold: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tags": [
                        "str"  # Each tag should be 3 to 23 alphanumeric characters and is
                          normalized to lower case at SRP. Required.
                    ],
                    "allowProtectedAppendWritesAll": bool,  # Optional. When enabled, new blocks
                      can be written to both 'Append and Bock Blobs' while maintaining legal hold
                      protection and compliance. Only new blocks can be added and any existing blocks
                      cannot be modified or deleted.
                    "hasLegalHold": bool  # Optional. The hasLegalHold public property is set to
                      true by SRP if there are at least one existing tag. The hasLegalHold public
                      property is set to false by SRP if all existing legal hold tags are cleared out.
                      There can be a maximum of 1000 blob containers with hasLegalHold=true for a given
                      account.
                }
        """

    @distributed_trace
    def set_legal_hold(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        legal_hold: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Sets legal hold tags. Setting the same tag results in an idempotent operation. SetLegalHold
        follows an append pattern and does not clear out the existing tags that are not specified in
        the request.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param legal_hold: The LegalHold property that will be set to a blob container. Is either a
         JSON type or a IO type. Required.
        :type legal_hold: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                legal_hold = {
                    "tags": [
                        "str"  # Each tag should be 3 to 23 alphanumeric characters and is
                          normalized to lower case at SRP. Required.
                    ],
                    "allowProtectedAppendWritesAll": bool,  # Optional. When enabled, new blocks
                      can be written to both 'Append and Bock Blobs' while maintaining legal hold
                      protection and compliance. Only new blocks can be added and any existing blocks
                      cannot be modified or deleted.
                    "hasLegalHold": bool  # Optional. The hasLegalHold public property is set to
                      true by SRP if there are at least one existing tag. The hasLegalHold public
                      property is set to false by SRP if all existing legal hold tags are cleared out.
                      There can be a maximum of 1000 blob containers with hasLegalHold=true for a given
                      account.
                }

                # response body for status code(s): 200
                response == {
                    "tags": [
                        "str"  # Each tag should be 3 to 23 alphanumeric characters and is
                          normalized to lower case at SRP. Required.
                    ],
                    "allowProtectedAppendWritesAll": bool,  # Optional. When enabled, new blocks
                      can be written to both 'Append and Bock Blobs' while maintaining legal hold
                      protection and compliance. Only new blocks can be added and any existing blocks
                      cannot be modified or deleted.
                    "hasLegalHold": bool  # Optional. The hasLegalHold public property is set to
                      true by SRP if there are at least one existing tag. The hasLegalHold public
                      property is set to false by SRP if all existing legal hold tags are cleared out.
                      There can be a maximum of 1000 blob containers with hasLegalHold=true for a given
                      account.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(legal_hold, (IOBase, bytes)):
            _content = legal_hold
        else:
            _json = legal_hold

        request = build_blob_containers_set_legal_hold_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def clear_legal_hold(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        legal_hold: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Clears legal hold tags. Clearing the same or non-existent tag results in an idempotent
        operation. ClearLegalHold clears out only the specified tags in the request.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param legal_hold: The LegalHold property that will be clear from a blob container. Required.
        :type legal_hold: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                legal_hold = {
                    "tags": [
                        "str"  # Each tag should be 3 to 23 alphanumeric characters and is
                          normalized to lower case at SRP. Required.
                    ],
                    "allowProtectedAppendWritesAll": bool,  # Optional. When enabled, new blocks
                      can be written to both 'Append and Bock Blobs' while maintaining legal hold
                      protection and compliance. Only new blocks can be added and any existing blocks
                      cannot be modified or deleted.
                    "hasLegalHold": bool  # Optional. The hasLegalHold public property is set to
                      true by SRP if there are at least one existing tag. The hasLegalHold public
                      property is set to false by SRP if all existing legal hold tags are cleared out.
                      There can be a maximum of 1000 blob containers with hasLegalHold=true for a given
                      account.
                }

                # response body for status code(s): 200
                response == {
                    "tags": [
                        "str"  # Each tag should be 3 to 23 alphanumeric characters and is
                          normalized to lower case at SRP. Required.
                    ],
                    "allowProtectedAppendWritesAll": bool,  # Optional. When enabled, new blocks
                      can be written to both 'Append and Bock Blobs' while maintaining legal hold
                      protection and compliance. Only new blocks can be added and any existing blocks
                      cannot be modified or deleted.
                    "hasLegalHold": bool  # Optional. The hasLegalHold public property is set to
                      true by SRP if there are at least one existing tag. The hasLegalHold public
                      property is set to false by SRP if all existing legal hold tags are cleared out.
                      There can be a maximum of 1000 blob containers with hasLegalHold=true for a given
                      account.
                }
        """

    @overload
    def clear_legal_hold(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        legal_hold: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Clears legal hold tags. Clearing the same or non-existent tag results in an idempotent
        operation. ClearLegalHold clears out only the specified tags in the request.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param legal_hold: The LegalHold property that will be clear from a blob container. Required.
        :type legal_hold: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tags": [
                        "str"  # Each tag should be 3 to 23 alphanumeric characters and is
                          normalized to lower case at SRP. Required.
                    ],
                    "allowProtectedAppendWritesAll": bool,  # Optional. When enabled, new blocks
                      can be written to both 'Append and Bock Blobs' while maintaining legal hold
                      protection and compliance. Only new blocks can be added and any existing blocks
                      cannot be modified or deleted.
                    "hasLegalHold": bool  # Optional. The hasLegalHold public property is set to
                      true by SRP if there are at least one existing tag. The hasLegalHold public
                      property is set to false by SRP if all existing legal hold tags are cleared out.
                      There can be a maximum of 1000 blob containers with hasLegalHold=true for a given
                      account.
                }
        """

    @distributed_trace
    def clear_legal_hold(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        legal_hold: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Clears legal hold tags. Clearing the same or non-existent tag results in an idempotent
        operation. ClearLegalHold clears out only the specified tags in the request.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param legal_hold: The LegalHold property that will be clear from a blob container. Is either a
         JSON type or a IO type. Required.
        :type legal_hold: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                legal_hold = {
                    "tags": [
                        "str"  # Each tag should be 3 to 23 alphanumeric characters and is
                          normalized to lower case at SRP. Required.
                    ],
                    "allowProtectedAppendWritesAll": bool,  # Optional. When enabled, new blocks
                      can be written to both 'Append and Bock Blobs' while maintaining legal hold
                      protection and compliance. Only new blocks can be added and any existing blocks
                      cannot be modified or deleted.
                    "hasLegalHold": bool  # Optional. The hasLegalHold public property is set to
                      true by SRP if there are at least one existing tag. The hasLegalHold public
                      property is set to false by SRP if all existing legal hold tags are cleared out.
                      There can be a maximum of 1000 blob containers with hasLegalHold=true for a given
                      account.
                }

                # response body for status code(s): 200
                response == {
                    "tags": [
                        "str"  # Each tag should be 3 to 23 alphanumeric characters and is
                          normalized to lower case at SRP. Required.
                    ],
                    "allowProtectedAppendWritesAll": bool,  # Optional. When enabled, new blocks
                      can be written to both 'Append and Bock Blobs' while maintaining legal hold
                      protection and compliance. Only new blocks can be added and any existing blocks
                      cannot be modified or deleted.
                    "hasLegalHold": bool  # Optional. The hasLegalHold public property is set to
                      true by SRP if there are at least one existing tag. The hasLegalHold public
                      property is set to false by SRP if all existing legal hold tags are cleared out.
                      There can be a maximum of 1000 blob containers with hasLegalHold=true for a given
                      account.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(legal_hold, (IOBase, bytes)):
            _content = legal_hold
        else:
            _json = legal_hold

        request = build_blob_containers_clear_legal_hold_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update_immutability_policy(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        parameters: Optional[JSON] = None,
        *,
        if_match: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates an unlocked immutability policy. ETag in If-Match is honored if given but
        not required for this operation.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param parameters: The ImmutabilityPolicy Properties that will be created or updated to a blob
         container. Default value is None.
        :type parameters: JSON
        :keyword if_match: The entity state (ETag) version of the immutability policy to update must be
         returned to the server for all update operations. The ETag value must include the leading and
         trailing double quotes as returned by the service. Default value is None.
        :paramtype if_match: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword immutability_policy_name: The name of the blob container immutabilityPolicy within the
         specified storage account. ImmutabilityPolicy Name must be 'default'. Default value is
         "default". Note that overriding this default value may result in unsupported behavior.
        :paramtype immutability_policy_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def create_or_update_immutability_policy(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        parameters: Optional[IO] = None,
        *,
        if_match: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates an unlocked immutability policy. ETag in If-Match is honored if given but
        not required for this operation.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param parameters: The ImmutabilityPolicy Properties that will be created or updated to a blob
         container. Default value is None.
        :type parameters: IO
        :keyword if_match: The entity state (ETag) version of the immutability policy to update must be
         returned to the server for all update operations. The ETag value must include the leading and
         trailing double quotes as returned by the service. Default value is None.
        :paramtype if_match: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword immutability_policy_name: The name of the blob container immutabilityPolicy within the
         specified storage account. ImmutabilityPolicy Name must be 'default'. Default value is
         "default". Note that overriding this default value may result in unsupported behavior.
        :paramtype immutability_policy_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def create_or_update_immutability_policy(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        parameters: Optional[Union[JSON, IO]] = None,
        *,
        if_match: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Creates or updates an unlocked immutability policy. ETag in If-Match is honored if given but
        not required for this operation.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param parameters: The ImmutabilityPolicy Properties that will be created or updated to a blob
         container. Is either a JSON type or a IO type. Default value is None.
        :type parameters: JSON or IO
        :keyword if_match: The entity state (ETag) version of the immutability policy to update must be
         returned to the server for all update operations. The ETag value must include the leading and
         trailing double quotes as returned by the service. Default value is None.
        :paramtype if_match: str
        :keyword immutability_policy_name: The name of the blob container immutabilityPolicy within the
         specified storage account. ImmutabilityPolicy Name must be 'default'. Default value is
         "default". Note that overriding this default value may result in unsupported behavior.
        :paramtype immutability_policy_name: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        immutability_policy_name: Literal["default"] = kwargs.pop("immutability_policy_name", "default")
        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            if parameters is not None:
                _json = parameters
            else:
                _json = None

        request = build_blob_containers_create_or_update_immutability_policy_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            if_match=if_match,
            immutability_policy_name=immutability_policy_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)

    @distributed_trace
    def get_immutability_policy(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        *,
        if_match: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Gets the existing immutability policy along with the corresponding ETag in response headers and
        body.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :keyword if_match: The entity state (ETag) version of the immutability policy to update must be
         returned to the server for all update operations. The ETag value must include the leading and
         trailing double quotes as returned by the service. Default value is None.
        :paramtype if_match: str
        :keyword immutability_policy_name: The name of the blob container immutabilityPolicy within the
         specified storage account. ImmutabilityPolicy Name must be 'default'. Default value is
         "default". Note that overriding this default value may result in unsupported behavior.
        :paramtype immutability_policy_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        immutability_policy_name: Literal["default"] = kwargs.pop("immutability_policy_name", "default")
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_blob_containers_get_immutability_policy_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            if_match=if_match,
            immutability_policy_name=immutability_policy_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)

    @distributed_trace
    def delete_immutability_policy(
        self, resource_group_name: str, account_name: str, container_name: str, *, if_match: str, **kwargs: Any
    ) -> JSON:
        """Aborts an unlocked immutability policy. The response of delete has
        immutabilityPeriodSinceCreationInDays set to 0. ETag in If-Match is required for this
        operation. Deleting a locked immutability policy is not allowed, the only way is to delete the
        container after deleting all expired blobs inside the policy locked container.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :keyword if_match: The entity state (ETag) version of the immutability policy to update must be
         returned to the server for all update operations. The ETag value must include the leading and
         trailing double quotes as returned by the service. Required.
        :paramtype if_match: str
        :keyword immutability_policy_name: The name of the blob container immutabilityPolicy within the
         specified storage account. ImmutabilityPolicy Name must be 'default'. Default value is
         "default". Note that overriding this default value may result in unsupported behavior.
        :paramtype immutability_policy_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        immutability_policy_name: Literal["default"] = kwargs.pop("immutability_policy_name", "default")
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_blob_containers_delete_immutability_policy_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            if_match=if_match,
            immutability_policy_name=immutability_policy_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)

    @distributed_trace
    def lock_immutability_policy(
        self, resource_group_name: str, account_name: str, container_name: str, *, if_match: str, **kwargs: Any
    ) -> JSON:
        """Sets the ImmutabilityPolicy to Locked state. The only action allowed on a Locked policy is
        ExtendImmutabilityPolicy action. ETag in If-Match is required for this operation.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :keyword if_match: The entity state (ETag) version of the immutability policy to update must be
         returned to the server for all update operations. The ETag value must include the leading and
         trailing double quotes as returned by the service. Required.
        :paramtype if_match: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_blob_containers_lock_immutability_policy_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            if_match=if_match,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)

    @overload
    def extend_immutability_policy(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        parameters: Optional[JSON] = None,
        *,
        if_match: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Extends the immutabilityPeriodSinceCreationInDays of a locked immutabilityPolicy. The only
        action allowed on a Locked policy will be this action. ETag in If-Match is required for this
        operation.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param parameters: The ImmutabilityPolicy Properties that will be extended for a blob
         container. Default value is None.
        :type parameters: JSON
        :keyword if_match: The entity state (ETag) version of the immutability policy to update must be
         returned to the server for all update operations. The ETag value must include the leading and
         trailing double quotes as returned by the service. Required.
        :paramtype if_match: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def extend_immutability_policy(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        parameters: Optional[IO] = None,
        *,
        if_match: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Extends the immutabilityPeriodSinceCreationInDays of a locked immutabilityPolicy. The only
        action allowed on a Locked policy will be this action. ETag in If-Match is required for this
        operation.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param parameters: The ImmutabilityPolicy Properties that will be extended for a blob
         container. Default value is None.
        :type parameters: IO
        :keyword if_match: The entity state (ETag) version of the immutability policy to update must be
         returned to the server for all update operations. The ETag value must include the leading and
         trailing double quotes as returned by the service. Required.
        :paramtype if_match: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def extend_immutability_policy(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        parameters: Optional[Union[JSON, IO]] = None,
        *,
        if_match: str,
        **kwargs: Any
    ) -> JSON:
        """Extends the immutabilityPeriodSinceCreationInDays of a locked immutabilityPolicy. The only
        action allowed on a Locked policy will be this action. ETag in If-Match is required for this
        operation.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param parameters: The ImmutabilityPolicy Properties that will be extended for a blob
         container. Is either a JSON type or a IO type. Default value is None.
        :type parameters: JSON or IO
        :keyword if_match: The entity state (ETag) version of the immutability policy to update must be
         returned to the server for all update operations. The ETag value must include the leading and
         trailing double quotes as returned by the service. Required.
        :paramtype if_match: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "allowProtectedAppendWrites": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to an append blob while maintaining immutability
                          protection and compliance. Only new blocks can be added and any existing
                          blocks cannot be modified or deleted. This property cannot be changed with
                          ExtendImmutabilityPolicy API.
                        "allowProtectedAppendWritesAll": bool,  # Optional. This property can
                          only be changed for unlocked time-based retention policies. When enabled, new
                          blocks can be written to both 'Append and Bock Blobs' while maintaining
                          immutability protection and compliance. Only new blocks can be added and any
                          existing blocks cannot be modified or deleted. This property cannot be
                          changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites'
                          and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
                        "immutabilityPeriodSinceCreationInDays": 0,  # Optional. The
                          immutability period for the blobs in the container since the policy creation,
                          in days.
                        "state": "str"  # Optional. The ImmutabilityPolicy state of a blob
                          container, possible values include: Locked and Unlocked. Known values are:
                          "Locked" and "Unlocked".
                    },
                    "etag": "str",  # Optional. Resource Etag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            if parameters is not None:
                _json = parameters
            else:
                _json = None

        request = build_blob_containers_extend_immutability_policy_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            if_match=if_match,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers["ETag"] = self._deserialize("str", response.headers.get("ETag"))

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)

    @overload
    def lease(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        parameters: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """The Lease Container operation establishes and manages a lock on a container for delete
        operations. The lock duration can be 15 to 60 seconds, or can be infinite.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param parameters: Lease Container request body. Default value is None.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "action": "str",  # Specifies the lease action. Can be one of the available
                      actions. Required. Known values are: "Acquire", "Renew", "Change", "Release", and
                      "Break".
                    "breakPeriod": 0,  # Optional. Optional. For a break action, proposed
                      duration the lease should continue before it is broken, in seconds, between 0 and
                      60.
                    "leaseDuration": 0,  # Optional. Required for acquire. Specifies the duration
                      of the lease, in seconds, or negative one (-1) for a lease that never expires.
                    "leaseId": "str",  # Optional. Identifies the lease. Can be specified in any
                      valid GUID string format.
                    "proposedLeaseId": "str"  # Optional. Optional for acquire, required for
                      change. Proposed lease ID, in a GUID string format.
                }

                # response body for status code(s): 200
                response == {
                    "leaseId": "str",  # Optional. Returned unique lease ID that must be included
                      with any request to delete the container, or to renew, change, or release the
                      lease.
                    "leaseTimeSeconds": "str"  # Optional. Approximate time remaining in the
                      lease period, in seconds.
                }
        """

    @overload
    def lease(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        parameters: Optional[IO] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """The Lease Container operation establishes and manages a lock on a container for delete
        operations. The lock duration can be 15 to 60 seconds, or can be infinite.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param parameters: Lease Container request body. Default value is None.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "leaseId": "str",  # Optional. Returned unique lease ID that must be included
                      with any request to delete the container, or to renew, change, or release the
                      lease.
                    "leaseTimeSeconds": "str"  # Optional. Approximate time remaining in the
                      lease period, in seconds.
                }
        """

    @distributed_trace
    def lease(
        self,
        resource_group_name: str,
        account_name: str,
        container_name: str,
        parameters: Optional[Union[JSON, IO]] = None,
        **kwargs: Any
    ) -> JSON:
        """The Lease Container operation establishes and manages a lock on a container for delete
        operations. The lock duration can be 15 to 60 seconds, or can be infinite.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :param parameters: Lease Container request body. Is either a JSON type or a IO type. Default
         value is None.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "action": "str",  # Specifies the lease action. Can be one of the available
                      actions. Required. Known values are: "Acquire", "Renew", "Change", "Release", and
                      "Break".
                    "breakPeriod": 0,  # Optional. Optional. For a break action, proposed
                      duration the lease should continue before it is broken, in seconds, between 0 and
                      60.
                    "leaseDuration": 0,  # Optional. Required for acquire. Specifies the duration
                      of the lease, in seconds, or negative one (-1) for a lease that never expires.
                    "leaseId": "str",  # Optional. Identifies the lease. Can be specified in any
                      valid GUID string format.
                    "proposedLeaseId": "str"  # Optional. Optional for acquire, required for
                      change. Proposed lease ID, in a GUID string format.
                }

                # response body for status code(s): 200
                response == {
                    "leaseId": "str",  # Optional. Returned unique lease ID that must be included
                      with any request to delete the container, or to renew, change, or release the
                      lease.
                    "leaseTimeSeconds": "str"  # Optional. Approximate time remaining in the
                      lease period, in seconds.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            if parameters is not None:
                _json = parameters
            else:
                _json = None

        request = build_blob_containers_lease_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _object_level_worm_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, container_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_blob_containers_object_level_worm_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            container_name=container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_object_level_worm(
        self, resource_group_name: str, account_name: str, container_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """This operation migrates a blob container from container level WORM to object level immutability
        enabled container. Prerequisites require a container level immutability policy either in locked
        or unlocked state, Account level versioning must be enabled and there should be no Legal hold
        on the container.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param container_name: The name of the blob container within the specified storage account.
         Blob container names must be between 3 and 63 characters in length and use numbers, lower-case
         letters and dash (-) only. Every dash (-) character must be immediately preceded and followed
         by a letter or number. Required.
        :type container_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._object_level_worm_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                container_name=container_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists all of the available Storage Rest API operations.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "display": {
                        "description": "str",  # Optional. Description of the operation.
                        "operation": "str",  # Optional. Type of operation: get, read,
                          delete, etc.
                        "provider": "str",  # Optional. Service provider: Microsoft Storage.
                        "resource": "str"  # Optional. Resource on which the operation is
                          performed etc.
                    },
                    "name": "str",  # Optional. Operation name:
                      {provider}/{resource}/{operation}.
                    "origin": "str",  # Optional. The origin of operations.
                    "properties": {
                        "serviceSpecification": {
                            "metricSpecifications": [
                                {
                                    "aggregationType": "str",  # Optional.
                                      Aggregation type could be Average.
                                    "category": "str",  # Optional. The category
                                      this metric specification belong to, could be Capacity.
                                    "dimensions": [
                                        {
                                            "displayName": "str",  #
                                              Optional. Display name of dimension.
                                            "name": "str"  # Optional.
                                              Display name of dimension.
                                        }
                                    ],
                                    "displayDescription": "str",  # Optional.
                                      Display description of metric specification.
                                    "displayName": "str",  # Optional. Display
                                      name of metric specification.
                                    "fillGapWithZero": bool,  # Optional. The
                                      property to decide fill gap with zero or not.
                                    "name": "str",  # Optional. Name of metric
                                      specification.
                                    "resourceIdDimensionNameOverride": "str",  #
                                      Optional. Account Resource Id.
                                    "unit": "str"  # Optional. Unit could be
                                      Bytes or Count.
                                }
                            ]
                        }
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class SkusOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`skus` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists the available SKUs supported by Microsoft.Storage for given subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The SKU name. Required for account creation; optional for
                      update. Note that in older versions, SKU name was called accountType. Required.
                      Known values are: "Standard_LRS", "Standard_GRS", "Standard_RAGRS",
                      "Standard_ZRS", "Premium_LRS", "Premium_ZRS", "Standard_GZRS", and
                      "Standard_RAGZRS".
                    "capabilities": [
                        {
                            "name": "str",  # Optional. The name of capability, The
                              capability information in the specified SKU, including file encryption,
                              network ACLs, change notification, etc.
                            "value": "str"  # Optional. A string value to indicate states
                              of given capability. Possibly 'true' or 'false'.
                        }
                    ],
                    "kind": "str",  # Optional. Indicates the type of storage account. Known
                      values are: "Storage", "StorageV2", "BlobStorage", "FileStorage", and
                      "BlockBlobStorage".
                    "locations": [
                        "str"  # Optional. The set of locations that the SKU is available.
                          This will be supported and registered Azure Geo Regions (e.g. West US, East
                          US, Southeast Asia, etc.).
                    ],
                    "resourceType": "str",  # Optional. The type of the resource, usually it is
                      'storageAccounts'.
                    "restrictions": [
                        {
                            "reasonCode": "str",  # Optional. The reason for the
                              restriction. As of now this can be "QuotaId" or
                              "NotAvailableForSubscription". Quota Id is set when the SKU has
                              requiredQuotas parameter as the subscription does not belong to that
                              quota. The "NotAvailableForSubscription" is related to capacity at DC.
                              Known values are: "QuotaId" and "NotAvailableForSubscription".
                            "type": "str",  # Optional. The type of restrictions. As of
                              now only possible value for this is location.
                            "values": [
                                "str"  # Optional. The value of restrictions. If the
                                  restriction type is set to location. This would be different
                                  locations where the SKU is restricted.
                            ]
                        }
                    ],
                    "tier": "str"  # Optional. The SKU tier. This is based on the SKU name. Known
                      values are: "Standard" and "Premium".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_skus_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class StorageAccountsOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`storage_accounts` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def check_name_availability(
        self, account_name: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Checks that the storage account name is valid and is not already in use.

        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                account_name = {
                    "name": "str",  # The storage account name. Required.
                    "type": "Microsoft.Storage/storageAccounts"  # Default value is
                      "Microsoft.Storage/storageAccounts". The type of resource,
                      Microsoft.Storage/storageAccounts. Required.
                }

                # response body for status code(s): 200
                response == {
                    "message": "str",  # Optional. Gets an error message explaining the Reason
                      value in more detail.
                    "nameAvailable": bool,  # Optional. Gets a boolean value that indicates
                      whether the name is available for you to use. If true, the name is available. If
                      false, the name has already been taken or is invalid and cannot be used.
                    "reason": "str"  # Optional. Gets the reason that a storage account name
                      could not be used. The Reason element is only returned if NameAvailable is false.
                      Known values are: "AccountNameInvalid" and "AlreadyExists".
                }
        """

    @overload
    def check_name_availability(
        self, account_name: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Checks that the storage account name is valid and is not already in use.

        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "message": "str",  # Optional. Gets an error message explaining the Reason
                      value in more detail.
                    "nameAvailable": bool,  # Optional. Gets a boolean value that indicates
                      whether the name is available for you to use. If true, the name is available. If
                      false, the name has already been taken or is invalid and cannot be used.
                    "reason": "str"  # Optional. Gets the reason that a storage account name
                      could not be used. The Reason element is only returned if NameAvailable is false.
                      Known values are: "AccountNameInvalid" and "AlreadyExists".
                }
        """

    @distributed_trace
    def check_name_availability(self, account_name: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Checks that the storage account name is valid and is not already in use.

        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Is either a JSON type or a IO type. Required.
        :type account_name: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                account_name = {
                    "name": "str",  # The storage account name. Required.
                    "type": "Microsoft.Storage/storageAccounts"  # Default value is
                      "Microsoft.Storage/storageAccounts". The type of resource,
                      Microsoft.Storage/storageAccounts. Required.
                }

                # response body for status code(s): 200
                response == {
                    "message": "str",  # Optional. Gets an error message explaining the Reason
                      value in more detail.
                    "nameAvailable": bool,  # Optional. Gets a boolean value that indicates
                      whether the name is available for you to use. If true, the name is available. If
                      false, the name has already been taken or is invalid and cannot be used.
                    "reason": "str"  # Optional. Gets the reason that a storage account name
                      could not be used. The Reason element is only returned if NameAvailable is false.
                      Known values are: "AccountNameInvalid" and "AlreadyExists".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(account_name, (IOBase, bytes)):
            _content = account_name
        else:
            _json = account_name

        request = build_storage_accounts_check_name_availability_request(
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_initial(
        self, resource_group_name: str, account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_storage_accounts_create_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Asynchronously creates a new storage account with the specified parameters. If an account is
        already created and a subsequent create request is issued with different properties, the
        account properties will be updated. If an account is already created and a subsequent create or
        update request is issued with the exact same set of properties, the request will succeed.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide for the created account. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "kind": "str",  # Required. Indicates the type of storage account. Required.
                      Known values are: "Storage", "StorageV2", "BlobStorage", "FileStorage", and
                      "BlockBlobStorage".
                    "location": "str",  # Required. Gets or sets the location of the resource.
                      This will be one of the supported and registered Azure Geo Regions (e.g. West US,
                      East US, Southeast Asia, etc.). The geo region of a resource cannot be changed
                      once it is created, but if an identical geo region is specified on update, the
                      request will succeed. Required.
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The name of the extended location.
                        "type": "str"  # Optional. The type of the extended location.
                          "EdgeZone"
                    },
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isHnsEnabled": bool,  # Optional. Account HierarchicalNamespace
                          enabled if sets to true.
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isNfsV3Enabled": bool,  # Optional. NFS 3.0 protocol support enabled
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Value is optional but if passed in, must be 'Enabled',
                          'Disabled' or 'SecuredByPerimeter'. Known values are: "Enabled", "Disabled",
                          and "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true. The default value is true since API
                          version 2019-04-01.
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets a list of key value pairs that
                          describe the resource. These tags can be used for viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key with a length no greater than 128
                          characters and a value with a length no greater than 256 characters.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # Optional. The name of the extended location.
                        "type": "str"  # Optional. The type of the extended location.
                          "EdgeZone"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Gets the Kind. Known values are: "Storage",
                      "StorageV2", "BlobStorage", "FileStorage", and "BlockBlobStorage".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "accountMigrationInProgress": bool,  # Optional. If customer
                          initiated account migration is in progress, the value will be true else it
                          will be null.
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "blobRestoreStatus": {
                            "failureReason": "str",  # Optional. Failure reason when blob
                              restore is failed.
                            "parameters": {
                                "blobRanges": [
                                    {
                                        "endRange": "str",  # Blob end range.
                                          This is exclusive. Empty means account end. Required.
                                        "startRange": "str"  # Blob start
                                          range. This is inclusive. Empty means account start.
                                          Required.
                                    }
                                ],
                                "timeToRestore": "2020-02-20 00:00:00"  # Restore
                                  blob to the specified time. Required.
                            },
                            "restoreId": "str",  # Optional. Id for tracking blob restore
                              request.
                            "status": "str"  # Optional. The status of blob restore
                              progress. Possible values are: - InProgress: Indicates that blob restore
                              is ongoing. - Complete: Indicates that blob restore has been completed
                              successfully. - Failed: Indicates that blob restore is failed. Known
                              values are: "InProgress", "Complete", and "Failed".
                        },
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the storage account in UTC.
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "failoverInProgress": bool,  # Optional. If the failover is in
                          progress, the value will be true, otherwise, it will be null.
                        "geoReplicationStats": {
                            "canFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not account failover is supported for the account.
                            "canPlannedFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not planned account failover is supported for the
                              account.
                            "lastSyncTime": "2020-02-20 00:00:00",  # Optional. All
                              primary writes preceding this UTC date/time value are guaranteed to be
                              available for read operations. Primary writes following this point in
                              time may or may not be available for reads. Element may be default value
                              if value of LastSyncTime is not available, this can happen if secondary
                              is offline or we are in bootstrap.
                            "postFailoverRedundancy": "str",  # Optional. The redundancy
                              type of the account after an account failover is performed. Known values
                              are: "Standard_LRS" and "Standard_ZRS".
                            "postPlannedFailoverRedundancy": "str",  # Optional. The
                              redundancy type of the account after a planned account failover is
                              performed. Known values are: "Standard_GRS", "Standard_GZRS",
                              "Standard_RAGRS", and "Standard_RAGZRS".
                            "status": "str"  # Optional. The status of the secondary
                              location. Possible values are: - Live: Indicates that the secondary
                              location is active and operational. - Bootstrap: Indicates initial
                              synchronization from the primary location to the secondary location is in
                              progress.This typically occurs when replication is first enabled. -
                              Unavailable: Indicates that the secondary location is temporarily
                              unavailable. Known values are: "Live", "Bootstrap", and "Unavailable".
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isHnsEnabled": bool,  # Optional. Account HierarchicalNamespace
                          enabled if sets to true.
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isNfsV3Enabled": bool,  # Optional. NFS 3.0 protocol support enabled
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "isSkuConversionBlocked": bool,  # Optional. This property will be
                          set to true or false on an event of ongoing migration. Default value is null.
                        "keyCreationTime": {
                            "key1": "2020-02-20 00:00:00",  # Optional. Storage account
                              keys creation time.
                            "key2": "2020-02-20 00:00:00"  # Optional. Storage account
                              keys creation time.
                        },
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "lastGeoFailoverTime": "2020-02-20 00:00:00",  # Optional. Gets the
                          timestamp of the most recent instance of a failover to the secondary
                          location. Only the most recent timestamp is retained. This element is not
                          returned if there has never been a failover instance. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "primaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "primaryLocation": "str",  # Optional. Gets the location of the
                          primary data center for the storage account.
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateLinkServiceConnectionState": {
                                        "actionRequired": "str",  # Optional.
                                          A message indicating if changes on the service provider
                                          require any updates on the consumer.
                                        "description": "str",  # Optional.
                                          The reason for approval/rejection of the connection.
                                        "status": "str"  # Optional.
                                          Indicates whether the connection has been
                                          Approved/Rejected/Removed by the owner of the service. Known
                                          values are: "Pending", "Approved", and "Rejected".
                                    },
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. The ARM
                                          identifier for Private Endpoint.
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of the private endpoint connection resource.
                                      Known values are: "Succeeded", "Creating", "Deleting", and
                                      "Failed".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. Gets the status of the
                          storage account at the time the operation was called. Known values are:
                          "Creating", "ResolvingDNS", and "Succeeded".
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Known values are: "Enabled", "Disabled", and
                          "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "secondaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "secondaryLocation": "str",  # Optional. Gets the location of the
                          geo-replicated secondary for the storage account. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "statusOfPrimary": "str",  # Optional. Gets the status indicating
                          whether the primary location of the storage account is available or
                          unavailable. Known values are: "available" and "unavailable".
                        "statusOfSecondary": "str",  # Optional. Gets the status indicating
                          whether the secondary location of the storage account is available or
                          unavailable. Only available if the SKU name is Standard_GRS or
                          Standard_RAGRS. Known values are: "available" and "unavailable".
                        "storageAccountSkuConversionStatus": {
                            "endTime": "str",  # Optional. This property represents the
                              sku conversion end time.
                            "skuConversionStatus": "str",  # Optional. This property
                              indicates the current sku conversion status. Known values are:
                              "InProgress", "Succeeded", and "Failed".
                            "startTime": "str",  # Optional. This property represents the
                              sku conversion start time.
                            "targetSkuName": "str"  # Optional. This property represents
                              the target sku name to which the account sku is being converted
                              asynchronously. Known values are: "Standard_LRS", "Standard_GRS",
                              "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                              "Standard_GZRS", and "Standard_RAGZRS".
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true.
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Asynchronously creates a new storage account with the specified parameters. If an account is
        already created and a subsequent create request is issued with different properties, the
        account properties will be updated. If an account is already created and a subsequent create or
        update request is issued with the exact same set of properties, the request will succeed.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide for the created account. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # Optional. The name of the extended location.
                        "type": "str"  # Optional. The type of the extended location.
                          "EdgeZone"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Gets the Kind. Known values are: "Storage",
                      "StorageV2", "BlobStorage", "FileStorage", and "BlockBlobStorage".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "accountMigrationInProgress": bool,  # Optional. If customer
                          initiated account migration is in progress, the value will be true else it
                          will be null.
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "blobRestoreStatus": {
                            "failureReason": "str",  # Optional. Failure reason when blob
                              restore is failed.
                            "parameters": {
                                "blobRanges": [
                                    {
                                        "endRange": "str",  # Blob end range.
                                          This is exclusive. Empty means account end. Required.
                                        "startRange": "str"  # Blob start
                                          range. This is inclusive. Empty means account start.
                                          Required.
                                    }
                                ],
                                "timeToRestore": "2020-02-20 00:00:00"  # Restore
                                  blob to the specified time. Required.
                            },
                            "restoreId": "str",  # Optional. Id for tracking blob restore
                              request.
                            "status": "str"  # Optional. The status of blob restore
                              progress. Possible values are: - InProgress: Indicates that blob restore
                              is ongoing. - Complete: Indicates that blob restore has been completed
                              successfully. - Failed: Indicates that blob restore is failed. Known
                              values are: "InProgress", "Complete", and "Failed".
                        },
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the storage account in UTC.
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "failoverInProgress": bool,  # Optional. If the failover is in
                          progress, the value will be true, otherwise, it will be null.
                        "geoReplicationStats": {
                            "canFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not account failover is supported for the account.
                            "canPlannedFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not planned account failover is supported for the
                              account.
                            "lastSyncTime": "2020-02-20 00:00:00",  # Optional. All
                              primary writes preceding this UTC date/time value are guaranteed to be
                              available for read operations. Primary writes following this point in
                              time may or may not be available for reads. Element may be default value
                              if value of LastSyncTime is not available, this can happen if secondary
                              is offline or we are in bootstrap.
                            "postFailoverRedundancy": "str",  # Optional. The redundancy
                              type of the account after an account failover is performed. Known values
                              are: "Standard_LRS" and "Standard_ZRS".
                            "postPlannedFailoverRedundancy": "str",  # Optional. The
                              redundancy type of the account after a planned account failover is
                              performed. Known values are: "Standard_GRS", "Standard_GZRS",
                              "Standard_RAGRS", and "Standard_RAGZRS".
                            "status": "str"  # Optional. The status of the secondary
                              location. Possible values are: - Live: Indicates that the secondary
                              location is active and operational. - Bootstrap: Indicates initial
                              synchronization from the primary location to the secondary location is in
                              progress.This typically occurs when replication is first enabled. -
                              Unavailable: Indicates that the secondary location is temporarily
                              unavailable. Known values are: "Live", "Bootstrap", and "Unavailable".
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isHnsEnabled": bool,  # Optional. Account HierarchicalNamespace
                          enabled if sets to true.
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isNfsV3Enabled": bool,  # Optional. NFS 3.0 protocol support enabled
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "isSkuConversionBlocked": bool,  # Optional. This property will be
                          set to true or false on an event of ongoing migration. Default value is null.
                        "keyCreationTime": {
                            "key1": "2020-02-20 00:00:00",  # Optional. Storage account
                              keys creation time.
                            "key2": "2020-02-20 00:00:00"  # Optional. Storage account
                              keys creation time.
                        },
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "lastGeoFailoverTime": "2020-02-20 00:00:00",  # Optional. Gets the
                          timestamp of the most recent instance of a failover to the secondary
                          location. Only the most recent timestamp is retained. This element is not
                          returned if there has never been a failover instance. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "primaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "primaryLocation": "str",  # Optional. Gets the location of the
                          primary data center for the storage account.
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateLinkServiceConnectionState": {
                                        "actionRequired": "str",  # Optional.
                                          A message indicating if changes on the service provider
                                          require any updates on the consumer.
                                        "description": "str",  # Optional.
                                          The reason for approval/rejection of the connection.
                                        "status": "str"  # Optional.
                                          Indicates whether the connection has been
                                          Approved/Rejected/Removed by the owner of the service. Known
                                          values are: "Pending", "Approved", and "Rejected".
                                    },
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. The ARM
                                          identifier for Private Endpoint.
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of the private endpoint connection resource.
                                      Known values are: "Succeeded", "Creating", "Deleting", and
                                      "Failed".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. Gets the status of the
                          storage account at the time the operation was called. Known values are:
                          "Creating", "ResolvingDNS", and "Succeeded".
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Known values are: "Enabled", "Disabled", and
                          "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "secondaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "secondaryLocation": "str",  # Optional. Gets the location of the
                          geo-replicated secondary for the storage account. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "statusOfPrimary": "str",  # Optional. Gets the status indicating
                          whether the primary location of the storage account is available or
                          unavailable. Known values are: "available" and "unavailable".
                        "statusOfSecondary": "str",  # Optional. Gets the status indicating
                          whether the secondary location of the storage account is available or
                          unavailable. Only available if the SKU name is Standard_GRS or
                          Standard_RAGRS. Known values are: "available" and "unavailable".
                        "storageAccountSkuConversionStatus": {
                            "endTime": "str",  # Optional. This property represents the
                              sku conversion end time.
                            "skuConversionStatus": "str",  # Optional. This property
                              indicates the current sku conversion status. Known values are:
                              "InProgress", "Succeeded", and "Failed".
                            "startTime": "str",  # Optional. This property represents the
                              sku conversion start time.
                            "targetSkuName": "str"  # Optional. This property represents
                              the target sku name to which the account sku is being converted
                              asynchronously. Known values are: "Standard_LRS", "Standard_GRS",
                              "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                              "Standard_GZRS", and "Standard_RAGZRS".
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true.
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create(
        self, resource_group_name: str, account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Asynchronously creates a new storage account with the specified parameters. If an account is
        already created and a subsequent create request is issued with different properties, the
        account properties will be updated. If an account is already created and a subsequent create or
        update request is issued with the exact same set of properties, the request will succeed.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide for the created account. Is either a JSON type or
         a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "kind": "str",  # Required. Indicates the type of storage account. Required.
                      Known values are: "Storage", "StorageV2", "BlobStorage", "FileStorage", and
                      "BlockBlobStorage".
                    "location": "str",  # Required. Gets or sets the location of the resource.
                      This will be one of the supported and registered Azure Geo Regions (e.g. West US,
                      East US, Southeast Asia, etc.). The geo region of a resource cannot be changed
                      once it is created, but if an identical geo region is specified on update, the
                      request will succeed. Required.
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "extendedLocation": {
                        "name": "str",  # Optional. The name of the extended location.
                        "type": "str"  # Optional. The type of the extended location.
                          "EdgeZone"
                    },
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isHnsEnabled": bool,  # Optional. Account HierarchicalNamespace
                          enabled if sets to true.
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isNfsV3Enabled": bool,  # Optional. NFS 3.0 protocol support enabled
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Value is optional but if passed in, must be 'Enabled',
                          'Disabled' or 'SecuredByPerimeter'. Known values are: "Enabled", "Disabled",
                          and "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true. The default value is true since API
                          version 2019-04-01.
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets a list of key value pairs that
                          describe the resource. These tags can be used for viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key with a length no greater than 128
                          characters and a value with a length no greater than 256 characters.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # Optional. The name of the extended location.
                        "type": "str"  # Optional. The type of the extended location.
                          "EdgeZone"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Gets the Kind. Known values are: "Storage",
                      "StorageV2", "BlobStorage", "FileStorage", and "BlockBlobStorage".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "accountMigrationInProgress": bool,  # Optional. If customer
                          initiated account migration is in progress, the value will be true else it
                          will be null.
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "blobRestoreStatus": {
                            "failureReason": "str",  # Optional. Failure reason when blob
                              restore is failed.
                            "parameters": {
                                "blobRanges": [
                                    {
                                        "endRange": "str",  # Blob end range.
                                          This is exclusive. Empty means account end. Required.
                                        "startRange": "str"  # Blob start
                                          range. This is inclusive. Empty means account start.
                                          Required.
                                    }
                                ],
                                "timeToRestore": "2020-02-20 00:00:00"  # Restore
                                  blob to the specified time. Required.
                            },
                            "restoreId": "str",  # Optional. Id for tracking blob restore
                              request.
                            "status": "str"  # Optional. The status of blob restore
                              progress. Possible values are: - InProgress: Indicates that blob restore
                              is ongoing. - Complete: Indicates that blob restore has been completed
                              successfully. - Failed: Indicates that blob restore is failed. Known
                              values are: "InProgress", "Complete", and "Failed".
                        },
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the storage account in UTC.
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "failoverInProgress": bool,  # Optional. If the failover is in
                          progress, the value will be true, otherwise, it will be null.
                        "geoReplicationStats": {
                            "canFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not account failover is supported for the account.
                            "canPlannedFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not planned account failover is supported for the
                              account.
                            "lastSyncTime": "2020-02-20 00:00:00",  # Optional. All
                              primary writes preceding this UTC date/time value are guaranteed to be
                              available for read operations. Primary writes following this point in
                              time may or may not be available for reads. Element may be default value
                              if value of LastSyncTime is not available, this can happen if secondary
                              is offline or we are in bootstrap.
                            "postFailoverRedundancy": "str",  # Optional. The redundancy
                              type of the account after an account failover is performed. Known values
                              are: "Standard_LRS" and "Standard_ZRS".
                            "postPlannedFailoverRedundancy": "str",  # Optional. The
                              redundancy type of the account after a planned account failover is
                              performed. Known values are: "Standard_GRS", "Standard_GZRS",
                              "Standard_RAGRS", and "Standard_RAGZRS".
                            "status": "str"  # Optional. The status of the secondary
                              location. Possible values are: - Live: Indicates that the secondary
                              location is active and operational. - Bootstrap: Indicates initial
                              synchronization from the primary location to the secondary location is in
                              progress.This typically occurs when replication is first enabled. -
                              Unavailable: Indicates that the secondary location is temporarily
                              unavailable. Known values are: "Live", "Bootstrap", and "Unavailable".
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isHnsEnabled": bool,  # Optional. Account HierarchicalNamespace
                          enabled if sets to true.
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isNfsV3Enabled": bool,  # Optional. NFS 3.0 protocol support enabled
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "isSkuConversionBlocked": bool,  # Optional. This property will be
                          set to true or false on an event of ongoing migration. Default value is null.
                        "keyCreationTime": {
                            "key1": "2020-02-20 00:00:00",  # Optional. Storage account
                              keys creation time.
                            "key2": "2020-02-20 00:00:00"  # Optional. Storage account
                              keys creation time.
                        },
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "lastGeoFailoverTime": "2020-02-20 00:00:00",  # Optional. Gets the
                          timestamp of the most recent instance of a failover to the secondary
                          location. Only the most recent timestamp is retained. This element is not
                          returned if there has never been a failover instance. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "primaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "primaryLocation": "str",  # Optional. Gets the location of the
                          primary data center for the storage account.
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateLinkServiceConnectionState": {
                                        "actionRequired": "str",  # Optional.
                                          A message indicating if changes on the service provider
                                          require any updates on the consumer.
                                        "description": "str",  # Optional.
                                          The reason for approval/rejection of the connection.
                                        "status": "str"  # Optional.
                                          Indicates whether the connection has been
                                          Approved/Rejected/Removed by the owner of the service. Known
                                          values are: "Pending", "Approved", and "Rejected".
                                    },
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. The ARM
                                          identifier for Private Endpoint.
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of the private endpoint connection resource.
                                      Known values are: "Succeeded", "Creating", "Deleting", and
                                      "Failed".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. Gets the status of the
                          storage account at the time the operation was called. Known values are:
                          "Creating", "ResolvingDNS", and "Succeeded".
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Known values are: "Enabled", "Disabled", and
                          "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "secondaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "secondaryLocation": "str",  # Optional. Gets the location of the
                          geo-replicated secondary for the storage account. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "statusOfPrimary": "str",  # Optional. Gets the status indicating
                          whether the primary location of the storage account is available or
                          unavailable. Known values are: "available" and "unavailable".
                        "statusOfSecondary": "str",  # Optional. Gets the status indicating
                          whether the secondary location of the storage account is available or
                          unavailable. Only available if the SKU name is Standard_GRS or
                          Standard_RAGRS. Known values are: "available" and "unavailable".
                        "storageAccountSkuConversionStatus": {
                            "endTime": "str",  # Optional. This property represents the
                              sku conversion end time.
                            "skuConversionStatus": "str",  # Optional. This property
                              indicates the current sku conversion status. Known values are:
                              "InProgress", "Succeeded", and "Failed".
                            "startTime": "str",  # Optional. This property represents the
                              sku conversion start time.
                            "targetSkuName": "str"  # Optional. This property represents
                              the target sku name to which the account sku is being converted
                              asynchronously. Known values are: "Standard_LRS", "Standard_GRS",
                              "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                              "Standard_GZRS", and "Standard_RAGZRS".
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true.
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                resource_group_name=resource_group_name,
                account_name=account_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> None:
        """Deletes a storage account in Microsoft Azure.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_storage_accounts_delete_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_properties(
        self, resource_group_name: str, account_name: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Returns the properties for the specified storage account including but not limited to name, SKU
        name, location, and account status. The ListKeys operation should be used to retrieve storage
        keys.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :keyword expand: May be used to expand the properties within account's properties. By default,
         data is not included when fetching properties. Currently we only support geoReplicationStats
         and blobRestoreStatus. Known values are: "geoReplicationStats" and "blobRestoreStatus". Default
         value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # Optional. The name of the extended location.
                        "type": "str"  # Optional. The type of the extended location.
                          "EdgeZone"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Gets the Kind. Known values are: "Storage",
                      "StorageV2", "BlobStorage", "FileStorage", and "BlockBlobStorage".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "accountMigrationInProgress": bool,  # Optional. If customer
                          initiated account migration is in progress, the value will be true else it
                          will be null.
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "blobRestoreStatus": {
                            "failureReason": "str",  # Optional. Failure reason when blob
                              restore is failed.
                            "parameters": {
                                "blobRanges": [
                                    {
                                        "endRange": "str",  # Blob end range.
                                          This is exclusive. Empty means account end. Required.
                                        "startRange": "str"  # Blob start
                                          range. This is inclusive. Empty means account start.
                                          Required.
                                    }
                                ],
                                "timeToRestore": "2020-02-20 00:00:00"  # Restore
                                  blob to the specified time. Required.
                            },
                            "restoreId": "str",  # Optional. Id for tracking blob restore
                              request.
                            "status": "str"  # Optional. The status of blob restore
                              progress. Possible values are: - InProgress: Indicates that blob restore
                              is ongoing. - Complete: Indicates that blob restore has been completed
                              successfully. - Failed: Indicates that blob restore is failed. Known
                              values are: "InProgress", "Complete", and "Failed".
                        },
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the storage account in UTC.
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "failoverInProgress": bool,  # Optional. If the failover is in
                          progress, the value will be true, otherwise, it will be null.
                        "geoReplicationStats": {
                            "canFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not account failover is supported for the account.
                            "canPlannedFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not planned account failover is supported for the
                              account.
                            "lastSyncTime": "2020-02-20 00:00:00",  # Optional. All
                              primary writes preceding this UTC date/time value are guaranteed to be
                              available for read operations. Primary writes following this point in
                              time may or may not be available for reads. Element may be default value
                              if value of LastSyncTime is not available, this can happen if secondary
                              is offline or we are in bootstrap.
                            "postFailoverRedundancy": "str",  # Optional. The redundancy
                              type of the account after an account failover is performed. Known values
                              are: "Standard_LRS" and "Standard_ZRS".
                            "postPlannedFailoverRedundancy": "str",  # Optional. The
                              redundancy type of the account after a planned account failover is
                              performed. Known values are: "Standard_GRS", "Standard_GZRS",
                              "Standard_RAGRS", and "Standard_RAGZRS".
                            "status": "str"  # Optional. The status of the secondary
                              location. Possible values are: - Live: Indicates that the secondary
                              location is active and operational. - Bootstrap: Indicates initial
                              synchronization from the primary location to the secondary location is in
                              progress.This typically occurs when replication is first enabled. -
                              Unavailable: Indicates that the secondary location is temporarily
                              unavailable. Known values are: "Live", "Bootstrap", and "Unavailable".
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isHnsEnabled": bool,  # Optional. Account HierarchicalNamespace
                          enabled if sets to true.
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isNfsV3Enabled": bool,  # Optional. NFS 3.0 protocol support enabled
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "isSkuConversionBlocked": bool,  # Optional. This property will be
                          set to true or false on an event of ongoing migration. Default value is null.
                        "keyCreationTime": {
                            "key1": "2020-02-20 00:00:00",  # Optional. Storage account
                              keys creation time.
                            "key2": "2020-02-20 00:00:00"  # Optional. Storage account
                              keys creation time.
                        },
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "lastGeoFailoverTime": "2020-02-20 00:00:00",  # Optional. Gets the
                          timestamp of the most recent instance of a failover to the secondary
                          location. Only the most recent timestamp is retained. This element is not
                          returned if there has never been a failover instance. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "primaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "primaryLocation": "str",  # Optional. Gets the location of the
                          primary data center for the storage account.
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateLinkServiceConnectionState": {
                                        "actionRequired": "str",  # Optional.
                                          A message indicating if changes on the service provider
                                          require any updates on the consumer.
                                        "description": "str",  # Optional.
                                          The reason for approval/rejection of the connection.
                                        "status": "str"  # Optional.
                                          Indicates whether the connection has been
                                          Approved/Rejected/Removed by the owner of the service. Known
                                          values are: "Pending", "Approved", and "Rejected".
                                    },
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. The ARM
                                          identifier for Private Endpoint.
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of the private endpoint connection resource.
                                      Known values are: "Succeeded", "Creating", "Deleting", and
                                      "Failed".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. Gets the status of the
                          storage account at the time the operation was called. Known values are:
                          "Creating", "ResolvingDNS", and "Succeeded".
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Known values are: "Enabled", "Disabled", and
                          "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "secondaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "secondaryLocation": "str",  # Optional. Gets the location of the
                          geo-replicated secondary for the storage account. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "statusOfPrimary": "str",  # Optional. Gets the status indicating
                          whether the primary location of the storage account is available or
                          unavailable. Known values are: "available" and "unavailable".
                        "statusOfSecondary": "str",  # Optional. Gets the status indicating
                          whether the secondary location of the storage account is available or
                          unavailable. Only available if the SKU name is Standard_GRS or
                          Standard_RAGRS. Known values are: "available" and "unavailable".
                        "storageAccountSkuConversionStatus": {
                            "endTime": "str",  # Optional. This property represents the
                              sku conversion end time.
                            "skuConversionStatus": "str",  # Optional. This property
                              indicates the current sku conversion status. Known values are:
                              "InProgress", "Succeeded", and "Failed".
                            "startTime": "str",  # Optional. This property represents the
                              sku conversion start time.
                            "targetSkuName": "str"  # Optional. This property represents
                              the target sku name to which the account sku is being converted
                              asynchronously. Known values are: "Standard_LRS", "Standard_GRS",
                              "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                              "Standard_GZRS", and "Standard_RAGZRS".
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true.
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_storage_accounts_get_properties_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def update(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """The update operation can be used to update the SKU, encryption, access tier, or tags for a
        storage account. It can also be used to map the account to a custom domain. Only one custom
        domain is supported per storage account; the replacement/change of custom domain is not
        supported. In order to replace an old custom domain, the old value must be cleared/unregistered
        before a new value can be set. The update of multiple properties is supported. This call does
        not change the storage keys for the account. If you want to change the storage account keys,
        use the regenerate keys operation. The location and name of the storage account cannot be
        changed after creation.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide for the updated account. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Optional. Indicates the type of storage account.
                      Currently only StorageV2 value supported by server. Known values are: "Storage",
                      "StorageV2", "BlobStorage", "FileStorage", and "BlockBlobStorage".
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Value is optional but if passed in, must be 'Enabled',
                          'Disabled' or 'SecuredByPerimeter'. Known values are: "Enabled", "Disabled",
                          and "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true.
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets a list of key value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater in length than 128 characters
                          and a value no greater in length than 256 characters.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # Optional. The name of the extended location.
                        "type": "str"  # Optional. The type of the extended location.
                          "EdgeZone"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Gets the Kind. Known values are: "Storage",
                      "StorageV2", "BlobStorage", "FileStorage", and "BlockBlobStorage".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "accountMigrationInProgress": bool,  # Optional. If customer
                          initiated account migration is in progress, the value will be true else it
                          will be null.
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "blobRestoreStatus": {
                            "failureReason": "str",  # Optional. Failure reason when blob
                              restore is failed.
                            "parameters": {
                                "blobRanges": [
                                    {
                                        "endRange": "str",  # Blob end range.
                                          This is exclusive. Empty means account end. Required.
                                        "startRange": "str"  # Blob start
                                          range. This is inclusive. Empty means account start.
                                          Required.
                                    }
                                ],
                                "timeToRestore": "2020-02-20 00:00:00"  # Restore
                                  blob to the specified time. Required.
                            },
                            "restoreId": "str",  # Optional. Id for tracking blob restore
                              request.
                            "status": "str"  # Optional. The status of blob restore
                              progress. Possible values are: - InProgress: Indicates that blob restore
                              is ongoing. - Complete: Indicates that blob restore has been completed
                              successfully. - Failed: Indicates that blob restore is failed. Known
                              values are: "InProgress", "Complete", and "Failed".
                        },
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the storage account in UTC.
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "failoverInProgress": bool,  # Optional. If the failover is in
                          progress, the value will be true, otherwise, it will be null.
                        "geoReplicationStats": {
                            "canFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not account failover is supported for the account.
                            "canPlannedFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not planned account failover is supported for the
                              account.
                            "lastSyncTime": "2020-02-20 00:00:00",  # Optional. All
                              primary writes preceding this UTC date/time value are guaranteed to be
                              available for read operations. Primary writes following this point in
                              time may or may not be available for reads. Element may be default value
                              if value of LastSyncTime is not available, this can happen if secondary
                              is offline or we are in bootstrap.
                            "postFailoverRedundancy": "str",  # Optional. The redundancy
                              type of the account after an account failover is performed. Known values
                              are: "Standard_LRS" and "Standard_ZRS".
                            "postPlannedFailoverRedundancy": "str",  # Optional. The
                              redundancy type of the account after a planned account failover is
                              performed. Known values are: "Standard_GRS", "Standard_GZRS",
                              "Standard_RAGRS", and "Standard_RAGZRS".
                            "status": "str"  # Optional. The status of the secondary
                              location. Possible values are: - Live: Indicates that the secondary
                              location is active and operational. - Bootstrap: Indicates initial
                              synchronization from the primary location to the secondary location is in
                              progress.This typically occurs when replication is first enabled. -
                              Unavailable: Indicates that the secondary location is temporarily
                              unavailable. Known values are: "Live", "Bootstrap", and "Unavailable".
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isHnsEnabled": bool,  # Optional. Account HierarchicalNamespace
                          enabled if sets to true.
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isNfsV3Enabled": bool,  # Optional. NFS 3.0 protocol support enabled
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "isSkuConversionBlocked": bool,  # Optional. This property will be
                          set to true or false on an event of ongoing migration. Default value is null.
                        "keyCreationTime": {
                            "key1": "2020-02-20 00:00:00",  # Optional. Storage account
                              keys creation time.
                            "key2": "2020-02-20 00:00:00"  # Optional. Storage account
                              keys creation time.
                        },
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "lastGeoFailoverTime": "2020-02-20 00:00:00",  # Optional. Gets the
                          timestamp of the most recent instance of a failover to the secondary
                          location. Only the most recent timestamp is retained. This element is not
                          returned if there has never been a failover instance. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "primaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "primaryLocation": "str",  # Optional. Gets the location of the
                          primary data center for the storage account.
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateLinkServiceConnectionState": {
                                        "actionRequired": "str",  # Optional.
                                          A message indicating if changes on the service provider
                                          require any updates on the consumer.
                                        "description": "str",  # Optional.
                                          The reason for approval/rejection of the connection.
                                        "status": "str"  # Optional.
                                          Indicates whether the connection has been
                                          Approved/Rejected/Removed by the owner of the service. Known
                                          values are: "Pending", "Approved", and "Rejected".
                                    },
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. The ARM
                                          identifier for Private Endpoint.
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of the private endpoint connection resource.
                                      Known values are: "Succeeded", "Creating", "Deleting", and
                                      "Failed".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. Gets the status of the
                          storage account at the time the operation was called. Known values are:
                          "Creating", "ResolvingDNS", and "Succeeded".
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Known values are: "Enabled", "Disabled", and
                          "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "secondaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "secondaryLocation": "str",  # Optional. Gets the location of the
                          geo-replicated secondary for the storage account. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "statusOfPrimary": "str",  # Optional. Gets the status indicating
                          whether the primary location of the storage account is available or
                          unavailable. Known values are: "available" and "unavailable".
                        "statusOfSecondary": "str",  # Optional. Gets the status indicating
                          whether the secondary location of the storage account is available or
                          unavailable. Only available if the SKU name is Standard_GRS or
                          Standard_RAGRS. Known values are: "available" and "unavailable".
                        "storageAccountSkuConversionStatus": {
                            "endTime": "str",  # Optional. This property represents the
                              sku conversion end time.
                            "skuConversionStatus": "str",  # Optional. This property
                              indicates the current sku conversion status. Known values are:
                              "InProgress", "Succeeded", and "Failed".
                            "startTime": "str",  # Optional. This property represents the
                              sku conversion start time.
                            "targetSkuName": "str"  # Optional. This property represents
                              the target sku name to which the account sku is being converted
                              asynchronously. Known values are: "Standard_LRS", "Standard_GRS",
                              "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                              "Standard_GZRS", and "Standard_RAGZRS".
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true.
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def update(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """The update operation can be used to update the SKU, encryption, access tier, or tags for a
        storage account. It can also be used to map the account to a custom domain. Only one custom
        domain is supported per storage account; the replacement/change of custom domain is not
        supported. In order to replace an old custom domain, the old value must be cleared/unregistered
        before a new value can be set. The update of multiple properties is supported. This call does
        not change the storage keys for the account. If you want to change the storage account keys,
        use the regenerate keys operation. The location and name of the storage account cannot be
        changed after creation.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide for the updated account. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # Optional. The name of the extended location.
                        "type": "str"  # Optional. The type of the extended location.
                          "EdgeZone"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Gets the Kind. Known values are: "Storage",
                      "StorageV2", "BlobStorage", "FileStorage", and "BlockBlobStorage".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "accountMigrationInProgress": bool,  # Optional. If customer
                          initiated account migration is in progress, the value will be true else it
                          will be null.
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "blobRestoreStatus": {
                            "failureReason": "str",  # Optional. Failure reason when blob
                              restore is failed.
                            "parameters": {
                                "blobRanges": [
                                    {
                                        "endRange": "str",  # Blob end range.
                                          This is exclusive. Empty means account end. Required.
                                        "startRange": "str"  # Blob start
                                          range. This is inclusive. Empty means account start.
                                          Required.
                                    }
                                ],
                                "timeToRestore": "2020-02-20 00:00:00"  # Restore
                                  blob to the specified time. Required.
                            },
                            "restoreId": "str",  # Optional. Id for tracking blob restore
                              request.
                            "status": "str"  # Optional. The status of blob restore
                              progress. Possible values are: - InProgress: Indicates that blob restore
                              is ongoing. - Complete: Indicates that blob restore has been completed
                              successfully. - Failed: Indicates that blob restore is failed. Known
                              values are: "InProgress", "Complete", and "Failed".
                        },
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the storage account in UTC.
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "failoverInProgress": bool,  # Optional. If the failover is in
                          progress, the value will be true, otherwise, it will be null.
                        "geoReplicationStats": {
                            "canFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not account failover is supported for the account.
                            "canPlannedFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not planned account failover is supported for the
                              account.
                            "lastSyncTime": "2020-02-20 00:00:00",  # Optional. All
                              primary writes preceding this UTC date/time value are guaranteed to be
                              available for read operations. Primary writes following this point in
                              time may or may not be available for reads. Element may be default value
                              if value of LastSyncTime is not available, this can happen if secondary
                              is offline or we are in bootstrap.
                            "postFailoverRedundancy": "str",  # Optional. The redundancy
                              type of the account after an account failover is performed. Known values
                              are: "Standard_LRS" and "Standard_ZRS".
                            "postPlannedFailoverRedundancy": "str",  # Optional. The
                              redundancy type of the account after a planned account failover is
                              performed. Known values are: "Standard_GRS", "Standard_GZRS",
                              "Standard_RAGRS", and "Standard_RAGZRS".
                            "status": "str"  # Optional. The status of the secondary
                              location. Possible values are: - Live: Indicates that the secondary
                              location is active and operational. - Bootstrap: Indicates initial
                              synchronization from the primary location to the secondary location is in
                              progress.This typically occurs when replication is first enabled. -
                              Unavailable: Indicates that the secondary location is temporarily
                              unavailable. Known values are: "Live", "Bootstrap", and "Unavailable".
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isHnsEnabled": bool,  # Optional. Account HierarchicalNamespace
                          enabled if sets to true.
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isNfsV3Enabled": bool,  # Optional. NFS 3.0 protocol support enabled
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "isSkuConversionBlocked": bool,  # Optional. This property will be
                          set to true or false on an event of ongoing migration. Default value is null.
                        "keyCreationTime": {
                            "key1": "2020-02-20 00:00:00",  # Optional. Storage account
                              keys creation time.
                            "key2": "2020-02-20 00:00:00"  # Optional. Storage account
                              keys creation time.
                        },
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "lastGeoFailoverTime": "2020-02-20 00:00:00",  # Optional. Gets the
                          timestamp of the most recent instance of a failover to the secondary
                          location. Only the most recent timestamp is retained. This element is not
                          returned if there has never been a failover instance. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "primaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "primaryLocation": "str",  # Optional. Gets the location of the
                          primary data center for the storage account.
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateLinkServiceConnectionState": {
                                        "actionRequired": "str",  # Optional.
                                          A message indicating if changes on the service provider
                                          require any updates on the consumer.
                                        "description": "str",  # Optional.
                                          The reason for approval/rejection of the connection.
                                        "status": "str"  # Optional.
                                          Indicates whether the connection has been
                                          Approved/Rejected/Removed by the owner of the service. Known
                                          values are: "Pending", "Approved", and "Rejected".
                                    },
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. The ARM
                                          identifier for Private Endpoint.
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of the private endpoint connection resource.
                                      Known values are: "Succeeded", "Creating", "Deleting", and
                                      "Failed".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. Gets the status of the
                          storage account at the time the operation was called. Known values are:
                          "Creating", "ResolvingDNS", and "Succeeded".
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Known values are: "Enabled", "Disabled", and
                          "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "secondaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "secondaryLocation": "str",  # Optional. Gets the location of the
                          geo-replicated secondary for the storage account. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "statusOfPrimary": "str",  # Optional. Gets the status indicating
                          whether the primary location of the storage account is available or
                          unavailable. Known values are: "available" and "unavailable".
                        "statusOfSecondary": "str",  # Optional. Gets the status indicating
                          whether the secondary location of the storage account is available or
                          unavailable. Only available if the SKU name is Standard_GRS or
                          Standard_RAGRS. Known values are: "available" and "unavailable".
                        "storageAccountSkuConversionStatus": {
                            "endTime": "str",  # Optional. This property represents the
                              sku conversion end time.
                            "skuConversionStatus": "str",  # Optional. This property
                              indicates the current sku conversion status. Known values are:
                              "InProgress", "Succeeded", and "Failed".
                            "startTime": "str",  # Optional. This property represents the
                              sku conversion start time.
                            "targetSkuName": "str"  # Optional. This property represents
                              the target sku name to which the account sku is being converted
                              asynchronously. Known values are: "Standard_LRS", "Standard_GRS",
                              "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                              "Standard_GZRS", and "Standard_RAGZRS".
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true.
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def update(self, resource_group_name: str, account_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """The update operation can be used to update the SKU, encryption, access tier, or tags for a
        storage account. It can also be used to map the account to a custom domain. Only one custom
        domain is supported per storage account; the replacement/change of custom domain is not
        supported. In order to replace an old custom domain, the old value must be cleared/unregistered
        before a new value can be set. The update of multiple properties is supported. This call does
        not change the storage keys for the account. If you want to change the storage account keys,
        use the regenerate keys operation. The location and name of the storage account cannot be
        changed after creation.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide for the updated account. Is either a JSON type or
         a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Optional. Indicates the type of storage account.
                      Currently only StorageV2 value supported by server. Known values are: "Storage",
                      "StorageV2", "BlobStorage", "FileStorage", and "BlockBlobStorage".
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Value is optional but if passed in, must be 'Enabled',
                          'Disabled' or 'SecuredByPerimeter'. Known values are: "Enabled", "Disabled",
                          and "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true.
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Gets or sets a list of key value pairs that
                          describe the resource. These tags can be used in viewing and grouping this
                          resource (across resource groups). A maximum of 15 tags can be provided for a
                          resource. Each tag must have a key no greater in length than 128 characters
                          and a value no greater in length than 256 characters.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # Optional. The name of the extended location.
                        "type": "str"  # Optional. The type of the extended location.
                          "EdgeZone"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Gets the Kind. Known values are: "Storage",
                      "StorageV2", "BlobStorage", "FileStorage", and "BlockBlobStorage".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "accountMigrationInProgress": bool,  # Optional. If customer
                          initiated account migration is in progress, the value will be true else it
                          will be null.
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "blobRestoreStatus": {
                            "failureReason": "str",  # Optional. Failure reason when blob
                              restore is failed.
                            "parameters": {
                                "blobRanges": [
                                    {
                                        "endRange": "str",  # Blob end range.
                                          This is exclusive. Empty means account end. Required.
                                        "startRange": "str"  # Blob start
                                          range. This is inclusive. Empty means account start.
                                          Required.
                                    }
                                ],
                                "timeToRestore": "2020-02-20 00:00:00"  # Restore
                                  blob to the specified time. Required.
                            },
                            "restoreId": "str",  # Optional. Id for tracking blob restore
                              request.
                            "status": "str"  # Optional. The status of blob restore
                              progress. Possible values are: - InProgress: Indicates that blob restore
                              is ongoing. - Complete: Indicates that blob restore has been completed
                              successfully. - Failed: Indicates that blob restore is failed. Known
                              values are: "InProgress", "Complete", and "Failed".
                        },
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the storage account in UTC.
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "failoverInProgress": bool,  # Optional. If the failover is in
                          progress, the value will be true, otherwise, it will be null.
                        "geoReplicationStats": {
                            "canFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not account failover is supported for the account.
                            "canPlannedFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not planned account failover is supported for the
                              account.
                            "lastSyncTime": "2020-02-20 00:00:00",  # Optional. All
                              primary writes preceding this UTC date/time value are guaranteed to be
                              available for read operations. Primary writes following this point in
                              time may or may not be available for reads. Element may be default value
                              if value of LastSyncTime is not available, this can happen if secondary
                              is offline or we are in bootstrap.
                            "postFailoverRedundancy": "str",  # Optional. The redundancy
                              type of the account after an account failover is performed. Known values
                              are: "Standard_LRS" and "Standard_ZRS".
                            "postPlannedFailoverRedundancy": "str",  # Optional. The
                              redundancy type of the account after a planned account failover is
                              performed. Known values are: "Standard_GRS", "Standard_GZRS",
                              "Standard_RAGRS", and "Standard_RAGZRS".
                            "status": "str"  # Optional. The status of the secondary
                              location. Possible values are: - Live: Indicates that the secondary
                              location is active and operational. - Bootstrap: Indicates initial
                              synchronization from the primary location to the secondary location is in
                              progress.This typically occurs when replication is first enabled. -
                              Unavailable: Indicates that the secondary location is temporarily
                              unavailable. Known values are: "Live", "Bootstrap", and "Unavailable".
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isHnsEnabled": bool,  # Optional. Account HierarchicalNamespace
                          enabled if sets to true.
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isNfsV3Enabled": bool,  # Optional. NFS 3.0 protocol support enabled
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "isSkuConversionBlocked": bool,  # Optional. This property will be
                          set to true or false on an event of ongoing migration. Default value is null.
                        "keyCreationTime": {
                            "key1": "2020-02-20 00:00:00",  # Optional. Storage account
                              keys creation time.
                            "key2": "2020-02-20 00:00:00"  # Optional. Storage account
                              keys creation time.
                        },
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "lastGeoFailoverTime": "2020-02-20 00:00:00",  # Optional. Gets the
                          timestamp of the most recent instance of a failover to the secondary
                          location. Only the most recent timestamp is retained. This element is not
                          returned if there has never been a failover instance. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "primaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "primaryLocation": "str",  # Optional. Gets the location of the
                          primary data center for the storage account.
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateLinkServiceConnectionState": {
                                        "actionRequired": "str",  # Optional.
                                          A message indicating if changes on the service provider
                                          require any updates on the consumer.
                                        "description": "str",  # Optional.
                                          The reason for approval/rejection of the connection.
                                        "status": "str"  # Optional.
                                          Indicates whether the connection has been
                                          Approved/Rejected/Removed by the owner of the service. Known
                                          values are: "Pending", "Approved", and "Rejected".
                                    },
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. The ARM
                                          identifier for Private Endpoint.
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of the private endpoint connection resource.
                                      Known values are: "Succeeded", "Creating", "Deleting", and
                                      "Failed".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. Gets the status of the
                          storage account at the time the operation was called. Known values are:
                          "Creating", "ResolvingDNS", and "Succeeded".
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Known values are: "Enabled", "Disabled", and
                          "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "secondaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "secondaryLocation": "str",  # Optional. Gets the location of the
                          geo-replicated secondary for the storage account. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "statusOfPrimary": "str",  # Optional. Gets the status indicating
                          whether the primary location of the storage account is available or
                          unavailable. Known values are: "available" and "unavailable".
                        "statusOfSecondary": "str",  # Optional. Gets the status indicating
                          whether the secondary location of the storage account is available or
                          unavailable. Only available if the SKU name is Standard_GRS or
                          Standard_RAGRS. Known values are: "available" and "unavailable".
                        "storageAccountSkuConversionStatus": {
                            "endTime": "str",  # Optional. This property represents the
                              sku conversion end time.
                            "skuConversionStatus": "str",  # Optional. This property
                              indicates the current sku conversion status. Known values are:
                              "InProgress", "Succeeded", and "Failed".
                            "startTime": "str",  # Optional. This property represents the
                              sku conversion start time.
                            "targetSkuName": "str"  # Optional. This property represents
                              the target sku name to which the account sku is being converted
                              asynchronously. Known values are: "Standard_LRS", "Standard_GRS",
                              "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                              "Standard_GZRS", and "Standard_RAGZRS".
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true.
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_storage_accounts_update_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists all the storage accounts available under the subscription. Note that storage keys are not
        returned; use the ListKeys operation for this.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # Optional. The name of the extended location.
                        "type": "str"  # Optional. The type of the extended location.
                          "EdgeZone"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Gets the Kind. Known values are: "Storage",
                      "StorageV2", "BlobStorage", "FileStorage", and "BlockBlobStorage".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "accountMigrationInProgress": bool,  # Optional. If customer
                          initiated account migration is in progress, the value will be true else it
                          will be null.
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "blobRestoreStatus": {
                            "failureReason": "str",  # Optional. Failure reason when blob
                              restore is failed.
                            "parameters": {
                                "blobRanges": [
                                    {
                                        "endRange": "str",  # Blob end range.
                                          This is exclusive. Empty means account end. Required.
                                        "startRange": "str"  # Blob start
                                          range. This is inclusive. Empty means account start.
                                          Required.
                                    }
                                ],
                                "timeToRestore": "2020-02-20 00:00:00"  # Restore
                                  blob to the specified time. Required.
                            },
                            "restoreId": "str",  # Optional. Id for tracking blob restore
                              request.
                            "status": "str"  # Optional. The status of blob restore
                              progress. Possible values are: - InProgress: Indicates that blob restore
                              is ongoing. - Complete: Indicates that blob restore has been completed
                              successfully. - Failed: Indicates that blob restore is failed. Known
                              values are: "InProgress", "Complete", and "Failed".
                        },
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the storage account in UTC.
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "failoverInProgress": bool,  # Optional. If the failover is in
                          progress, the value will be true, otherwise, it will be null.
                        "geoReplicationStats": {
                            "canFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not account failover is supported for the account.
                            "canPlannedFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not planned account failover is supported for the
                              account.
                            "lastSyncTime": "2020-02-20 00:00:00",  # Optional. All
                              primary writes preceding this UTC date/time value are guaranteed to be
                              available for read operations. Primary writes following this point in
                              time may or may not be available for reads. Element may be default value
                              if value of LastSyncTime is not available, this can happen if secondary
                              is offline or we are in bootstrap.
                            "postFailoverRedundancy": "str",  # Optional. The redundancy
                              type of the account after an account failover is performed. Known values
                              are: "Standard_LRS" and "Standard_ZRS".
                            "postPlannedFailoverRedundancy": "str",  # Optional. The
                              redundancy type of the account after a planned account failover is
                              performed. Known values are: "Standard_GRS", "Standard_GZRS",
                              "Standard_RAGRS", and "Standard_RAGZRS".
                            "status": "str"  # Optional. The status of the secondary
                              location. Possible values are: - Live: Indicates that the secondary
                              location is active and operational. - Bootstrap: Indicates initial
                              synchronization from the primary location to the secondary location is in
                              progress.This typically occurs when replication is first enabled. -
                              Unavailable: Indicates that the secondary location is temporarily
                              unavailable. Known values are: "Live", "Bootstrap", and "Unavailable".
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isHnsEnabled": bool,  # Optional. Account HierarchicalNamespace
                          enabled if sets to true.
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isNfsV3Enabled": bool,  # Optional. NFS 3.0 protocol support enabled
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "isSkuConversionBlocked": bool,  # Optional. This property will be
                          set to true or false on an event of ongoing migration. Default value is null.
                        "keyCreationTime": {
                            "key1": "2020-02-20 00:00:00",  # Optional. Storage account
                              keys creation time.
                            "key2": "2020-02-20 00:00:00"  # Optional. Storage account
                              keys creation time.
                        },
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "lastGeoFailoverTime": "2020-02-20 00:00:00",  # Optional. Gets the
                          timestamp of the most recent instance of a failover to the secondary
                          location. Only the most recent timestamp is retained. This element is not
                          returned if there has never been a failover instance. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "primaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "primaryLocation": "str",  # Optional. Gets the location of the
                          primary data center for the storage account.
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateLinkServiceConnectionState": {
                                        "actionRequired": "str",  # Optional.
                                          A message indicating if changes on the service provider
                                          require any updates on the consumer.
                                        "description": "str",  # Optional.
                                          The reason for approval/rejection of the connection.
                                        "status": "str"  # Optional.
                                          Indicates whether the connection has been
                                          Approved/Rejected/Removed by the owner of the service. Known
                                          values are: "Pending", "Approved", and "Rejected".
                                    },
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. The ARM
                                          identifier for Private Endpoint.
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of the private endpoint connection resource.
                                      Known values are: "Succeeded", "Creating", "Deleting", and
                                      "Failed".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. Gets the status of the
                          storage account at the time the operation was called. Known values are:
                          "Creating", "ResolvingDNS", and "Succeeded".
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Known values are: "Enabled", "Disabled", and
                          "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "secondaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "secondaryLocation": "str",  # Optional. Gets the location of the
                          geo-replicated secondary for the storage account. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "statusOfPrimary": "str",  # Optional. Gets the status indicating
                          whether the primary location of the storage account is available or
                          unavailable. Known values are: "available" and "unavailable".
                        "statusOfSecondary": "str",  # Optional. Gets the status indicating
                          whether the secondary location of the storage account is available or
                          unavailable. Only available if the SKU name is Standard_GRS or
                          Standard_RAGRS. Known values are: "available" and "unavailable".
                        "storageAccountSkuConversionStatus": {
                            "endTime": "str",  # Optional. This property represents the
                              sku conversion end time.
                            "skuConversionStatus": "str",  # Optional. This property
                              indicates the current sku conversion status. Known values are:
                              "InProgress", "Succeeded", and "Failed".
                            "startTime": "str",  # Optional. This property represents the
                              sku conversion start time.
                            "targetSkuName": "str"  # Optional. This property represents
                              the target sku name to which the account sku is being converted
                              asynchronously. Known values are: "Standard_LRS", "Standard_GRS",
                              "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                              "Standard_GZRS", and "Standard_RAGZRS".
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true.
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_storage_accounts_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all the storage accounts available under the given resource group. Note that storage keys
        are not returned; use the ListKeys operation for this.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "extendedLocation": {
                        "name": "str",  # Optional. The name of the extended location.
                        "type": "str"  # Optional. The type of the extended location.
                          "EdgeZone"
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "identity": {
                        "type": "str",  # The identity type. Required. Known values are:
                          "None", "SystemAssigned", "UserAssigned", and "SystemAssigned,UserAssigned".
                        "principalId": "str",  # Optional. The principal ID of resource
                          identity.
                        "tenantId": "str",  # Optional. The tenant ID of resource.
                        "userAssignedIdentities": {
                            "str": {
                                "clientId": "str",  # Optional. The client ID of the
                                  identity.
                                "principalId": "str"  # Optional. The principal ID of
                                  the identity.
                            }
                        }
                    },
                    "kind": "str",  # Optional. Gets the Kind. Known values are: "Storage",
                      "StorageV2", "BlobStorage", "FileStorage", and "BlockBlobStorage".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "accessTier": "str",  # Optional. Required for storage accounts where
                          kind = BlobStorage. The access tier is used for billing. The 'Premium' access
                          tier is the default value for premium block blobs storage account type and it
                          cannot be changed for the premium block blobs storage account type. Known
                          values are: "Hot", "Cool", "Premium", and "Cold".
                        "accountMigrationInProgress": bool,  # Optional. If customer
                          initiated account migration is in progress, the value will be true else it
                          will be null.
                        "allowBlobPublicAccess": bool,  # Optional. Allow or disallow public
                          access to all blobs or containers in the storage account. The default
                          interpretation is false for this property.
                        "allowCrossTenantReplication": bool,  # Optional. Allow or disallow
                          cross AAD tenant object replication. Set this property to true for new or
                          existing accounts only if object replication policies will involve storage
                          accounts in different AAD tenants. The default interpretation is false for
                          new accounts to follow best security practices by default.
                        "allowSharedKeyAccess": bool,  # Optional. Indicates whether the
                          storage account permits requests to be authorized with the account access key
                          via Shared Key. If false, then all requests, including shared access
                          signatures, must be authorized with Azure Active Directory (Azure AD). The
                          default value is null, which is equivalent to true.
                        "allowedCopyScope": "str",  # Optional. Restrict copy to and from
                          Storage Accounts within an AAD tenant or with Private Links to the same VNet.
                          Known values are: "PrivateLink" and "AAD".
                        "azureFilesIdentityBasedAuthentication": {
                            "directoryServiceOptions": "str",  # Indicates the directory
                              service used. Note that this enum may be extended in the future.
                              Required. Known values are: "None", "AADDS", "AD", and "AADKERB".
                            "activeDirectoryProperties": {
                                "domainGuid": "str",  # Specifies the domain GUID.
                                  Required.
                                "domainName": "str",  # Specifies the primary domain
                                  that the AD DNS server is authoritative for. Required.
                                "accountType": "str",  # Optional. Specifies the
                                  Active Directory account type for Azure Storage. Known values are:
                                  "User" and "Computer".
                                "azureStorageSid": "str",  # Optional. Specifies the
                                  security identifier (SID) for Azure Storage.
                                "domainSid": "str",  # Optional. Specifies the
                                  security identifier (SID).
                                "forestName": "str",  # Optional. Specifies the
                                  Active Directory forest to get.
                                "netBiosDomainName": "str",  # Optional. Specifies
                                  the NetBIOS domain name.
                                "samAccountName": "str"  # Optional. Specifies the
                                  Active Directory SAMAccountName for Azure Storage.
                            },
                            "defaultSharePermission": "str"  # Optional. Default share
                              permission for users using Kerberos authentication if RBAC role is not
                              assigned. Known values are: "None", "StorageFileDataSmbShareReader",
                              "StorageFileDataSmbShareContributor", and
                              "StorageFileDataSmbShareElevatedContributor".
                        },
                        "blobRestoreStatus": {
                            "failureReason": "str",  # Optional. Failure reason when blob
                              restore is failed.
                            "parameters": {
                                "blobRanges": [
                                    {
                                        "endRange": "str",  # Blob end range.
                                          This is exclusive. Empty means account end. Required.
                                        "startRange": "str"  # Blob start
                                          range. This is inclusive. Empty means account start.
                                          Required.
                                    }
                                ],
                                "timeToRestore": "2020-02-20 00:00:00"  # Restore
                                  blob to the specified time. Required.
                            },
                            "restoreId": "str",  # Optional. Id for tracking blob restore
                              request.
                            "status": "str"  # Optional. The status of blob restore
                              progress. Possible values are: - InProgress: Indicates that blob restore
                              is ongoing. - Complete: Indicates that blob restore has been completed
                              successfully. - Failed: Indicates that blob restore is failed. Known
                              values are: "InProgress", "Complete", and "Failed".
                        },
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the storage account in UTC.
                        "customDomain": {
                            "name": "str",  # Gets or sets the custom domain name
                              assigned to the storage account. Name is the CNAME source. Required.
                            "useSubDomainName": bool  # Optional. Indicates whether
                              indirect CName validation is enabled. Default value is false. This should
                              only be set on updates.
                        },
                        "defaultToOAuthAuthentication": bool,  # Optional. A boolean flag
                          which indicates whether the default authentication is OAuth or not. The
                          default interpretation is false for this property.
                        "dnsEndpointType": "str",  # Optional. Allows you to specify the type
                          of endpoint. Set this to AzureDNSZone to create a large number of accounts in
                          a single subscription, which creates accounts in an Azure DNS Zone and the
                          endpoint URL will have an alphanumeric DNS Zone identifier. Known values are:
                          "Standard" and "AzureDnsZone".
                        "enableExtendedGroups": bool,  # Optional. Enables extended group
                          support with local users feature, if set to true.
                        "encryption": {
                            "identity": {
                                "federatedIdentityClientId": "str",  # Optional.
                                  ClientId of the multi-tenant application to be used in conjunction
                                  with the user-assigned identity for cross-tenant
                                  customer-managed-keys server-side encryption on the storage account.
                                "userAssignedIdentity": "str"  # Optional. Resource
                                  identifier of the UserAssigned identity to be associated with
                                  server-side encryption on the storage account.
                            },
                            "keySource": "Microsoft.Storage",  # Optional. Default value
                              is "Microsoft.Storage". The encryption keySource (provider). Possible
                              values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault. Known
                              values are: "Microsoft.Storage" and "Microsoft.Keyvault".
                            "keyvaultproperties": {
                                "currentVersionedKeyExpirationTimestamp": "2020-02-20
                                  00:00:00",  # Optional. This is a read only property that represents
                                  the expiration time of the current version of the customer managed
                                  key used for encryption.
                                "currentVersionedKeyIdentifier": "str",  # Optional.
                                  The object identifier of the current versioned Key Vault Key in use.
                                "keyname": "str",  # Optional. The name of KeyVault
                                  key.
                                "keyvaulturi": "str",  # Optional. The Uri of
                                  KeyVault.
                                "keyversion": "str",  # Optional. The version of
                                  KeyVault key.
                                "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                                  Optional. Timestamp of last rotation of the Key Vault Key.
                            },
                            "requireInfrastructureEncryption": bool,  # Optional. A
                              boolean indicating whether or not the service applies a secondary layer
                              of encryption with platform managed keys for data at rest.
                            "services": {
                                "blob": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "file": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "queue": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                },
                                "table": {
                                    "enabled": bool,  # Optional. A boolean
                                      indicating whether or not the service encrypts the data as it is
                                      stored. Encryption at rest is enabled by default today and cannot
                                      be disabled.
                                    "keyType": "str",  # Optional. Encryption key
                                      type to be used for the encryption service. 'Account' key type
                                      implies that an account-scoped encryption key will be used.
                                      'Service' key type implies that a default service key is used.
                                      Known values are: "Service" and "Account".
                                    "lastEnabledTime": "2020-02-20 00:00:00"  #
                                      Optional. Gets a rough estimate of the date/time when the
                                      encryption was last enabled by the user. Data is encrypted at
                                      rest by default today and cannot be disabled.
                                }
                            }
                        },
                        "failoverInProgress": bool,  # Optional. If the failover is in
                          progress, the value will be true, otherwise, it will be null.
                        "geoReplicationStats": {
                            "canFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not account failover is supported for the account.
                            "canPlannedFailover": bool,  # Optional. A boolean flag which
                              indicates whether or not planned account failover is supported for the
                              account.
                            "lastSyncTime": "2020-02-20 00:00:00",  # Optional. All
                              primary writes preceding this UTC date/time value are guaranteed to be
                              available for read operations. Primary writes following this point in
                              time may or may not be available for reads. Element may be default value
                              if value of LastSyncTime is not available, this can happen if secondary
                              is offline or we are in bootstrap.
                            "postFailoverRedundancy": "str",  # Optional. The redundancy
                              type of the account after an account failover is performed. Known values
                              are: "Standard_LRS" and "Standard_ZRS".
                            "postPlannedFailoverRedundancy": "str",  # Optional. The
                              redundancy type of the account after a planned account failover is
                              performed. Known values are: "Standard_GRS", "Standard_GZRS",
                              "Standard_RAGRS", and "Standard_RAGZRS".
                            "status": "str"  # Optional. The status of the secondary
                              location. Possible values are: - Live: Indicates that the secondary
                              location is active and operational. - Bootstrap: Indicates initial
                              synchronization from the primary location to the secondary location is in
                              progress.This typically occurs when replication is first enabled. -
                              Unavailable: Indicates that the secondary location is temporarily
                              unavailable. Known values are: "Live", "Bootstrap", and "Unavailable".
                        },
                        "immutableStorageWithVersioning": {
                            "enabled": bool,  # Optional. A boolean flag which enables
                              account-level immutability. All the containers under such an account have
                              object-level immutability enabled by default.
                            "immutabilityPolicy": {
                                "allowProtectedAppendWrites": bool,  # Optional. This
                                  property can only be changed for disabled and unlocked time-based
                                  retention policies. When enabled, new blocks can be written to an
                                  append blob while maintaining immutability protection and compliance.
                                  Only new blocks can be added and any existing blocks cannot be
                                  modified or deleted.
                                "immutabilityPeriodSinceCreationInDays": 0,  #
                                  Optional. The immutability period for the blobs in the container
                                  since the policy creation, in days.
                                "state": "str"  # Optional. The ImmutabilityPolicy
                                  state defines the mode of the policy. Disabled state disables the
                                  policy, Unlocked state allows increase and decrease of immutability
                                  retention time and also allows toggling allowProtectedAppendWrites
                                  property, Locked state only allows the increase of the immutability
                                  retention time. A policy can only be created in a Disabled or
                                  Unlocked state and can be toggled between the two states. Only a
                                  policy in an Unlocked state can transition to a Locked state which
                                  cannot be reverted. Known values are: "Unlocked", "Locked", and
                                  "Disabled".
                            }
                        },
                        "isHnsEnabled": bool,  # Optional. Account HierarchicalNamespace
                          enabled if sets to true.
                        "isLocalUserEnabled": bool,  # Optional. Enables local users feature,
                          if set to true.
                        "isNfsV3Enabled": bool,  # Optional. NFS 3.0 protocol support enabled
                          if set to true.
                        "isSftpEnabled": bool,  # Optional. Enables Secure File Transfer
                          Protocol, if set to true.
                        "isSkuConversionBlocked": bool,  # Optional. This property will be
                          set to true or false on an event of ongoing migration. Default value is null.
                        "keyCreationTime": {
                            "key1": "2020-02-20 00:00:00",  # Optional. Storage account
                              keys creation time.
                            "key2": "2020-02-20 00:00:00"  # Optional. Storage account
                              keys creation time.
                        },
                        "keyPolicy": {
                            "keyExpirationPeriodInDays": 0  # The key expiration period
                              in days. Required.
                        },
                        "largeFileSharesState": "str",  # Optional. Allow large file shares
                          if sets to Enabled. It cannot be disabled once it is enabled. Known values
                          are: "Disabled" and "Enabled".
                        "lastGeoFailoverTime": "2020-02-20 00:00:00",  # Optional. Gets the
                          timestamp of the most recent instance of a failover to the secondary
                          location. Only the most recent timestamp is retained. This element is not
                          returned if there has never been a failover instance. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "minimumTlsVersion": "str",  # Optional. Set the minimum TLS version
                          to be permitted on requests to storage. The default interpretation is TLS 1.0
                          for this property. Known values are: "TLS1_0", "TLS1_1", "TLS1_2", and
                          "TLS1_3".
                        "networkAcls": {
                            "defaultAction": "Allow",  # Default value is "Allow".
                              Specifies the default action of allow or deny when no other rules match.
                              Known values are: "Allow" and "Deny".
                            "bypass": "AzureServices",  # Optional. Default value is
                              "AzureServices". Specifies whether traffic is bypassed for
                              Logging/Metrics/AzureServices. Possible values are any combination of
                              Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None
                              to bypass none of those traffics. Known values are: "None", "Logging",
                              "Metrics", and "AzureServices".
                            "ipRules": [
                                {
                                    "value": "str",  # Specifies the IP or IP
                                      range in CIDR format. Only IPV4 address is allowed. Required.
                                    "action": "Allow"  # Optional. Default value
                                      is "Allow". The action of IP ACL rule.
                                }
                            ],
                            "resourceAccessRules": [
                                {
                                    "resourceId": "str",  # Optional. Resource
                                      Id.
                                    "tenantId": "str"  # Optional. Tenant Id.
                                }
                            ],
                            "virtualNetworkRules": [
                                {
                                    "id": "str",  # Resource ID of a subnet, for
                                      example:
                                      /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
                                      Required.
                                    "action": "Allow",  # Optional. Default value
                                      is "Allow". The action of virtual network rule.
                                    "state": "str"  # Optional. Gets the state of
                                      virtual network rule. Known values are: "Provisioning",
                                      "Deprovisioning", "Succeeded", "Failed", and
                                      "NetworkSourceDeleted".
                                }
                            ]
                        },
                        "primaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "primaryLocation": "str",  # Optional. Gets the location of the
                          primary data center for the storage account.
                        "privateEndpointConnections": [
                            {
                                "id": "str",  # Optional. Fully qualified resource ID
                                  for the resource. Ex -
                                  /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                                "name": "str",  # Optional. The name of the resource.
                                "properties": {
                                    "privateLinkServiceConnectionState": {
                                        "actionRequired": "str",  # Optional.
                                          A message indicating if changes on the service provider
                                          require any updates on the consumer.
                                        "description": "str",  # Optional.
                                          The reason for approval/rejection of the connection.
                                        "status": "str"  # Optional.
                                          Indicates whether the connection has been
                                          Approved/Rejected/Removed by the owner of the service. Known
                                          values are: "Pending", "Approved", and "Rejected".
                                    },
                                    "privateEndpoint": {
                                        "id": "str"  # Optional. The ARM
                                          identifier for Private Endpoint.
                                    },
                                    "provisioningState": "str"  # Optional. The
                                      provisioning state of the private endpoint connection resource.
                                      Known values are: "Succeeded", "Creating", "Deleting", and
                                      "Failed".
                                },
                                "type": "str"  # Optional. The type of the resource.
                                  E.g. "Microsoft.Compute/virtualMachines" or
                                  "Microsoft.Storage/storageAccounts".
                            }
                        ],
                        "provisioningState": "str",  # Optional. Gets the status of the
                          storage account at the time the operation was called. Known values are:
                          "Creating", "ResolvingDNS", and "Succeeded".
                        "publicNetworkAccess": "str",  # Optional. Allow, disallow, or let
                          Network Security Perimeter configuration to evaluate public network access to
                          Storage Account. Known values are: "Enabled", "Disabled", and
                          "SecuredByPerimeter".
                        "routingPreference": {
                            "publishInternetEndpoints": bool,  # Optional. A boolean flag
                              which indicates whether internet routing storage endpoints are to be
                              published.
                            "publishMicrosoftEndpoints": bool,  # Optional. A boolean
                              flag which indicates whether microsoft routing storage endpoints are to
                              be published.
                            "routingChoice": "str"  # Optional. Routing Choice defines
                              the kind of network routing opted by the user. Known values are:
                              "MicrosoftRouting" and "InternetRouting".
                        },
                        "sasPolicy": {
                            "expirationAction": "Log",  # Default value is "Log". The SAS
                              Expiration Action defines the action to be performed when
                              sasPolicy.sasExpirationPeriod is violated. The 'Log' action can be used
                              for audit purposes and the 'Block' action can be used to block and deny
                              the usage of SAS tokens that do not adhere to the sas policy expiration
                              period. Known values are: "Log" and "Block".
                            "sasExpirationPeriod": "str"  # The SAS expiration period,
                              DD.HH:MM:SS. Required.
                        },
                        "secondaryEndpoints": {
                            "blob": "str",  # Optional. Gets the blob endpoint.
                            "dfs": "str",  # Optional. Gets the dfs endpoint.
                            "file": "str",  # Optional. Gets the file endpoint.
                            "internetEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "microsoftEndpoints": {
                                "blob": "str",  # Optional. Gets the blob endpoint.
                                "dfs": "str",  # Optional. Gets the dfs endpoint.
                                "file": "str",  # Optional. Gets the file endpoint.
                                "queue": "str",  # Optional. Gets the queue endpoint.
                                "table": "str",  # Optional. Gets the table endpoint.
                                "web": "str"  # Optional. Gets the web endpoint.
                            },
                            "queue": "str",  # Optional. Gets the queue endpoint.
                            "table": "str",  # Optional. Gets the table endpoint.
                            "web": "str"  # Optional. Gets the web endpoint.
                        },
                        "secondaryLocation": "str",  # Optional. Gets the location of the
                          geo-replicated secondary for the storage account. Only available if the
                          accountType is Standard_GRS or Standard_RAGRS.
                        "statusOfPrimary": "str",  # Optional. Gets the status indicating
                          whether the primary location of the storage account is available or
                          unavailable. Known values are: "available" and "unavailable".
                        "statusOfSecondary": "str",  # Optional. Gets the status indicating
                          whether the secondary location of the storage account is available or
                          unavailable. Only available if the SKU name is Standard_GRS or
                          Standard_RAGRS. Known values are: "available" and "unavailable".
                        "storageAccountSkuConversionStatus": {
                            "endTime": "str",  # Optional. This property represents the
                              sku conversion end time.
                            "skuConversionStatus": "str",  # Optional. This property
                              indicates the current sku conversion status. Known values are:
                              "InProgress", "Succeeded", and "Failed".
                            "startTime": "str",  # Optional. This property represents the
                              sku conversion start time.
                            "targetSkuName": "str"  # Optional. This property represents
                              the target sku name to which the account sku is being converted
                              asynchronously. Known values are: "Standard_LRS", "Standard_GRS",
                              "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                              "Standard_GZRS", and "Standard_RAGZRS".
                        },
                        "supportsHttpsTrafficOnly": bool  # Optional. Allows https traffic
                          only to storage service if sets to true.
                    },
                    "sku": {
                        "name": "str",  # The SKU name. Required for account creation;
                          optional for update. Note that in older versions, SKU name was called
                          accountType. Required. Known values are: "Standard_LRS", "Standard_GRS",
                          "Standard_RAGRS", "Standard_ZRS", "Premium_LRS", "Premium_ZRS",
                          "Standard_GZRS", and "Standard_RAGZRS".
                        "tier": "str"  # Optional. The SKU tier. This is based on the SKU
                          name. Known values are: "Standard" and "Premium".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_storage_accounts_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_keys(
        self, resource_group_name: str, account_name: str, *, expand: Optional[Literal["kerb"]] = None, **kwargs: Any
    ) -> JSON:
        """Lists the access keys or Kerberos keys (if active directory enabled) for the specified storage
        account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :keyword expand: Specifies type of the key to be listed. Possible value is kerb. Known values
         are "kerb" and None. Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "keys": [
                        {
                            "creationTime": "2020-02-20 00:00:00",  # Optional. Creation
                              time of the key, in round trip date format.
                            "keyName": "str",  # Optional. Name of the key.
                            "permissions": "str",  # Optional. Permissions for the key --
                              read-only or full permissions. Known values are: "Read" and "Full".
                            "value": "str"  # Optional. Base 64-encoded value of the key.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_storage_accounts_list_keys_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def regenerate_key(
        self,
        resource_group_name: str,
        account_name: str,
        regenerate_key: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Regenerates one of the access keys or Kerberos keys for the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param regenerate_key: Specifies name of the key which should be regenerated -- key1, key2,
         kerb1, kerb2. Required.
        :type regenerate_key: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                regenerate_key = {
                    "keyName": "str"  # The name of storage keys that want to be regenerated,
                      possible values are key1, key2, kerb1, kerb2. Required.
                }

                # response body for status code(s): 200
                response == {
                    "keys": [
                        {
                            "creationTime": "2020-02-20 00:00:00",  # Optional. Creation
                              time of the key, in round trip date format.
                            "keyName": "str",  # Optional. Name of the key.
                            "permissions": "str",  # Optional. Permissions for the key --
                              read-only or full permissions. Known values are: "Read" and "Full".
                            "value": "str"  # Optional. Base 64-encoded value of the key.
                        }
                    ]
                }
        """

    @overload
    def regenerate_key(
        self,
        resource_group_name: str,
        account_name: str,
        regenerate_key: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Regenerates one of the access keys or Kerberos keys for the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param regenerate_key: Specifies name of the key which should be regenerated -- key1, key2,
         kerb1, kerb2. Required.
        :type regenerate_key: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "keys": [
                        {
                            "creationTime": "2020-02-20 00:00:00",  # Optional. Creation
                              time of the key, in round trip date format.
                            "keyName": "str",  # Optional. Name of the key.
                            "permissions": "str",  # Optional. Permissions for the key --
                              read-only or full permissions. Known values are: "Read" and "Full".
                            "value": "str"  # Optional. Base 64-encoded value of the key.
                        }
                    ]
                }
        """

    @distributed_trace
    def regenerate_key(
        self, resource_group_name: str, account_name: str, regenerate_key: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Regenerates one of the access keys or Kerberos keys for the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param regenerate_key: Specifies name of the key which should be regenerated -- key1, key2,
         kerb1, kerb2. Is either a JSON type or a IO type. Required.
        :type regenerate_key: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                regenerate_key = {
                    "keyName": "str"  # The name of storage keys that want to be regenerated,
                      possible values are key1, key2, kerb1, kerb2. Required.
                }

                # response body for status code(s): 200
                response == {
                    "keys": [
                        {
                            "creationTime": "2020-02-20 00:00:00",  # Optional. Creation
                              time of the key, in round trip date format.
                            "keyName": "str",  # Optional. Name of the key.
                            "permissions": "str",  # Optional. Permissions for the key --
                              read-only or full permissions. Known values are: "Read" and "Full".
                            "value": "str"  # Optional. Base 64-encoded value of the key.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(regenerate_key, (IOBase, bytes)):
            _content = regenerate_key
        else:
            _json = regenerate_key

        request = build_storage_accounts_regenerate_key_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def list_account_sas(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """List SAS credentials of a storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide to list SAS credentials for the storage account.
         Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "signedExpiry": "2020-02-20 00:00:00",  # The time at which the shared access
                      signature becomes invalid. Required.
                    "signedPermission": "str",  # The signed permissions for the account SAS.
                      Possible values include: Read (r), Write (w), Delete (d), List (l), Add (a),
                      Create (c), Update (u) and Process (p). Required. Known values are: "r", "d",
                      "w", "l", "a", "c", "u", and "p".
                    "signedResourceTypes": "str",  # The signed resource types that are
                      accessible with the account SAS. Service (s): Access to service-level APIs;
                      Container (c): Access to container-level APIs; Object (o): Access to object-level
                      APIs for blobs, queue messages, table entities, and files. Required. Known values
                      are: "s", "c", and "o".
                    "signedServices": "str",  # The signed services accessible with the account
                      SAS. Possible values include: Blob (b), Queue (q), Table (t), File (f). Required.
                      Known values are: "b", "q", "t", and "f".
                    "keyToSign": "str",  # Optional. The key to sign the account SAS token with.
                    "signedIp": "str",  # Optional. An IP address or a range of IP addresses from
                      which to accept requests.
                    "signedProtocol": "str",  # Optional. The protocol permitted for a request
                      made with the account SAS. Known values are: "https,http" and "https".
                    "signedStart": "2020-02-20 00:00:00"  # Optional. The time at which the SAS
                      becomes valid.
                }

                # response body for status code(s): 200
                response == {
                    "accountSasToken": "str"  # Optional. List SAS credentials of storage
                      account.
                }
        """

    @overload
    def list_account_sas(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """List SAS credentials of a storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide to list SAS credentials for the storage account.
         Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "accountSasToken": "str"  # Optional. List SAS credentials of storage
                      account.
                }
        """

    @distributed_trace
    def list_account_sas(
        self, resource_group_name: str, account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """List SAS credentials of a storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide to list SAS credentials for the storage account.
         Is either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "signedExpiry": "2020-02-20 00:00:00",  # The time at which the shared access
                      signature becomes invalid. Required.
                    "signedPermission": "str",  # The signed permissions for the account SAS.
                      Possible values include: Read (r), Write (w), Delete (d), List (l), Add (a),
                      Create (c), Update (u) and Process (p). Required. Known values are: "r", "d",
                      "w", "l", "a", "c", "u", and "p".
                    "signedResourceTypes": "str",  # The signed resource types that are
                      accessible with the account SAS. Service (s): Access to service-level APIs;
                      Container (c): Access to container-level APIs; Object (o): Access to object-level
                      APIs for blobs, queue messages, table entities, and files. Required. Known values
                      are: "s", "c", and "o".
                    "signedServices": "str",  # The signed services accessible with the account
                      SAS. Possible values include: Blob (b), Queue (q), Table (t), File (f). Required.
                      Known values are: "b", "q", "t", and "f".
                    "keyToSign": "str",  # Optional. The key to sign the account SAS token with.
                    "signedIp": "str",  # Optional. An IP address or a range of IP addresses from
                      which to accept requests.
                    "signedProtocol": "str",  # Optional. The protocol permitted for a request
                      made with the account SAS. Known values are: "https,http" and "https".
                    "signedStart": "2020-02-20 00:00:00"  # Optional. The time at which the SAS
                      becomes valid.
                }

                # response body for status code(s): 200
                response == {
                    "accountSasToken": "str"  # Optional. List SAS credentials of storage
                      account.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_storage_accounts_list_account_sas_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def list_service_sas(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """List service SAS credentials of a specific resource.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide to list service SAS credentials. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "canonicalizedResource": "str",  # The canonical path to the signed resource.
                      Required.
                    "endPk": "str",  # Optional. The end of partition key.
                    "endRk": "str",  # Optional. The end of row key.
                    "keyToSign": "str",  # Optional. The key to sign the account SAS token with.
                    "rscc": "str",  # Optional. The response header override for cache control.
                    "rscd": "str",  # Optional. The response header override for content
                      disposition.
                    "rsce": "str",  # Optional. The response header override for content
                      encoding.
                    "rscl": "str",  # Optional. The response header override for content
                      language.
                    "rsct": "str",  # Optional. The response header override for content type.
                    "signedExpiry": "2020-02-20 00:00:00",  # Optional. The time at which the
                      shared access signature becomes invalid.
                    "signedIdentifier": "str",  # Optional. A unique value up to 64 characters in
                      length that correlates to an access policy specified for the container, queue, or
                      table.
                    "signedIp": "str",  # Optional. An IP address or a range of IP addresses from
                      which to accept requests.
                    "signedPermission": "str",  # Optional. The signed permissions for the
                      service SAS. Possible values include: Read (r), Write (w), Delete (d), List (l),
                      Add (a), Create (c), Update (u) and Process (p). Known values are: "r", "d", "w",
                      "l", "a", "c", "u", and "p".
                    "signedProtocol": "str",  # Optional. The protocol permitted for a request
                      made with the account SAS. Known values are: "https,http" and "https".
                    "signedResource": "str",  # Optional. The signed services accessible with the
                      service SAS. Possible values include: Blob (b), Container (c), File (f), Share
                      (s). Known values are: "b", "c", "f", and "s".
                    "signedStart": "2020-02-20 00:00:00",  # Optional. The time at which the SAS
                      becomes valid.
                    "startPk": "str",  # Optional. The start of partition key.
                    "startRk": "str"  # Optional. The start of row key.
                }

                # response body for status code(s): 200
                response == {
                    "serviceSasToken": "str"  # Optional. List service SAS credentials of
                      specific resource.
                }
        """

    @overload
    def list_service_sas(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """List service SAS credentials of a specific resource.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide to list service SAS credentials. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "serviceSasToken": "str"  # Optional. List service SAS credentials of
                      specific resource.
                }
        """

    @distributed_trace
    def list_service_sas(
        self, resource_group_name: str, account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """List service SAS credentials of a specific resource.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide to list service SAS credentials. Is either a JSON
         type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "canonicalizedResource": "str",  # The canonical path to the signed resource.
                      Required.
                    "endPk": "str",  # Optional. The end of partition key.
                    "endRk": "str",  # Optional. The end of row key.
                    "keyToSign": "str",  # Optional. The key to sign the account SAS token with.
                    "rscc": "str",  # Optional. The response header override for cache control.
                    "rscd": "str",  # Optional. The response header override for content
                      disposition.
                    "rsce": "str",  # Optional. The response header override for content
                      encoding.
                    "rscl": "str",  # Optional. The response header override for content
                      language.
                    "rsct": "str",  # Optional. The response header override for content type.
                    "signedExpiry": "2020-02-20 00:00:00",  # Optional. The time at which the
                      shared access signature becomes invalid.
                    "signedIdentifier": "str",  # Optional. A unique value up to 64 characters in
                      length that correlates to an access policy specified for the container, queue, or
                      table.
                    "signedIp": "str",  # Optional. An IP address or a range of IP addresses from
                      which to accept requests.
                    "signedPermission": "str",  # Optional. The signed permissions for the
                      service SAS. Possible values include: Read (r), Write (w), Delete (d), List (l),
                      Add (a), Create (c), Update (u) and Process (p). Known values are: "r", "d", "w",
                      "l", "a", "c", "u", and "p".
                    "signedProtocol": "str",  # Optional. The protocol permitted for a request
                      made with the account SAS. Known values are: "https,http" and "https".
                    "signedResource": "str",  # Optional. The signed services accessible with the
                      service SAS. Possible values include: Blob (b), Container (c), File (f), Share
                      (s). Known values are: "b", "c", "f", and "s".
                    "signedStart": "2020-02-20 00:00:00",  # Optional. The time at which the SAS
                      becomes valid.
                    "startPk": "str",  # Optional. The start of partition key.
                    "startRk": "str"  # Optional. The start of row key.
                }

                # response body for status code(s): 200
                response == {
                    "serviceSasToken": "str"  # Optional. List service SAS credentials of
                      specific resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_storage_accounts_list_service_sas_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _failover_initial(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        account_name: str,
        *,
        failover_type: Optional[Literal["Planned"]] = None,
        **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_storage_accounts_failover_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            failover_type=failover_type,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_failover(
        self,
        resource_group_name: str,
        account_name: str,
        *,
        failover_type: Optional[Literal["Planned"]] = None,
        **kwargs: Any
    ) -> LROPoller[None]:
        """A failover request can be triggered for a storage account in the event a primary endpoint
        becomes unavailable for any reason. The failover occurs from the storage account's primary
        cluster to the secondary cluster for RA-GRS accounts. The secondary cluster will become primary
        after failover and the account is converted to LRS. In the case of a Planned Failover, the
        primary and secondary clusters are swapped after failover and the account remains
        geo-replicated. Failover should continue to be used in the event of availability issues as
        Planned failover is only available while the primary and secondary endpoints are available. The
        primary use case of a Planned Failover is disaster recovery testing drills. This type of
        failover is invoked by setting FailoverType parameter to 'Planned'. Learn more about the
        failover options here-
        https://learn.microsoft.com/en-us/azure/storage/common/storage-disaster-recovery-guidance.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :keyword failover_type: The parameter is set to 'Planned' to indicate whether a Planned
         failover is requested. Known values are "Planned" and None. Default value is None.
        :paramtype failover_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._failover_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                failover_type=failover_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _hierarchical_namespace_migration_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, *, request_type: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_storage_accounts_hierarchical_namespace_migration_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            request_type=request_type,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_hierarchical_namespace_migration(
        self, resource_group_name: str, account_name: str, *, request_type: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Live Migration of storage account to enable Hns.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :keyword request_type: Required. Hierarchical namespace migration type can either be a
         hierarchical namespace validation request 'HnsOnValidationRequest' or a hydration request
         'HnsOnHydrationRequest'. The validation request will validate the migration whereas the
         hydration request will migrate the account. Required.
        :paramtype request_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._hierarchical_namespace_migration_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                request_type=request_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _abort_hierarchical_namespace_migration_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_storage_accounts_abort_hierarchical_namespace_migration_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def begin_abort_hierarchical_namespace_migration(
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Abort live Migration of storage account to enable Hns.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._abort_hierarchical_namespace_migration_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _customer_initiated_migration_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_storage_accounts_customer_initiated_migration_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @overload
    def begin_customer_initiated_migration(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[None]:
        """Account Migration request can be triggered for a storage account to change its redundancy
        level. The migration updates the non-zonal redundant storage account to a zonal redundant
        account or vice-versa in order to have better reliability and availability. Zone-redundant
        storage (ZRS) replicates your storage account synchronously across three Azure availability
        zones in the primary region.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The request parameters required to perform storage account migration.
         Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "targetSkuName": "str",  # Target sku name for the account. Required.
                          Known values are: "Standard_LRS", "Standard_GRS", "Standard_RAGRS",
                          "Standard_ZRS", "Premium_LRS", "Premium_ZRS", "Standard_GZRS", and
                          "Standard_RAGZRS".
                        "migrationFailedDetailedReason": "str",  # Optional. Reason for
                          migration failure.
                        "migrationFailedReason": "str",  # Optional. Error code for migration
                          failure.
                        "migrationStatus": "str"  # Optional. Current status of migration.
                          Known values are: "Invalid", "SubmittedForConversion", "InProgress",
                          "Complete", and "Failed".
                    },
                    "id": "str",  # Optional. Migration Resource Id.
                    "name": "str",  # Optional. current value is 'default' for customer initiated
                      migration.
                    "type": "str"  # Optional. SrpAccountMigrationType in ARM contract which is
                      'accountMigrations'.
                }
        """

    @overload
    def begin_customer_initiated_migration(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[None]:
        """Account Migration request can be triggered for a storage account to change its redundancy
        level. The migration updates the non-zonal redundant storage account to a zonal redundant
        account or vice-versa in order to have better reliability and availability. Zone-redundant
        storage (ZRS) replicates your storage account synchronously across three Azure availability
        zones in the primary region.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The request parameters required to perform storage account migration.
         Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_customer_initiated_migration(
        self, resource_group_name: str, account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[None]:
        """Account Migration request can be triggered for a storage account to change its redundancy
        level. The migration updates the non-zonal redundant storage account to a zonal redundant
        account or vice-versa in order to have better reliability and availability. Zone-redundant
        storage (ZRS) replicates your storage account synchronously across three Azure availability
        zones in the primary region.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The request parameters required to perform storage account migration. Is
         either a JSON type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "targetSkuName": "str",  # Target sku name for the account. Required.
                          Known values are: "Standard_LRS", "Standard_GRS", "Standard_RAGRS",
                          "Standard_ZRS", "Premium_LRS", "Premium_ZRS", "Standard_GZRS", and
                          "Standard_RAGZRS".
                        "migrationFailedDetailedReason": "str",  # Optional. Reason for
                          migration failure.
                        "migrationFailedReason": "str",  # Optional. Error code for migration
                          failure.
                        "migrationStatus": "str"  # Optional. Current status of migration.
                          Known values are: "Invalid", "SubmittedForConversion", "InProgress",
                          "Complete", and "Failed".
                    },
                    "id": "str",  # Optional. Migration Resource Id.
                    "name": "str",  # Optional. current value is 'default' for customer initiated
                      migration.
                    "type": "str"  # Optional. SrpAccountMigrationType in ARM contract which is
                      'accountMigrations'.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._customer_initiated_migration_initial(  # type: ignore
                resource_group_name=resource_group_name,
                account_name=account_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get_customer_initiated_migration(
        self, resource_group_name: str, account_name: str, migration_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the status of the ongoing migration for the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param migration_name: The name of the Storage Account Migration. It should always be
         'default'. "default" Required.
        :type migration_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "targetSkuName": "str",  # Target sku name for the account. Required.
                          Known values are: "Standard_LRS", "Standard_GRS", "Standard_RAGRS",
                          "Standard_ZRS", "Premium_LRS", "Premium_ZRS", "Standard_GZRS", and
                          "Standard_RAGZRS".
                        "migrationFailedDetailedReason": "str",  # Optional. Reason for
                          migration failure.
                        "migrationFailedReason": "str",  # Optional. Error code for migration
                          failure.
                        "migrationStatus": "str"  # Optional. Current status of migration.
                          Known values are: "Invalid", "SubmittedForConversion", "InProgress",
                          "Complete", and "Failed".
                    },
                    "id": "str",  # Optional. Migration Resource Id.
                    "name": "str",  # Optional. current value is 'default' for customer initiated
                      migration.
                    "type": "str"  # Optional. SrpAccountMigrationType in ARM contract which is
                      'accountMigrations'.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_storage_accounts_get_customer_initiated_migration_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            migration_name=migration_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _restore_blob_ranges_initial(
        self, resource_group_name: str, account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_storage_accounts_restore_blob_ranges_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_restore_blob_ranges(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Restore blobs in the specified blob ranges.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide for restore blob ranges. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "blobRanges": [
                        {
                            "endRange": "str",  # Blob end range. This is exclusive.
                              Empty means account end. Required.
                            "startRange": "str"  # Blob start range. This is inclusive.
                              Empty means account start. Required.
                        }
                    ],
                    "timeToRestore": "2020-02-20 00:00:00"  # Restore blob to the specified time.
                      Required.
                }

                # response body for status code(s): 200, 202
                response == {
                    "failureReason": "str",  # Optional. Failure reason when blob restore is
                      failed.
                    "parameters": {
                        "blobRanges": [
                            {
                                "endRange": "str",  # Blob end range. This is
                                  exclusive. Empty means account end. Required.
                                "startRange": "str"  # Blob start range. This is
                                  inclusive. Empty means account start. Required.
                            }
                        ],
                        "timeToRestore": "2020-02-20 00:00:00"  # Restore blob to the
                          specified time. Required.
                    },
                    "restoreId": "str",  # Optional. Id for tracking blob restore request.
                    "status": "str"  # Optional. The status of blob restore progress. Possible
                      values are: - InProgress: Indicates that blob restore is ongoing. - Complete:
                      Indicates that blob restore has been completed successfully. - Failed: Indicates
                      that blob restore is failed. Known values are: "InProgress", "Complete", and
                      "Failed".
                }
        """

    @overload
    def begin_restore_blob_ranges(
        self,
        resource_group_name: str,
        account_name: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Restore blobs in the specified blob ranges.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide for restore blob ranges. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 202
                response == {
                    "failureReason": "str",  # Optional. Failure reason when blob restore is
                      failed.
                    "parameters": {
                        "blobRanges": [
                            {
                                "endRange": "str",  # Blob end range. This is
                                  exclusive. Empty means account end. Required.
                                "startRange": "str"  # Blob start range. This is
                                  inclusive. Empty means account start. Required.
                            }
                        ],
                        "timeToRestore": "2020-02-20 00:00:00"  # Restore blob to the
                          specified time. Required.
                    },
                    "restoreId": "str",  # Optional. Id for tracking blob restore request.
                    "status": "str"  # Optional. The status of blob restore progress. Possible
                      values are: - InProgress: Indicates that blob restore is ongoing. - Complete:
                      Indicates that blob restore has been completed successfully. - Failed: Indicates
                      that blob restore is failed. Known values are: "InProgress", "Complete", and
                      "Failed".
                }
        """

    @distributed_trace
    def begin_restore_blob_ranges(
        self, resource_group_name: str, account_name: str, parameters: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Restore blobs in the specified blob ranges.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param parameters: The parameters to provide for restore blob ranges. Is either a JSON type or
         a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "blobRanges": [
                        {
                            "endRange": "str",  # Blob end range. This is exclusive.
                              Empty means account end. Required.
                            "startRange": "str"  # Blob start range. This is inclusive.
                              Empty means account start. Required.
                        }
                    ],
                    "timeToRestore": "2020-02-20 00:00:00"  # Restore blob to the specified time.
                      Required.
                }

                # response body for status code(s): 200, 202
                response == {
                    "failureReason": "str",  # Optional. Failure reason when blob restore is
                      failed.
                    "parameters": {
                        "blobRanges": [
                            {
                                "endRange": "str",  # Blob end range. This is
                                  exclusive. Empty means account end. Required.
                                "startRange": "str"  # Blob start range. This is
                                  inclusive. Empty means account start. Required.
                            }
                        ],
                        "timeToRestore": "2020-02-20 00:00:00"  # Restore blob to the
                          specified time. Required.
                    },
                    "restoreId": "str",  # Optional. Id for tracking blob restore request.
                    "status": "str"  # Optional. The status of blob restore progress. Possible
                      values are: - InProgress: Indicates that blob restore is ongoing. - Complete:
                      Indicates that blob restore has been completed successfully. - Failed: Indicates
                      that blob restore is failed. Known values are: "InProgress", "Complete", and
                      "Failed".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._restore_blob_ranges_initial(
                resource_group_name=resource_group_name,
                account_name=account_name,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def revoke_user_delegation_keys(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, **kwargs: Any
    ) -> None:
        """Revoke user delegation keys.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_storage_accounts_revoke_user_delegation_keys_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class DeletedAccountsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`deleted_accounts` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists deleted accounts under the subscription.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "str",  # Optional. Creation time of the deleted
                          account.
                        "deletionTime": "str",  # Optional. Deletion time of the deleted
                          account.
                        "location": "str",  # Optional. Location of the deleted account.
                        "restoreReference": "str",  # Optional. Can be used to attempt
                          recovering this deleted account via PutStorageAccount API.
                        "storageAccountResourceId": "str"  # Optional. Full resource id of
                          the original storage account.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_deleted_accounts_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, deleted_account_name: str, location: str, **kwargs: Any) -> JSON:
        """Get properties of specified deleted account resource.

        :param deleted_account_name: Name of the deleted storage account. Required.
        :type deleted_account_name: str
        :param location: The location of the deleted storage account. Required.
        :type location: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "str",  # Optional. Creation time of the deleted
                          account.
                        "deletionTime": "str",  # Optional. Deletion time of the deleted
                          account.
                        "location": "str",  # Optional. Location of the deleted account.
                        "restoreReference": "str",  # Optional. Can be used to attempt
                          recovering this deleted account via PutStorageAccount API.
                        "storageAccountResourceId": "str"  # Optional. Full resource id of
                          the original storage account.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_deleted_accounts_get_request(
            deleted_account_name=deleted_account_name,
            location=location,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class UsagesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`usages` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_location(self, location: str, **kwargs: Any) -> Iterable[JSON]:
        """Gets the current usage count and the limit for the resources of the location under the
        subscription.

        :param location: The location of the Azure Storage resource. Required.
        :type location: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "currentValue": 0,  # Optional. Gets the current count of the allocated
                      resources in the subscription.
                    "limit": 0,  # Optional. Gets the maximum count of the resources that can be
                      allocated in the subscription.
                    "name": {
                        "localizedValue": "str",  # Optional. Gets a localized string
                          describing the resource name.
                        "value": "str"  # Optional. Gets a string describing the resource
                          name.
                    },
                    "unit": "str"  # Optional. Gets the unit of measurement. Known values are:
                      "Count", "Bytes", "Seconds", "Percent", "CountsPerSecond", and "BytesPerSecond".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_usages_list_by_location_request(
                    location=location,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class ManagementPoliciesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`management_policies` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, resource_group_name: str, account_name: str, management_policy_name: str, **kwargs: Any) -> JSON:
        """Gets the managementpolicy associated with the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param management_policy_name: The name of the Storage Account Management Policy. It should
         always be 'default'. "default" Required.
        :type management_policy_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "rules": [
                                {
                                    "definition": {
                                        "actions": {
                                            "baseBlob": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                "enableAutoTierToHotFromCool": bool,  # Optional.
                                                  This property enables auto tiering of a blob from
                                                  cool to hot on a blob access. This property requires
                                                  tierToCool.daysAfterLastAccessTimeGreaterThan.
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                }
                                            },
                                            "snapshot": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            },
                                            "version": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            }
                                        },
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # An array of
                                                  predefined enum values. Currently blockBlob supports
                                                  all tiering and delete actions. Only delete actions
                                                  are supported for appendBlob. Required.
                                            ],
                                            "blobIndexMatch": [
                                                {
                                                    "name":
                                                      "str",  # This is the filter tag name, it can
                                                      have 1 - 128 characters. Required.
                                                    "op": "str",
                                                      # This is the comparison operator which is used
                                                      for object comparison and filtering. Only ==
                                                      (equality operator) is currently supported.
                                                      Required.
                                                    "value":
                                                      "str"  # This is the filter tag value field used
                                                      for tag based filtering, it can have 0 - 256
                                                      characters. Required.
                                                }
                                            ],
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings for prefixes to be match.
                                            ]
                                        }
                                    },
                                    "name": "str",  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                    "type": "str",  # The valid value is
                                      Lifecycle. Required. "Lifecycle"
                                    "enabled": bool  # Optional. Rule is enabled
                                      if set to true.
                                }
                            ]
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          date and time the ManagementPolicies was last modified.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_management_policies_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            management_policy_name=management_policy_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        management_policy_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets the managementpolicy to the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param management_policy_name: The name of the Storage Account Management Policy. It should
         always be 'default'. "default" Required.
        :type management_policy_name: str
        :param properties: The ManagementPolicy set to a storage account. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "rules": [
                                {
                                    "definition": {
                                        "actions": {
                                            "baseBlob": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                "enableAutoTierToHotFromCool": bool,  # Optional.
                                                  This property enables auto tiering of a blob from
                                                  cool to hot on a blob access. This property requires
                                                  tierToCool.daysAfterLastAccessTimeGreaterThan.
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                }
                                            },
                                            "snapshot": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            },
                                            "version": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            }
                                        },
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # An array of
                                                  predefined enum values. Currently blockBlob supports
                                                  all tiering and delete actions. Only delete actions
                                                  are supported for appendBlob. Required.
                                            ],
                                            "blobIndexMatch": [
                                                {
                                                    "name":
                                                      "str",  # This is the filter tag name, it can
                                                      have 1 - 128 characters. Required.
                                                    "op": "str",
                                                      # This is the comparison operator which is used
                                                      for object comparison and filtering. Only ==
                                                      (equality operator) is currently supported.
                                                      Required.
                                                    "value":
                                                      "str"  # This is the filter tag value field used
                                                      for tag based filtering, it can have 0 - 256
                                                      characters. Required.
                                                }
                                            ],
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings for prefixes to be match.
                                            ]
                                        }
                                    },
                                    "name": "str",  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                    "type": "str",  # The valid value is
                                      Lifecycle. Required. "Lifecycle"
                                    "enabled": bool  # Optional. Rule is enabled
                                      if set to true.
                                }
                            ]
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          date and time the ManagementPolicies was last modified.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "rules": [
                                {
                                    "definition": {
                                        "actions": {
                                            "baseBlob": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                "enableAutoTierToHotFromCool": bool,  # Optional.
                                                  This property enables auto tiering of a blob from
                                                  cool to hot on a blob access. This property requires
                                                  tierToCool.daysAfterLastAccessTimeGreaterThan.
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                }
                                            },
                                            "snapshot": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            },
                                            "version": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            }
                                        },
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # An array of
                                                  predefined enum values. Currently blockBlob supports
                                                  all tiering and delete actions. Only delete actions
                                                  are supported for appendBlob. Required.
                                            ],
                                            "blobIndexMatch": [
                                                {
                                                    "name":
                                                      "str",  # This is the filter tag name, it can
                                                      have 1 - 128 characters. Required.
                                                    "op": "str",
                                                      # This is the comparison operator which is used
                                                      for object comparison and filtering. Only ==
                                                      (equality operator) is currently supported.
                                                      Required.
                                                    "value":
                                                      "str"  # This is the filter tag value field used
                                                      for tag based filtering, it can have 0 - 256
                                                      characters. Required.
                                                }
                                            ],
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings for prefixes to be match.
                                            ]
                                        }
                                    },
                                    "name": "str",  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                    "type": "str",  # The valid value is
                                      Lifecycle. Required. "Lifecycle"
                                    "enabled": bool  # Optional. Rule is enabled
                                      if set to true.
                                }
                            ]
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          date and time the ManagementPolicies was last modified.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        management_policy_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets the managementpolicy to the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param management_policy_name: The name of the Storage Account Management Policy. It should
         always be 'default'. "default" Required.
        :type management_policy_name: str
        :param properties: The ManagementPolicy set to a storage account. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "rules": [
                                {
                                    "definition": {
                                        "actions": {
                                            "baseBlob": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                "enableAutoTierToHotFromCool": bool,  # Optional.
                                                  This property enables auto tiering of a blob from
                                                  cool to hot on a blob access. This property requires
                                                  tierToCool.daysAfterLastAccessTimeGreaterThan.
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                }
                                            },
                                            "snapshot": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            },
                                            "version": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            }
                                        },
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # An array of
                                                  predefined enum values. Currently blockBlob supports
                                                  all tiering and delete actions. Only delete actions
                                                  are supported for appendBlob. Required.
                                            ],
                                            "blobIndexMatch": [
                                                {
                                                    "name":
                                                      "str",  # This is the filter tag name, it can
                                                      have 1 - 128 characters. Required.
                                                    "op": "str",
                                                      # This is the comparison operator which is used
                                                      for object comparison and filtering. Only ==
                                                      (equality operator) is currently supported.
                                                      Required.
                                                    "value":
                                                      "str"  # This is the filter tag value field used
                                                      for tag based filtering, it can have 0 - 256
                                                      characters. Required.
                                                }
                                            ],
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings for prefixes to be match.
                                            ]
                                        }
                                    },
                                    "name": "str",  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                    "type": "str",  # The valid value is
                                      Lifecycle. Required. "Lifecycle"
                                    "enabled": bool  # Optional. Rule is enabled
                                      if set to true.
                                }
                            ]
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          date and time the ManagementPolicies was last modified.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        management_policy_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Sets the managementpolicy to the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param management_policy_name: The name of the Storage Account Management Policy. It should
         always be 'default'. "default" Required.
        :type management_policy_name: str
        :param properties: The ManagementPolicy set to a storage account. Is either a JSON type or a IO
         type. Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "rules": [
                                {
                                    "definition": {
                                        "actions": {
                                            "baseBlob": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                "enableAutoTierToHotFromCool": bool,  # Optional.
                                                  This property enables auto tiering of a blob from
                                                  cool to hot on a blob access. This property requires
                                                  tierToCool.daysAfterLastAccessTimeGreaterThan.
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                }
                                            },
                                            "snapshot": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            },
                                            "version": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            }
                                        },
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # An array of
                                                  predefined enum values. Currently blockBlob supports
                                                  all tiering and delete actions. Only delete actions
                                                  are supported for appendBlob. Required.
                                            ],
                                            "blobIndexMatch": [
                                                {
                                                    "name":
                                                      "str",  # This is the filter tag name, it can
                                                      have 1 - 128 characters. Required.
                                                    "op": "str",
                                                      # This is the comparison operator which is used
                                                      for object comparison and filtering. Only ==
                                                      (equality operator) is currently supported.
                                                      Required.
                                                    "value":
                                                      "str"  # This is the filter tag value field used
                                                      for tag based filtering, it can have 0 - 256
                                                      characters. Required.
                                                }
                                            ],
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings for prefixes to be match.
                                            ]
                                        }
                                    },
                                    "name": "str",  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                    "type": "str",  # The valid value is
                                      Lifecycle. Required. "Lifecycle"
                                    "enabled": bool  # Optional. Rule is enabled
                                      if set to true.
                                }
                            ]
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          date and time the ManagementPolicies was last modified.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "rules": [
                                {
                                    "definition": {
                                        "actions": {
                                            "baseBlob": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                "enableAutoTierToHotFromCool": bool,  # Optional.
                                                  This property enables auto tiering of a blob from
                                                  cool to hot on a blob access. This property requires
                                                  tierToCool.daysAfterLastAccessTimeGreaterThan.
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Optional.
                                                      Value indicating the age in days after blob
                                                      creation.
                "daysAfterLastAccessTimeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob access. This property can only be used
                                                      in conjunction with last access time tracking
                                                      policy.
                "daysAfterLastTierChangeGreaterThan": 0.0,  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterModificationGreaterThan to be set for
                                                      baseBlobs based actions. The blob will be
                                                      archived if both the conditions are satisfied.
                "daysAfterModificationGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last modification.
                                                }
                                            },
                                            "snapshot": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            },
                                            "version": {
                                                "delete": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToArchive": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCold": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToCool": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                },
                                                "tierToHot": {
                "daysAfterCreationGreaterThan": 0.0,  # Value
                                                      indicating the age in days after creation.
                                                      Required.
                "daysAfterLastTierChangeGreaterThan": 0.0  #
                                                      Optional. Value indicating the age in days after
                                                      last blob tier change time. This property is only
                                                      applicable for tierToArchive actions and requires
                                                      daysAfterCreationGreaterThan to be set for
                                                      snapshots and blob version based actions. The
                                                      blob will be archived if both the conditions are
                                                      satisfied.
                                                }
                                            }
                                        },
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # An array of
                                                  predefined enum values. Currently blockBlob supports
                                                  all tiering and delete actions. Only delete actions
                                                  are supported for appendBlob. Required.
                                            ],
                                            "blobIndexMatch": [
                                                {
                                                    "name":
                                                      "str",  # This is the filter tag name, it can
                                                      have 1 - 128 characters. Required.
                                                    "op": "str",
                                                      # This is the comparison operator which is used
                                                      for object comparison and filtering. Only ==
                                                      (equality operator) is currently supported.
                                                      Required.
                                                    "value":
                                                      "str"  # This is the filter tag value field used
                                                      for tag based filtering, it can have 0 - 256
                                                      characters. Required.
                                                }
                                            ],
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings for prefixes to be match.
                                            ]
                                        }
                                    },
                                    "name": "str",  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                    "type": "str",  # The valid value is
                                      Lifecycle. Required. "Lifecycle"
                                    "enabled": bool  # Optional. Rule is enabled
                                      if set to true.
                                }
                            ]
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          date and time the ManagementPolicies was last modified.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_management_policies_create_or_update_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            management_policy_name=management_policy_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, management_policy_name: str, **kwargs: Any
    ) -> None:
        """Deletes the managementpolicy associated with the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param management_policy_name: The name of the Storage Account Management Policy. It should
         always be 'default'. "default" Required.
        :type management_policy_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_management_policies_delete_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            management_policy_name=management_policy_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class BlobInventoryPoliciesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`blob_inventory_policies` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, resource_group_name: str, account_name: str, blob_inventory_policy_name: str, **kwargs: Any) -> JSON:
        """Gets the blob inventory policy associated with the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param blob_inventory_policy_name: The name of the storage account blob inventory policy. It
         should always be 'default'. "default" Required.
        :type blob_inventory_policy_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "enabled": bool,  # Policy is enabled if set to true.
                              Required.
                            "rules": [
                                {
                                    "definition": {
                                        "format": "str",  # This is a
                                          required field, it specifies the format for the inventory
                                          files. Required. Known values are: "Csv" and "Parquet".
                                        "objectType": "str",  # This is a
                                          required field. This field specifies the scope of the
                                          inventory created either at the blob or container level.
                                          Required. Known values are: "Blob" and "Container".
                                        "schedule": "str",  # This is a
                                          required field. This field is used to schedule an inventory
                                          formation. Required. Known values are: "Daily" and "Weekly".
                                        "schemaFields": [
                                            "str"  # This is a required
                                              field. This field specifies the fields and properties of
                                              the object to be included in the inventory. The Schema
                                              field value 'Name' is always required. The valid values
                                              for this field for the 'Blob' definition.objectType
                                              include 'Name, Creation-Time, Last-Modified,
                                              Content-Length, Content-MD5, BlobType, AccessTier,
                                              AccessTierChangeTime, AccessTierInferred, Tags,
                                              Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, Snapshot, VersionId, IsCurrentVersion, Metadata,
                                              LastAccessTime, Tags, Etag, ContentType, ContentEncoding,
                                              ContentLanguage, ContentCRC64, CacheControl,
                                              ContentDisposition, LeaseStatus, LeaseState,
                                              LeaseDuration, ServerEncrypted, Deleted, DeletionId,
                                              DeletedTime, RemainingRetentionDays,
                                              ImmutabilityPolicyUntilDate, ImmutabilityPolicyMode,
                                              LegalHold, CopyId, CopyStatus, CopySource, CopyProgress,
                                              CopyCompletionTime, CopyStatusDescription,
                                              CustomerProvidedKeySha256, RehydratePriority,
                                              ArchiveStatus, XmsBlobSequenceNumber, EncryptionScope,
                                              IncrementalCopy, TagCount'. For Blob object type schema
                                              field value 'DeletedTime' is applicable only for Hns
                                              enabled accounts. The valid values for 'Container'
                                              definition.objectType include 'Name, Last-Modified,
                                              Metadata, LeaseStatus, LeaseState, LeaseDuration,
                                              PublicAccess, HasImmutabilityPolicy, HasLegalHold, Etag,
                                              DefaultEncryptionScope, DenyEncryptionScopeOverride,
                                              ImmutableStorageWithVersioningEnabled, Deleted, Version,
                                              DeletedTime, RemainingRetentionDays'. Schema field values
                                              'Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, DeletionId' are valid only for Hns enabled
                                              accounts.Schema field values 'Tags, TagCount' are only
                                              valid for Non-Hns accounts. Required.
                                        ],
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # Optional. An
                                                  array of predefined enum values. Valid values include
                                                  blockBlob, appendBlob, pageBlob. Hns accounts does
                                                  not support pageBlobs. This field is required when
                                                  definition.objectType property is set to 'Blob'.
                                            ],
                                            "creationTime": {
                                                "lastNDays": 0  #
                                                  Optional. When set the policy filters the objects
                                                  that are created in the last N days. Where N is an
                                                  integer value between 1 to 36500.
                                            },
                                            "excludePrefix": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  excluded from the inventory.
                                            ],
                                            "includeBlobVersions": bool,
                                              # Optional. Includes blob versions in blob inventory when
                                              value is set to true. The definition.schemaFields values
                                              'VersionId and IsCurrentVersion' are required if this
                                              property is set to true, else they must be excluded.
                                            "includeDeleted": bool,  #
                                              Optional. For 'Container' definition.objectType the
                                              definition.schemaFields must include 'Deleted, Version,
                                              DeletedTime and RemainingRetentionDays'. For 'Blob'
                                              definition.objectType and HNS enabled storage accounts
                                              the definition.schemaFields must include 'DeletionId,
                                              Deleted, DeletedTime and RemainingRetentionDays' and for
                                              Hns disabled accounts the definition.schemaFields must
                                              include 'Deleted and RemainingRetentionDays', else it
                                              must be excluded.
                                            "includeSnapshots": bool,  #
                                              Optional. Includes blob snapshots in blob inventory when
                                              value is set to true. The definition.schemaFields value
                                              'Snapshot' is required if this property is set to true,
                                              else it must be excluded.
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  included in the inventory.
                                            ]
                                        }
                                    },
                                    "destination": "str",  # Container name where
                                      blob inventory files are stored. Must be pre-created. Required.
                                    "enabled": bool,  # Rule is enabled when set
                                      to true. Required.
                                    "name": "str"  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                }
                            ],
                            "type": "str",  # The valid value is Inventory. Required.
                              "Inventory"
                            "destination": "str"  # Optional. Deprecated Property from
                              API version 2021-04-01 onwards, the required destination container name
                              must be specified at the rule level 'policy.rule.destination'.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          last modified date and time of the blob inventory policy.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_blob_inventory_policies_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            blob_inventory_policy_name=blob_inventory_policy_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        blob_inventory_policy_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets the blob inventory policy to the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param blob_inventory_policy_name: The name of the storage account blob inventory policy. It
         should always be 'default'. "default" Required.
        :type blob_inventory_policy_name: str
        :param properties: The blob inventory policy set to a storage account. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "enabled": bool,  # Policy is enabled if set to true.
                              Required.
                            "rules": [
                                {
                                    "definition": {
                                        "format": "str",  # This is a
                                          required field, it specifies the format for the inventory
                                          files. Required. Known values are: "Csv" and "Parquet".
                                        "objectType": "str",  # This is a
                                          required field. This field specifies the scope of the
                                          inventory created either at the blob or container level.
                                          Required. Known values are: "Blob" and "Container".
                                        "schedule": "str",  # This is a
                                          required field. This field is used to schedule an inventory
                                          formation. Required. Known values are: "Daily" and "Weekly".
                                        "schemaFields": [
                                            "str"  # This is a required
                                              field. This field specifies the fields and properties of
                                              the object to be included in the inventory. The Schema
                                              field value 'Name' is always required. The valid values
                                              for this field for the 'Blob' definition.objectType
                                              include 'Name, Creation-Time, Last-Modified,
                                              Content-Length, Content-MD5, BlobType, AccessTier,
                                              AccessTierChangeTime, AccessTierInferred, Tags,
                                              Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, Snapshot, VersionId, IsCurrentVersion, Metadata,
                                              LastAccessTime, Tags, Etag, ContentType, ContentEncoding,
                                              ContentLanguage, ContentCRC64, CacheControl,
                                              ContentDisposition, LeaseStatus, LeaseState,
                                              LeaseDuration, ServerEncrypted, Deleted, DeletionId,
                                              DeletedTime, RemainingRetentionDays,
                                              ImmutabilityPolicyUntilDate, ImmutabilityPolicyMode,
                                              LegalHold, CopyId, CopyStatus, CopySource, CopyProgress,
                                              CopyCompletionTime, CopyStatusDescription,
                                              CustomerProvidedKeySha256, RehydratePriority,
                                              ArchiveStatus, XmsBlobSequenceNumber, EncryptionScope,
                                              IncrementalCopy, TagCount'. For Blob object type schema
                                              field value 'DeletedTime' is applicable only for Hns
                                              enabled accounts. The valid values for 'Container'
                                              definition.objectType include 'Name, Last-Modified,
                                              Metadata, LeaseStatus, LeaseState, LeaseDuration,
                                              PublicAccess, HasImmutabilityPolicy, HasLegalHold, Etag,
                                              DefaultEncryptionScope, DenyEncryptionScopeOverride,
                                              ImmutableStorageWithVersioningEnabled, Deleted, Version,
                                              DeletedTime, RemainingRetentionDays'. Schema field values
                                              'Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, DeletionId' are valid only for Hns enabled
                                              accounts.Schema field values 'Tags, TagCount' are only
                                              valid for Non-Hns accounts. Required.
                                        ],
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # Optional. An
                                                  array of predefined enum values. Valid values include
                                                  blockBlob, appendBlob, pageBlob. Hns accounts does
                                                  not support pageBlobs. This field is required when
                                                  definition.objectType property is set to 'Blob'.
                                            ],
                                            "creationTime": {
                                                "lastNDays": 0  #
                                                  Optional. When set the policy filters the objects
                                                  that are created in the last N days. Where N is an
                                                  integer value between 1 to 36500.
                                            },
                                            "excludePrefix": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  excluded from the inventory.
                                            ],
                                            "includeBlobVersions": bool,
                                              # Optional. Includes blob versions in blob inventory when
                                              value is set to true. The definition.schemaFields values
                                              'VersionId and IsCurrentVersion' are required if this
                                              property is set to true, else they must be excluded.
                                            "includeDeleted": bool,  #
                                              Optional. For 'Container' definition.objectType the
                                              definition.schemaFields must include 'Deleted, Version,
                                              DeletedTime and RemainingRetentionDays'. For 'Blob'
                                              definition.objectType and HNS enabled storage accounts
                                              the definition.schemaFields must include 'DeletionId,
                                              Deleted, DeletedTime and RemainingRetentionDays' and for
                                              Hns disabled accounts the definition.schemaFields must
                                              include 'Deleted and RemainingRetentionDays', else it
                                              must be excluded.
                                            "includeSnapshots": bool,  #
                                              Optional. Includes blob snapshots in blob inventory when
                                              value is set to true. The definition.schemaFields value
                                              'Snapshot' is required if this property is set to true,
                                              else it must be excluded.
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  included in the inventory.
                                            ]
                                        }
                                    },
                                    "destination": "str",  # Container name where
                                      blob inventory files are stored. Must be pre-created. Required.
                                    "enabled": bool,  # Rule is enabled when set
                                      to true. Required.
                                    "name": "str"  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                }
                            ],
                            "type": "str",  # The valid value is Inventory. Required.
                              "Inventory"
                            "destination": "str"  # Optional. Deprecated Property from
                              API version 2021-04-01 onwards, the required destination container name
                              must be specified at the rule level 'policy.rule.destination'.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          last modified date and time of the blob inventory policy.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "enabled": bool,  # Policy is enabled if set to true.
                              Required.
                            "rules": [
                                {
                                    "definition": {
                                        "format": "str",  # This is a
                                          required field, it specifies the format for the inventory
                                          files. Required. Known values are: "Csv" and "Parquet".
                                        "objectType": "str",  # This is a
                                          required field. This field specifies the scope of the
                                          inventory created either at the blob or container level.
                                          Required. Known values are: "Blob" and "Container".
                                        "schedule": "str",  # This is a
                                          required field. This field is used to schedule an inventory
                                          formation. Required. Known values are: "Daily" and "Weekly".
                                        "schemaFields": [
                                            "str"  # This is a required
                                              field. This field specifies the fields and properties of
                                              the object to be included in the inventory. The Schema
                                              field value 'Name' is always required. The valid values
                                              for this field for the 'Blob' definition.objectType
                                              include 'Name, Creation-Time, Last-Modified,
                                              Content-Length, Content-MD5, BlobType, AccessTier,
                                              AccessTierChangeTime, AccessTierInferred, Tags,
                                              Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, Snapshot, VersionId, IsCurrentVersion, Metadata,
                                              LastAccessTime, Tags, Etag, ContentType, ContentEncoding,
                                              ContentLanguage, ContentCRC64, CacheControl,
                                              ContentDisposition, LeaseStatus, LeaseState,
                                              LeaseDuration, ServerEncrypted, Deleted, DeletionId,
                                              DeletedTime, RemainingRetentionDays,
                                              ImmutabilityPolicyUntilDate, ImmutabilityPolicyMode,
                                              LegalHold, CopyId, CopyStatus, CopySource, CopyProgress,
                                              CopyCompletionTime, CopyStatusDescription,
                                              CustomerProvidedKeySha256, RehydratePriority,
                                              ArchiveStatus, XmsBlobSequenceNumber, EncryptionScope,
                                              IncrementalCopy, TagCount'. For Blob object type schema
                                              field value 'DeletedTime' is applicable only for Hns
                                              enabled accounts. The valid values for 'Container'
                                              definition.objectType include 'Name, Last-Modified,
                                              Metadata, LeaseStatus, LeaseState, LeaseDuration,
                                              PublicAccess, HasImmutabilityPolicy, HasLegalHold, Etag,
                                              DefaultEncryptionScope, DenyEncryptionScopeOverride,
                                              ImmutableStorageWithVersioningEnabled, Deleted, Version,
                                              DeletedTime, RemainingRetentionDays'. Schema field values
                                              'Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, DeletionId' are valid only for Hns enabled
                                              accounts.Schema field values 'Tags, TagCount' are only
                                              valid for Non-Hns accounts. Required.
                                        ],
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # Optional. An
                                                  array of predefined enum values. Valid values include
                                                  blockBlob, appendBlob, pageBlob. Hns accounts does
                                                  not support pageBlobs. This field is required when
                                                  definition.objectType property is set to 'Blob'.
                                            ],
                                            "creationTime": {
                                                "lastNDays": 0  #
                                                  Optional. When set the policy filters the objects
                                                  that are created in the last N days. Where N is an
                                                  integer value between 1 to 36500.
                                            },
                                            "excludePrefix": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  excluded from the inventory.
                                            ],
                                            "includeBlobVersions": bool,
                                              # Optional. Includes blob versions in blob inventory when
                                              value is set to true. The definition.schemaFields values
                                              'VersionId and IsCurrentVersion' are required if this
                                              property is set to true, else they must be excluded.
                                            "includeDeleted": bool,  #
                                              Optional. For 'Container' definition.objectType the
                                              definition.schemaFields must include 'Deleted, Version,
                                              DeletedTime and RemainingRetentionDays'. For 'Blob'
                                              definition.objectType and HNS enabled storage accounts
                                              the definition.schemaFields must include 'DeletionId,
                                              Deleted, DeletedTime and RemainingRetentionDays' and for
                                              Hns disabled accounts the definition.schemaFields must
                                              include 'Deleted and RemainingRetentionDays', else it
                                              must be excluded.
                                            "includeSnapshots": bool,  #
                                              Optional. Includes blob snapshots in blob inventory when
                                              value is set to true. The definition.schemaFields value
                                              'Snapshot' is required if this property is set to true,
                                              else it must be excluded.
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  included in the inventory.
                                            ]
                                        }
                                    },
                                    "destination": "str",  # Container name where
                                      blob inventory files are stored. Must be pre-created. Required.
                                    "enabled": bool,  # Rule is enabled when set
                                      to true. Required.
                                    "name": "str"  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                }
                            ],
                            "type": "str",  # The valid value is Inventory. Required.
                              "Inventory"
                            "destination": "str"  # Optional. Deprecated Property from
                              API version 2021-04-01 onwards, the required destination container name
                              must be specified at the rule level 'policy.rule.destination'.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          last modified date and time of the blob inventory policy.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        blob_inventory_policy_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sets the blob inventory policy to the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param blob_inventory_policy_name: The name of the storage account blob inventory policy. It
         should always be 'default'. "default" Required.
        :type blob_inventory_policy_name: str
        :param properties: The blob inventory policy set to a storage account. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "enabled": bool,  # Policy is enabled if set to true.
                              Required.
                            "rules": [
                                {
                                    "definition": {
                                        "format": "str",  # This is a
                                          required field, it specifies the format for the inventory
                                          files. Required. Known values are: "Csv" and "Parquet".
                                        "objectType": "str",  # This is a
                                          required field. This field specifies the scope of the
                                          inventory created either at the blob or container level.
                                          Required. Known values are: "Blob" and "Container".
                                        "schedule": "str",  # This is a
                                          required field. This field is used to schedule an inventory
                                          formation. Required. Known values are: "Daily" and "Weekly".
                                        "schemaFields": [
                                            "str"  # This is a required
                                              field. This field specifies the fields and properties of
                                              the object to be included in the inventory. The Schema
                                              field value 'Name' is always required. The valid values
                                              for this field for the 'Blob' definition.objectType
                                              include 'Name, Creation-Time, Last-Modified,
                                              Content-Length, Content-MD5, BlobType, AccessTier,
                                              AccessTierChangeTime, AccessTierInferred, Tags,
                                              Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, Snapshot, VersionId, IsCurrentVersion, Metadata,
                                              LastAccessTime, Tags, Etag, ContentType, ContentEncoding,
                                              ContentLanguage, ContentCRC64, CacheControl,
                                              ContentDisposition, LeaseStatus, LeaseState,
                                              LeaseDuration, ServerEncrypted, Deleted, DeletionId,
                                              DeletedTime, RemainingRetentionDays,
                                              ImmutabilityPolicyUntilDate, ImmutabilityPolicyMode,
                                              LegalHold, CopyId, CopyStatus, CopySource, CopyProgress,
                                              CopyCompletionTime, CopyStatusDescription,
                                              CustomerProvidedKeySha256, RehydratePriority,
                                              ArchiveStatus, XmsBlobSequenceNumber, EncryptionScope,
                                              IncrementalCopy, TagCount'. For Blob object type schema
                                              field value 'DeletedTime' is applicable only for Hns
                                              enabled accounts. The valid values for 'Container'
                                              definition.objectType include 'Name, Last-Modified,
                                              Metadata, LeaseStatus, LeaseState, LeaseDuration,
                                              PublicAccess, HasImmutabilityPolicy, HasLegalHold, Etag,
                                              DefaultEncryptionScope, DenyEncryptionScopeOverride,
                                              ImmutableStorageWithVersioningEnabled, Deleted, Version,
                                              DeletedTime, RemainingRetentionDays'. Schema field values
                                              'Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, DeletionId' are valid only for Hns enabled
                                              accounts.Schema field values 'Tags, TagCount' are only
                                              valid for Non-Hns accounts. Required.
                                        ],
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # Optional. An
                                                  array of predefined enum values. Valid values include
                                                  blockBlob, appendBlob, pageBlob. Hns accounts does
                                                  not support pageBlobs. This field is required when
                                                  definition.objectType property is set to 'Blob'.
                                            ],
                                            "creationTime": {
                                                "lastNDays": 0  #
                                                  Optional. When set the policy filters the objects
                                                  that are created in the last N days. Where N is an
                                                  integer value between 1 to 36500.
                                            },
                                            "excludePrefix": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  excluded from the inventory.
                                            ],
                                            "includeBlobVersions": bool,
                                              # Optional. Includes blob versions in blob inventory when
                                              value is set to true. The definition.schemaFields values
                                              'VersionId and IsCurrentVersion' are required if this
                                              property is set to true, else they must be excluded.
                                            "includeDeleted": bool,  #
                                              Optional. For 'Container' definition.objectType the
                                              definition.schemaFields must include 'Deleted, Version,
                                              DeletedTime and RemainingRetentionDays'. For 'Blob'
                                              definition.objectType and HNS enabled storage accounts
                                              the definition.schemaFields must include 'DeletionId,
                                              Deleted, DeletedTime and RemainingRetentionDays' and for
                                              Hns disabled accounts the definition.schemaFields must
                                              include 'Deleted and RemainingRetentionDays', else it
                                              must be excluded.
                                            "includeSnapshots": bool,  #
                                              Optional. Includes blob snapshots in blob inventory when
                                              value is set to true. The definition.schemaFields value
                                              'Snapshot' is required if this property is set to true,
                                              else it must be excluded.
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  included in the inventory.
                                            ]
                                        }
                                    },
                                    "destination": "str",  # Container name where
                                      blob inventory files are stored. Must be pre-created. Required.
                                    "enabled": bool,  # Rule is enabled when set
                                      to true. Required.
                                    "name": "str"  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                }
                            ],
                            "type": "str",  # The valid value is Inventory. Required.
                              "Inventory"
                            "destination": "str"  # Optional. Deprecated Property from
                              API version 2021-04-01 onwards, the required destination container name
                              must be specified at the rule level 'policy.rule.destination'.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          last modified date and time of the blob inventory policy.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        blob_inventory_policy_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Sets the blob inventory policy to the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param blob_inventory_policy_name: The name of the storage account blob inventory policy. It
         should always be 'default'. "default" Required.
        :type blob_inventory_policy_name: str
        :param properties: The blob inventory policy set to a storage account. Is either a JSON type or
         a IO type. Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "enabled": bool,  # Policy is enabled if set to true.
                              Required.
                            "rules": [
                                {
                                    "definition": {
                                        "format": "str",  # This is a
                                          required field, it specifies the format for the inventory
                                          files. Required. Known values are: "Csv" and "Parquet".
                                        "objectType": "str",  # This is a
                                          required field. This field specifies the scope of the
                                          inventory created either at the blob or container level.
                                          Required. Known values are: "Blob" and "Container".
                                        "schedule": "str",  # This is a
                                          required field. This field is used to schedule an inventory
                                          formation. Required. Known values are: "Daily" and "Weekly".
                                        "schemaFields": [
                                            "str"  # This is a required
                                              field. This field specifies the fields and properties of
                                              the object to be included in the inventory. The Schema
                                              field value 'Name' is always required. The valid values
                                              for this field for the 'Blob' definition.objectType
                                              include 'Name, Creation-Time, Last-Modified,
                                              Content-Length, Content-MD5, BlobType, AccessTier,
                                              AccessTierChangeTime, AccessTierInferred, Tags,
                                              Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, Snapshot, VersionId, IsCurrentVersion, Metadata,
                                              LastAccessTime, Tags, Etag, ContentType, ContentEncoding,
                                              ContentLanguage, ContentCRC64, CacheControl,
                                              ContentDisposition, LeaseStatus, LeaseState,
                                              LeaseDuration, ServerEncrypted, Deleted, DeletionId,
                                              DeletedTime, RemainingRetentionDays,
                                              ImmutabilityPolicyUntilDate, ImmutabilityPolicyMode,
                                              LegalHold, CopyId, CopyStatus, CopySource, CopyProgress,
                                              CopyCompletionTime, CopyStatusDescription,
                                              CustomerProvidedKeySha256, RehydratePriority,
                                              ArchiveStatus, XmsBlobSequenceNumber, EncryptionScope,
                                              IncrementalCopy, TagCount'. For Blob object type schema
                                              field value 'DeletedTime' is applicable only for Hns
                                              enabled accounts. The valid values for 'Container'
                                              definition.objectType include 'Name, Last-Modified,
                                              Metadata, LeaseStatus, LeaseState, LeaseDuration,
                                              PublicAccess, HasImmutabilityPolicy, HasLegalHold, Etag,
                                              DefaultEncryptionScope, DenyEncryptionScopeOverride,
                                              ImmutableStorageWithVersioningEnabled, Deleted, Version,
                                              DeletedTime, RemainingRetentionDays'. Schema field values
                                              'Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, DeletionId' are valid only for Hns enabled
                                              accounts.Schema field values 'Tags, TagCount' are only
                                              valid for Non-Hns accounts. Required.
                                        ],
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # Optional. An
                                                  array of predefined enum values. Valid values include
                                                  blockBlob, appendBlob, pageBlob. Hns accounts does
                                                  not support pageBlobs. This field is required when
                                                  definition.objectType property is set to 'Blob'.
                                            ],
                                            "creationTime": {
                                                "lastNDays": 0  #
                                                  Optional. When set the policy filters the objects
                                                  that are created in the last N days. Where N is an
                                                  integer value between 1 to 36500.
                                            },
                                            "excludePrefix": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  excluded from the inventory.
                                            ],
                                            "includeBlobVersions": bool,
                                              # Optional. Includes blob versions in blob inventory when
                                              value is set to true. The definition.schemaFields values
                                              'VersionId and IsCurrentVersion' are required if this
                                              property is set to true, else they must be excluded.
                                            "includeDeleted": bool,  #
                                              Optional. For 'Container' definition.objectType the
                                              definition.schemaFields must include 'Deleted, Version,
                                              DeletedTime and RemainingRetentionDays'. For 'Blob'
                                              definition.objectType and HNS enabled storage accounts
                                              the definition.schemaFields must include 'DeletionId,
                                              Deleted, DeletedTime and RemainingRetentionDays' and for
                                              Hns disabled accounts the definition.schemaFields must
                                              include 'Deleted and RemainingRetentionDays', else it
                                              must be excluded.
                                            "includeSnapshots": bool,  #
                                              Optional. Includes blob snapshots in blob inventory when
                                              value is set to true. The definition.schemaFields value
                                              'Snapshot' is required if this property is set to true,
                                              else it must be excluded.
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  included in the inventory.
                                            ]
                                        }
                                    },
                                    "destination": "str",  # Container name where
                                      blob inventory files are stored. Must be pre-created. Required.
                                    "enabled": bool,  # Rule is enabled when set
                                      to true. Required.
                                    "name": "str"  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                }
                            ],
                            "type": "str",  # The valid value is Inventory. Required.
                              "Inventory"
                            "destination": "str"  # Optional. Deprecated Property from
                              API version 2021-04-01 onwards, the required destination container name
                              must be specified at the rule level 'policy.rule.destination'.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          last modified date and time of the blob inventory policy.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "enabled": bool,  # Policy is enabled if set to true.
                              Required.
                            "rules": [
                                {
                                    "definition": {
                                        "format": "str",  # This is a
                                          required field, it specifies the format for the inventory
                                          files. Required. Known values are: "Csv" and "Parquet".
                                        "objectType": "str",  # This is a
                                          required field. This field specifies the scope of the
                                          inventory created either at the blob or container level.
                                          Required. Known values are: "Blob" and "Container".
                                        "schedule": "str",  # This is a
                                          required field. This field is used to schedule an inventory
                                          formation. Required. Known values are: "Daily" and "Weekly".
                                        "schemaFields": [
                                            "str"  # This is a required
                                              field. This field specifies the fields and properties of
                                              the object to be included in the inventory. The Schema
                                              field value 'Name' is always required. The valid values
                                              for this field for the 'Blob' definition.objectType
                                              include 'Name, Creation-Time, Last-Modified,
                                              Content-Length, Content-MD5, BlobType, AccessTier,
                                              AccessTierChangeTime, AccessTierInferred, Tags,
                                              Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, Snapshot, VersionId, IsCurrentVersion, Metadata,
                                              LastAccessTime, Tags, Etag, ContentType, ContentEncoding,
                                              ContentLanguage, ContentCRC64, CacheControl,
                                              ContentDisposition, LeaseStatus, LeaseState,
                                              LeaseDuration, ServerEncrypted, Deleted, DeletionId,
                                              DeletedTime, RemainingRetentionDays,
                                              ImmutabilityPolicyUntilDate, ImmutabilityPolicyMode,
                                              LegalHold, CopyId, CopyStatus, CopySource, CopyProgress,
                                              CopyCompletionTime, CopyStatusDescription,
                                              CustomerProvidedKeySha256, RehydratePriority,
                                              ArchiveStatus, XmsBlobSequenceNumber, EncryptionScope,
                                              IncrementalCopy, TagCount'. For Blob object type schema
                                              field value 'DeletedTime' is applicable only for Hns
                                              enabled accounts. The valid values for 'Container'
                                              definition.objectType include 'Name, Last-Modified,
                                              Metadata, LeaseStatus, LeaseState, LeaseDuration,
                                              PublicAccess, HasImmutabilityPolicy, HasLegalHold, Etag,
                                              DefaultEncryptionScope, DenyEncryptionScopeOverride,
                                              ImmutableStorageWithVersioningEnabled, Deleted, Version,
                                              DeletedTime, RemainingRetentionDays'. Schema field values
                                              'Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, DeletionId' are valid only for Hns enabled
                                              accounts.Schema field values 'Tags, TagCount' are only
                                              valid for Non-Hns accounts. Required.
                                        ],
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # Optional. An
                                                  array of predefined enum values. Valid values include
                                                  blockBlob, appendBlob, pageBlob. Hns accounts does
                                                  not support pageBlobs. This field is required when
                                                  definition.objectType property is set to 'Blob'.
                                            ],
                                            "creationTime": {
                                                "lastNDays": 0  #
                                                  Optional. When set the policy filters the objects
                                                  that are created in the last N days. Where N is an
                                                  integer value between 1 to 36500.
                                            },
                                            "excludePrefix": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  excluded from the inventory.
                                            ],
                                            "includeBlobVersions": bool,
                                              # Optional. Includes blob versions in blob inventory when
                                              value is set to true. The definition.schemaFields values
                                              'VersionId and IsCurrentVersion' are required if this
                                              property is set to true, else they must be excluded.
                                            "includeDeleted": bool,  #
                                              Optional. For 'Container' definition.objectType the
                                              definition.schemaFields must include 'Deleted, Version,
                                              DeletedTime and RemainingRetentionDays'. For 'Blob'
                                              definition.objectType and HNS enabled storage accounts
                                              the definition.schemaFields must include 'DeletionId,
                                              Deleted, DeletedTime and RemainingRetentionDays' and for
                                              Hns disabled accounts the definition.schemaFields must
                                              include 'Deleted and RemainingRetentionDays', else it
                                              must be excluded.
                                            "includeSnapshots": bool,  #
                                              Optional. Includes blob snapshots in blob inventory when
                                              value is set to true. The definition.schemaFields value
                                              'Snapshot' is required if this property is set to true,
                                              else it must be excluded.
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  included in the inventory.
                                            ]
                                        }
                                    },
                                    "destination": "str",  # Container name where
                                      blob inventory files are stored. Must be pre-created. Required.
                                    "enabled": bool,  # Rule is enabled when set
                                      to true. Required.
                                    "name": "str"  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                }
                            ],
                            "type": "str",  # The valid value is Inventory. Required.
                              "Inventory"
                            "destination": "str"  # Optional. Deprecated Property from
                              API version 2021-04-01 onwards, the required destination container name
                              must be specified at the rule level 'policy.rule.destination'.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          last modified date and time of the blob inventory policy.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_blob_inventory_policies_create_or_update_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            blob_inventory_policy_name=blob_inventory_policy_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, blob_inventory_policy_name: str, **kwargs: Any
    ) -> None:
        """Deletes the blob inventory policy associated with the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param blob_inventory_policy_name: The name of the storage account blob inventory policy. It
         should always be 'default'. "default" Required.
        :type blob_inventory_policy_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_blob_inventory_policies_delete_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            blob_inventory_policy_name=blob_inventory_policy_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list(self, resource_group_name: str, account_name: str, **kwargs: Any) -> Iterable[JSON]:
        """Gets the blob inventory policy associated with the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "policy": {
                            "enabled": bool,  # Policy is enabled if set to true.
                              Required.
                            "rules": [
                                {
                                    "definition": {
                                        "format": "str",  # This is a
                                          required field, it specifies the format for the inventory
                                          files. Required. Known values are: "Csv" and "Parquet".
                                        "objectType": "str",  # This is a
                                          required field. This field specifies the scope of the
                                          inventory created either at the blob or container level.
                                          Required. Known values are: "Blob" and "Container".
                                        "schedule": "str",  # This is a
                                          required field. This field is used to schedule an inventory
                                          formation. Required. Known values are: "Daily" and "Weekly".
                                        "schemaFields": [
                                            "str"  # This is a required
                                              field. This field specifies the fields and properties of
                                              the object to be included in the inventory. The Schema
                                              field value 'Name' is always required. The valid values
                                              for this field for the 'Blob' definition.objectType
                                              include 'Name, Creation-Time, Last-Modified,
                                              Content-Length, Content-MD5, BlobType, AccessTier,
                                              AccessTierChangeTime, AccessTierInferred, Tags,
                                              Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, Snapshot, VersionId, IsCurrentVersion, Metadata,
                                              LastAccessTime, Tags, Etag, ContentType, ContentEncoding,
                                              ContentLanguage, ContentCRC64, CacheControl,
                                              ContentDisposition, LeaseStatus, LeaseState,
                                              LeaseDuration, ServerEncrypted, Deleted, DeletionId,
                                              DeletedTime, RemainingRetentionDays,
                                              ImmutabilityPolicyUntilDate, ImmutabilityPolicyMode,
                                              LegalHold, CopyId, CopyStatus, CopySource, CopyProgress,
                                              CopyCompletionTime, CopyStatusDescription,
                                              CustomerProvidedKeySha256, RehydratePriority,
                                              ArchiveStatus, XmsBlobSequenceNumber, EncryptionScope,
                                              IncrementalCopy, TagCount'. For Blob object type schema
                                              field value 'DeletedTime' is applicable only for Hns
                                              enabled accounts. The valid values for 'Container'
                                              definition.objectType include 'Name, Last-Modified,
                                              Metadata, LeaseStatus, LeaseState, LeaseDuration,
                                              PublicAccess, HasImmutabilityPolicy, HasLegalHold, Etag,
                                              DefaultEncryptionScope, DenyEncryptionScopeOverride,
                                              ImmutableStorageWithVersioningEnabled, Deleted, Version,
                                              DeletedTime, RemainingRetentionDays'. Schema field values
                                              'Expiry-Time, hdi_isfolder, Owner, Group, Permissions,
                                              Acl, DeletionId' are valid only for Hns enabled
                                              accounts.Schema field values 'Tags, TagCount' are only
                                              valid for Non-Hns accounts. Required.
                                        ],
                                        "filters": {
                                            "blobTypes": [
                                                "str"  # Optional. An
                                                  array of predefined enum values. Valid values include
                                                  blockBlob, appendBlob, pageBlob. Hns accounts does
                                                  not support pageBlobs. This field is required when
                                                  definition.objectType property is set to 'Blob'.
                                            ],
                                            "creationTime": {
                                                "lastNDays": 0  #
                                                  Optional. When set the policy filters the objects
                                                  that are created in the last N days. Where N is an
                                                  integer value between 1 to 36500.
                                            },
                                            "excludePrefix": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  excluded from the inventory.
                                            ],
                                            "includeBlobVersions": bool,
                                              # Optional. Includes blob versions in blob inventory when
                                              value is set to true. The definition.schemaFields values
                                              'VersionId and IsCurrentVersion' are required if this
                                              property is set to true, else they must be excluded.
                                            "includeDeleted": bool,  #
                                              Optional. For 'Container' definition.objectType the
                                              definition.schemaFields must include 'Deleted, Version,
                                              DeletedTime and RemainingRetentionDays'. For 'Blob'
                                              definition.objectType and HNS enabled storage accounts
                                              the definition.schemaFields must include 'DeletionId,
                                              Deleted, DeletedTime and RemainingRetentionDays' and for
                                              Hns disabled accounts the definition.schemaFields must
                                              include 'Deleted and RemainingRetentionDays', else it
                                              must be excluded.
                                            "includeSnapshots": bool,  #
                                              Optional. Includes blob snapshots in blob inventory when
                                              value is set to true. The definition.schemaFields value
                                              'Snapshot' is required if this property is set to true,
                                              else it must be excluded.
                                            "prefixMatch": [
                                                "str"  # Optional. An
                                                  array of strings with maximum 10 blob prefixes to be
                                                  included in the inventory.
                                            ]
                                        }
                                    },
                                    "destination": "str",  # Container name where
                                      blob inventory files are stored. Must be pre-created. Required.
                                    "enabled": bool,  # Rule is enabled when set
                                      to true. Required.
                                    "name": "str"  # A rule name can contain any
                                      combination of alpha numeric characters. Rule name is
                                      case-sensitive. It must be unique within a policy. Required.
                                }
                            ],
                            "type": "str",  # The valid value is Inventory. Required.
                              "Inventory"
                            "destination": "str"  # Optional. Deprecated Property from
                              API version 2021-04-01 onwards, the required destination container name
                              must be specified at the rule level 'policy.rule.destination'.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00"  # Optional. Returns the
                          last modified date and time of the blob inventory policy.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_blob_inventory_policies_list_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class PrivateEndpointConnectionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`private_endpoint_connections` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, account_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List all the private endpoint connections associated with the storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateLinkServiceConnectionState": {
                            "actionRequired": "str",  # Optional. A message indicating if
                              changes on the service provider require any updates on the consumer.
                            "description": "str",  # Optional. The reason for
                              approval/rejection of the connection.
                            "status": "str"  # Optional. Indicates whether the connection
                              has been Approved/Rejected/Removed by the owner of the service. Known
                              values are: "Pending", "Approved", and "Rejected".
                        },
                        "privateEndpoint": {
                            "id": "str"  # Optional. The ARM identifier for Private
                              Endpoint.
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          private endpoint connection resource. Known values are: "Succeeded",
                          "Creating", "Deleting", and "Failed".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_private_endpoint_connections_list_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self, resource_group_name: str, account_name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> JSON:
        """Gets the specified private endpoint connection associated with the storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection associated
         with the Azure resource. Required.
        :type private_endpoint_connection_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateLinkServiceConnectionState": {
                            "actionRequired": "str",  # Optional. A message indicating if
                              changes on the service provider require any updates on the consumer.
                            "description": "str",  # Optional. The reason for
                              approval/rejection of the connection.
                            "status": "str"  # Optional. Indicates whether the connection
                              has been Approved/Rejected/Removed by the owner of the service. Known
                              values are: "Pending", "Approved", and "Rejected".
                        },
                        "privateEndpoint": {
                            "id": "str"  # Optional. The ARM identifier for Private
                              Endpoint.
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          private endpoint connection resource. Known values are: "Succeeded",
                          "Creating", "Deleting", and "Failed".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_private_endpoint_connections_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def put(
        self,
        resource_group_name: str,
        account_name: str,
        private_endpoint_connection_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the state of specified private endpoint connection associated with the storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection associated
         with the Azure resource. Required.
        :type private_endpoint_connection_name: str
        :param properties: The private endpoint connection properties. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateLinkServiceConnectionState": {
                            "actionRequired": "str",  # Optional. A message indicating if
                              changes on the service provider require any updates on the consumer.
                            "description": "str",  # Optional. The reason for
                              approval/rejection of the connection.
                            "status": "str"  # Optional. Indicates whether the connection
                              has been Approved/Rejected/Removed by the owner of the service. Known
                              values are: "Pending", "Approved", and "Rejected".
                        },
                        "privateEndpoint": {
                            "id": "str"  # Optional. The ARM identifier for Private
                              Endpoint.
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          private endpoint connection resource. Known values are: "Succeeded",
                          "Creating", "Deleting", and "Failed".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateLinkServiceConnectionState": {
                            "actionRequired": "str",  # Optional. A message indicating if
                              changes on the service provider require any updates on the consumer.
                            "description": "str",  # Optional. The reason for
                              approval/rejection of the connection.
                            "status": "str"  # Optional. Indicates whether the connection
                              has been Approved/Rejected/Removed by the owner of the service. Known
                              values are: "Pending", "Approved", and "Rejected".
                        },
                        "privateEndpoint": {
                            "id": "str"  # Optional. The ARM identifier for Private
                              Endpoint.
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          private endpoint connection resource. Known values are: "Succeeded",
                          "Creating", "Deleting", and "Failed".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def put(
        self,
        resource_group_name: str,
        account_name: str,
        private_endpoint_connection_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the state of specified private endpoint connection associated with the storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection associated
         with the Azure resource. Required.
        :type private_endpoint_connection_name: str
        :param properties: The private endpoint connection properties. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateLinkServiceConnectionState": {
                            "actionRequired": "str",  # Optional. A message indicating if
                              changes on the service provider require any updates on the consumer.
                            "description": "str",  # Optional. The reason for
                              approval/rejection of the connection.
                            "status": "str"  # Optional. Indicates whether the connection
                              has been Approved/Rejected/Removed by the owner of the service. Known
                              values are: "Pending", "Approved", and "Rejected".
                        },
                        "privateEndpoint": {
                            "id": "str"  # Optional. The ARM identifier for Private
                              Endpoint.
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          private endpoint connection resource. Known values are: "Succeeded",
                          "Creating", "Deleting", and "Failed".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def put(
        self,
        resource_group_name: str,
        account_name: str,
        private_endpoint_connection_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Update the state of specified private endpoint connection associated with the storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection associated
         with the Azure resource. Required.
        :type private_endpoint_connection_name: str
        :param properties: The private endpoint connection properties. Is either a JSON type or a IO
         type. Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateLinkServiceConnectionState": {
                            "actionRequired": "str",  # Optional. A message indicating if
                              changes on the service provider require any updates on the consumer.
                            "description": "str",  # Optional. The reason for
                              approval/rejection of the connection.
                            "status": "str"  # Optional. Indicates whether the connection
                              has been Approved/Rejected/Removed by the owner of the service. Known
                              values are: "Pending", "Approved", and "Rejected".
                        },
                        "privateEndpoint": {
                            "id": "str"  # Optional. The ARM identifier for Private
                              Endpoint.
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          private endpoint connection resource. Known values are: "Succeeded",
                          "Creating", "Deleting", and "Failed".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "privateLinkServiceConnectionState": {
                            "actionRequired": "str",  # Optional. A message indicating if
                              changes on the service provider require any updates on the consumer.
                            "description": "str",  # Optional. The reason for
                              approval/rejection of the connection.
                            "status": "str"  # Optional. Indicates whether the connection
                              has been Approved/Rejected/Removed by the owner of the service. Known
                              values are: "Pending", "Approved", and "Rejected".
                        },
                        "privateEndpoint": {
                            "id": "str"  # Optional. The ARM identifier for Private
                              Endpoint.
                        },
                        "provisioningState": "str"  # Optional. The provisioning state of the
                          private endpoint connection resource. Known values are: "Succeeded",
                          "Creating", "Deleting", and "Failed".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_private_endpoint_connections_put_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, private_endpoint_connection_name: str, **kwargs: Any
    ) -> None:
        """Deletes the specified private endpoint connection associated with the storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param private_endpoint_connection_name: The name of the private endpoint connection associated
         with the Azure resource. Required.
        :type private_endpoint_connection_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_private_endpoint_connections_delete_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            private_endpoint_connection_name=private_endpoint_connection_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class PrivateLinkResourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`private_link_resources` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_storage_account(self, resource_group_name: str, account_name: str, **kwargs: Any) -> JSON:
        """Gets the private link resources that need to be created for a storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "id": "str",  # Optional. Fully qualified resource ID for the
                              resource. Ex -
                              /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                            "name": "str",  # Optional. The name of the resource.
                            "properties": {
                                "groupId": "str",  # Optional. The private link
                                  resource group id.
                                "requiredMembers": [
                                    "str"  # Optional. The private link resource
                                      required member names.
                                ],
                                "requiredZoneNames": [
                                    "str"  # Optional. The private link resource
                                      Private link DNS zone name.
                                ]
                            },
                            "type": "str"  # Optional. The type of the resource. E.g.
                              "Microsoft.Compute/virtualMachines" or
                              "Microsoft.Storage/storageAccounts".
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_private_link_resources_list_by_storage_account_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class ObjectReplicationPoliciesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`object_replication_policies` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, resource_group_name: str, account_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List the object replication policies associated with the storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destinationAccount": "str",  # Required. Destination account name.
                          It should be full resource id if allowCrossTenantReplication set to false.
                          Required.
                        "sourceAccount": "str",  # Required. Source account name. It should
                          be full resource id if allowCrossTenantReplication set to false. Required.
                        "enabledTime": "2020-02-20 00:00:00",  # Optional. Indicates when the
                          policy is enabled on the source account.
                        "policyId": "str",  # Optional. A unique id for object replication
                          policy.
                        "rules": [
                            {
                                "destinationContainer": "str",  # Required.
                                  Destination container name. Required.
                                "sourceContainer": "str",  # Required. Source
                                  container name. Required.
                                "filters": {
                                    "minCreationTime": "str",  # Optional. Blobs
                                      created after the time will be replicated to the destination. It
                                      must be in datetime format 'yyyy-MM-ddTHH:mm:ssZ'. Example:
                                      2020-02-19T16:05:00Z.
                                    "prefixMatch": [
                                        "str"  # Optional. Optional. Filters
                                          the results to replicate only blobs whose names begin with
                                          the specified prefix.
                                    ]
                                },
                                "ruleId": "str"  # Optional. Rule Id is
                                  auto-generated for each new rule on destination account. It is
                                  required for put policy on source account.
                            }
                        ]
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_object_replication_policies_list_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self, resource_group_name: str, account_name: str, object_replication_policy_id: str, **kwargs: Any
    ) -> JSON:
        """Get the object replication policy of the storage account by policy ID.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param object_replication_policy_id: For the destination account, provide the value 'default'.
         Configure the policy on the destination account first. For the source account, provide the
         value of the policy ID that is returned when you download the policy that was defined on the
         destination account. The policy is downloaded as a JSON file. Required.
        :type object_replication_policy_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destinationAccount": "str",  # Required. Destination account name.
                          It should be full resource id if allowCrossTenantReplication set to false.
                          Required.
                        "sourceAccount": "str",  # Required. Source account name. It should
                          be full resource id if allowCrossTenantReplication set to false. Required.
                        "enabledTime": "2020-02-20 00:00:00",  # Optional. Indicates when the
                          policy is enabled on the source account.
                        "policyId": "str",  # Optional. A unique id for object replication
                          policy.
                        "rules": [
                            {
                                "destinationContainer": "str",  # Required.
                                  Destination container name. Required.
                                "sourceContainer": "str",  # Required. Source
                                  container name. Required.
                                "filters": {
                                    "minCreationTime": "str",  # Optional. Blobs
                                      created after the time will be replicated to the destination. It
                                      must be in datetime format 'yyyy-MM-ddTHH:mm:ssZ'. Example:
                                      2020-02-19T16:05:00Z.
                                    "prefixMatch": [
                                        "str"  # Optional. Optional. Filters
                                          the results to replicate only blobs whose names begin with
                                          the specified prefix.
                                    ]
                                },
                                "ruleId": "str"  # Optional. Rule Id is
                                  auto-generated for each new rule on destination account. It is
                                  required for put policy on source account.
                            }
                        ]
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_object_replication_policies_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            object_replication_policy_id=object_replication_policy_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        object_replication_policy_id: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create or update the object replication policy of the storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param object_replication_policy_id: For the destination account, provide the value 'default'.
         Configure the policy on the destination account first. For the source account, provide the
         value of the policy ID that is returned when you download the policy that was defined on the
         destination account. The policy is downloaded as a JSON file. Required.
        :type object_replication_policy_id: str
        :param properties: The object replication policy set to a storage account. A unique policy ID
         will be created if absent. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destinationAccount": "str",  # Required. Destination account name.
                          It should be full resource id if allowCrossTenantReplication set to false.
                          Required.
                        "sourceAccount": "str",  # Required. Source account name. It should
                          be full resource id if allowCrossTenantReplication set to false. Required.
                        "enabledTime": "2020-02-20 00:00:00",  # Optional. Indicates when the
                          policy is enabled on the source account.
                        "policyId": "str",  # Optional. A unique id for object replication
                          policy.
                        "rules": [
                            {
                                "destinationContainer": "str",  # Required.
                                  Destination container name. Required.
                                "sourceContainer": "str",  # Required. Source
                                  container name. Required.
                                "filters": {
                                    "minCreationTime": "str",  # Optional. Blobs
                                      created after the time will be replicated to the destination. It
                                      must be in datetime format 'yyyy-MM-ddTHH:mm:ssZ'. Example:
                                      2020-02-19T16:05:00Z.
                                    "prefixMatch": [
                                        "str"  # Optional. Optional. Filters
                                          the results to replicate only blobs whose names begin with
                                          the specified prefix.
                                    ]
                                },
                                "ruleId": "str"  # Optional. Rule Id is
                                  auto-generated for each new rule on destination account. It is
                                  required for put policy on source account.
                            }
                        ]
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destinationAccount": "str",  # Required. Destination account name.
                          It should be full resource id if allowCrossTenantReplication set to false.
                          Required.
                        "sourceAccount": "str",  # Required. Source account name. It should
                          be full resource id if allowCrossTenantReplication set to false. Required.
                        "enabledTime": "2020-02-20 00:00:00",  # Optional. Indicates when the
                          policy is enabled on the source account.
                        "policyId": "str",  # Optional. A unique id for object replication
                          policy.
                        "rules": [
                            {
                                "destinationContainer": "str",  # Required.
                                  Destination container name. Required.
                                "sourceContainer": "str",  # Required. Source
                                  container name. Required.
                                "filters": {
                                    "minCreationTime": "str",  # Optional. Blobs
                                      created after the time will be replicated to the destination. It
                                      must be in datetime format 'yyyy-MM-ddTHH:mm:ssZ'. Example:
                                      2020-02-19T16:05:00Z.
                                    "prefixMatch": [
                                        "str"  # Optional. Optional. Filters
                                          the results to replicate only blobs whose names begin with
                                          the specified prefix.
                                    ]
                                },
                                "ruleId": "str"  # Optional. Rule Id is
                                  auto-generated for each new rule on destination account. It is
                                  required for put policy on source account.
                            }
                        ]
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        object_replication_policy_id: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create or update the object replication policy of the storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param object_replication_policy_id: For the destination account, provide the value 'default'.
         Configure the policy on the destination account first. For the source account, provide the
         value of the policy ID that is returned when you download the policy that was defined on the
         destination account. The policy is downloaded as a JSON file. Required.
        :type object_replication_policy_id: str
        :param properties: The object replication policy set to a storage account. A unique policy ID
         will be created if absent. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destinationAccount": "str",  # Required. Destination account name.
                          It should be full resource id if allowCrossTenantReplication set to false.
                          Required.
                        "sourceAccount": "str",  # Required. Source account name. It should
                          be full resource id if allowCrossTenantReplication set to false. Required.
                        "enabledTime": "2020-02-20 00:00:00",  # Optional. Indicates when the
                          policy is enabled on the source account.
                        "policyId": "str",  # Optional. A unique id for object replication
                          policy.
                        "rules": [
                            {
                                "destinationContainer": "str",  # Required.
                                  Destination container name. Required.
                                "sourceContainer": "str",  # Required. Source
                                  container name. Required.
                                "filters": {
                                    "minCreationTime": "str",  # Optional. Blobs
                                      created after the time will be replicated to the destination. It
                                      must be in datetime format 'yyyy-MM-ddTHH:mm:ssZ'. Example:
                                      2020-02-19T16:05:00Z.
                                    "prefixMatch": [
                                        "str"  # Optional. Optional. Filters
                                          the results to replicate only blobs whose names begin with
                                          the specified prefix.
                                    ]
                                },
                                "ruleId": "str"  # Optional. Rule Id is
                                  auto-generated for each new rule on destination account. It is
                                  required for put policy on source account.
                            }
                        ]
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        object_replication_policy_id: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Create or update the object replication policy of the storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param object_replication_policy_id: For the destination account, provide the value 'default'.
         Configure the policy on the destination account first. For the source account, provide the
         value of the policy ID that is returned when you download the policy that was defined on the
         destination account. The policy is downloaded as a JSON file. Required.
        :type object_replication_policy_id: str
        :param properties: The object replication policy set to a storage account. A unique policy ID
         will be created if absent. Is either a JSON type or a IO type. Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destinationAccount": "str",  # Required. Destination account name.
                          It should be full resource id if allowCrossTenantReplication set to false.
                          Required.
                        "sourceAccount": "str",  # Required. Source account name. It should
                          be full resource id if allowCrossTenantReplication set to false. Required.
                        "enabledTime": "2020-02-20 00:00:00",  # Optional. Indicates when the
                          policy is enabled on the source account.
                        "policyId": "str",  # Optional. A unique id for object replication
                          policy.
                        "rules": [
                            {
                                "destinationContainer": "str",  # Required.
                                  Destination container name. Required.
                                "sourceContainer": "str",  # Required. Source
                                  container name. Required.
                                "filters": {
                                    "minCreationTime": "str",  # Optional. Blobs
                                      created after the time will be replicated to the destination. It
                                      must be in datetime format 'yyyy-MM-ddTHH:mm:ssZ'. Example:
                                      2020-02-19T16:05:00Z.
                                    "prefixMatch": [
                                        "str"  # Optional. Optional. Filters
                                          the results to replicate only blobs whose names begin with
                                          the specified prefix.
                                    ]
                                },
                                "ruleId": "str"  # Optional. Rule Id is
                                  auto-generated for each new rule on destination account. It is
                                  required for put policy on source account.
                            }
                        ]
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "destinationAccount": "str",  # Required. Destination account name.
                          It should be full resource id if allowCrossTenantReplication set to false.
                          Required.
                        "sourceAccount": "str",  # Required. Source account name. It should
                          be full resource id if allowCrossTenantReplication set to false. Required.
                        "enabledTime": "2020-02-20 00:00:00",  # Optional. Indicates when the
                          policy is enabled on the source account.
                        "policyId": "str",  # Optional. A unique id for object replication
                          policy.
                        "rules": [
                            {
                                "destinationContainer": "str",  # Required.
                                  Destination container name. Required.
                                "sourceContainer": "str",  # Required. Source
                                  container name. Required.
                                "filters": {
                                    "minCreationTime": "str",  # Optional. Blobs
                                      created after the time will be replicated to the destination. It
                                      must be in datetime format 'yyyy-MM-ddTHH:mm:ssZ'. Example:
                                      2020-02-19T16:05:00Z.
                                    "prefixMatch": [
                                        "str"  # Optional. Optional. Filters
                                          the results to replicate only blobs whose names begin with
                                          the specified prefix.
                                    ]
                                },
                                "ruleId": "str"  # Optional. Rule Id is
                                  auto-generated for each new rule on destination account. It is
                                  required for put policy on source account.
                            }
                        ]
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_object_replication_policies_create_or_update_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            object_replication_policy_id=object_replication_policy_id,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, object_replication_policy_id: str, **kwargs: Any
    ) -> None:
        """Deletes the object replication policy associated with the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param object_replication_policy_id: For the destination account, provide the value 'default'.
         Configure the policy on the destination account first. For the source account, provide the
         value of the policy ID that is returned when you download the policy that was defined on the
         destination account. The policy is downloaded as a JSON file. Required.
        :type object_replication_policy_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_object_replication_policies_delete_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            object_replication_policy_id=object_replication_policy_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class LocalUsersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`local_users` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        resource_group_name: str,
        account_name: str,
        *,
        filter: Optional[str] = None,
        include: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """List the local users associated with the storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :keyword filter: Optional. When specified, only local user names starting with the filter will
         be listed. Default value is None.
        :paramtype filter: str
        :keyword include: Optional, when specified, will list local users enabled for the specific
         protocol. Lists all users by default. "nfsv3" Default value is None.
        :paramtype include: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "allowAclAuthorization": bool,  # Optional. Indicates whether ACL
                          authorization is allowed for this user. Set it to false to disallow using ACL
                          authorization.
                        "extendedGroups": [
                            0  # Optional. Supplementary group membership. Only
                              applicable for local users enabled for NFSv3 access.
                        ],
                        "groupId": 0,  # Optional. An identifier for associating a group of
                          users.
                        "hasSharedKey": bool,  # Optional. Indicates whether shared key
                          exists. Set it to false to remove existing shared key.
                        "hasSshKey": bool,  # Optional. Indicates whether ssh key exists. Set
                          it to false to remove existing SSH key.
                        "hasSshPassword": bool,  # Optional. Indicates whether ssh password
                          exists. Set it to false to remove existing SSH password.
                        "homeDirectory": "str",  # Optional. Optional, local user home
                          directory.
                        "isNFSv3Enabled": bool,  # Optional. Indicates if the local user is
                          enabled for access with NFSv3 protocol.
                        "permissionScopes": [
                            {
                                "permissions": "str",  # The permissions for the
                                  local user. Possible values include: Read (r), Write (w), Delete (d),
                                  List (l), Create (c), Modify Ownership (o), and Modify Permissions
                                  (p). Required.
                                "resourceName": "str",  # The name of resource,
                                  normally the container name or the file share name, used by the local
                                  user. Required.
                                "service": "str"  # The service used by the local
                                  user, e.g. blob, file. Required.
                            }
                        ],
                        "sid": "str",  # Optional. A unique Security Identifier that is
                          generated by the server.
                        "sshAuthorizedKeys": [
                            {
                                "description": "str",  # Optional. Optional. It is
                                  used to store the function/usage of the key.
                                "key": "str"  # Optional. Ssh public key base64
                                  encoded. The format should be: ':code:`<keyType>` :code:`<keyData>`',
                                  e.g. ssh-rsa AAAABBBB.
                            }
                        ],
                        "userId": 0  # Optional. A unique Identifier that is generated by the
                          server.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_local_users_list_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    include=include,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, account_name: str, username: str, **kwargs: Any) -> JSON:
        """Get the local user of the storage account by username.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param username: The name of local user. The username must contain lowercase letters and
         numbers only. It must be unique only within the storage account. Required.
        :type username: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "allowAclAuthorization": bool,  # Optional. Indicates whether ACL
                          authorization is allowed for this user. Set it to false to disallow using ACL
                          authorization.
                        "extendedGroups": [
                            0  # Optional. Supplementary group membership. Only
                              applicable for local users enabled for NFSv3 access.
                        ],
                        "groupId": 0,  # Optional. An identifier for associating a group of
                          users.
                        "hasSharedKey": bool,  # Optional. Indicates whether shared key
                          exists. Set it to false to remove existing shared key.
                        "hasSshKey": bool,  # Optional. Indicates whether ssh key exists. Set
                          it to false to remove existing SSH key.
                        "hasSshPassword": bool,  # Optional. Indicates whether ssh password
                          exists. Set it to false to remove existing SSH password.
                        "homeDirectory": "str",  # Optional. Optional, local user home
                          directory.
                        "isNFSv3Enabled": bool,  # Optional. Indicates if the local user is
                          enabled for access with NFSv3 protocol.
                        "permissionScopes": [
                            {
                                "permissions": "str",  # The permissions for the
                                  local user. Possible values include: Read (r), Write (w), Delete (d),
                                  List (l), Create (c), Modify Ownership (o), and Modify Permissions
                                  (p). Required.
                                "resourceName": "str",  # The name of resource,
                                  normally the container name or the file share name, used by the local
                                  user. Required.
                                "service": "str"  # The service used by the local
                                  user, e.g. blob, file. Required.
                            }
                        ],
                        "sid": "str",  # Optional. A unique Security Identifier that is
                          generated by the server.
                        "sshAuthorizedKeys": [
                            {
                                "description": "str",  # Optional. Optional. It is
                                  used to store the function/usage of the key.
                                "key": "str"  # Optional. Ssh public key base64
                                  encoded. The format should be: ':code:`<keyType>` :code:`<keyData>`',
                                  e.g. ssh-rsa AAAABBBB.
                            }
                        ],
                        "userId": 0  # Optional. A unique Identifier that is generated by the
                          server.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_local_users_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            username=username,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        username: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create or update the properties of a local user associated with the storage account. Properties
        for NFSv3 enablement and extended groups cannot be set with other properties.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param username: The name of local user. The username must contain lowercase letters and
         numbers only. It must be unique only within the storage account. Required.
        :type username: str
        :param properties: The local user associated with a storage account. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "allowAclAuthorization": bool,  # Optional. Indicates whether ACL
                          authorization is allowed for this user. Set it to false to disallow using ACL
                          authorization.
                        "extendedGroups": [
                            0  # Optional. Supplementary group membership. Only
                              applicable for local users enabled for NFSv3 access.
                        ],
                        "groupId": 0,  # Optional. An identifier for associating a group of
                          users.
                        "hasSharedKey": bool,  # Optional. Indicates whether shared key
                          exists. Set it to false to remove existing shared key.
                        "hasSshKey": bool,  # Optional. Indicates whether ssh key exists. Set
                          it to false to remove existing SSH key.
                        "hasSshPassword": bool,  # Optional. Indicates whether ssh password
                          exists. Set it to false to remove existing SSH password.
                        "homeDirectory": "str",  # Optional. Optional, local user home
                          directory.
                        "isNFSv3Enabled": bool,  # Optional. Indicates if the local user is
                          enabled for access with NFSv3 protocol.
                        "permissionScopes": [
                            {
                                "permissions": "str",  # The permissions for the
                                  local user. Possible values include: Read (r), Write (w), Delete (d),
                                  List (l), Create (c), Modify Ownership (o), and Modify Permissions
                                  (p). Required.
                                "resourceName": "str",  # The name of resource,
                                  normally the container name or the file share name, used by the local
                                  user. Required.
                                "service": "str"  # The service used by the local
                                  user, e.g. blob, file. Required.
                            }
                        ],
                        "sid": "str",  # Optional. A unique Security Identifier that is
                          generated by the server.
                        "sshAuthorizedKeys": [
                            {
                                "description": "str",  # Optional. Optional. It is
                                  used to store the function/usage of the key.
                                "key": "str"  # Optional. Ssh public key base64
                                  encoded. The format should be: ':code:`<keyType>` :code:`<keyData>`',
                                  e.g. ssh-rsa AAAABBBB.
                            }
                        ],
                        "userId": 0  # Optional. A unique Identifier that is generated by the
                          server.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "allowAclAuthorization": bool,  # Optional. Indicates whether ACL
                          authorization is allowed for this user. Set it to false to disallow using ACL
                          authorization.
                        "extendedGroups": [
                            0  # Optional. Supplementary group membership. Only
                              applicable for local users enabled for NFSv3 access.
                        ],
                        "groupId": 0,  # Optional. An identifier for associating a group of
                          users.
                        "hasSharedKey": bool,  # Optional. Indicates whether shared key
                          exists. Set it to false to remove existing shared key.
                        "hasSshKey": bool,  # Optional. Indicates whether ssh key exists. Set
                          it to false to remove existing SSH key.
                        "hasSshPassword": bool,  # Optional. Indicates whether ssh password
                          exists. Set it to false to remove existing SSH password.
                        "homeDirectory": "str",  # Optional. Optional, local user home
                          directory.
                        "isNFSv3Enabled": bool,  # Optional. Indicates if the local user is
                          enabled for access with NFSv3 protocol.
                        "permissionScopes": [
                            {
                                "permissions": "str",  # The permissions for the
                                  local user. Possible values include: Read (r), Write (w), Delete (d),
                                  List (l), Create (c), Modify Ownership (o), and Modify Permissions
                                  (p). Required.
                                "resourceName": "str",  # The name of resource,
                                  normally the container name or the file share name, used by the local
                                  user. Required.
                                "service": "str"  # The service used by the local
                                  user, e.g. blob, file. Required.
                            }
                        ],
                        "sid": "str",  # Optional. A unique Security Identifier that is
                          generated by the server.
                        "sshAuthorizedKeys": [
                            {
                                "description": "str",  # Optional. Optional. It is
                                  used to store the function/usage of the key.
                                "key": "str"  # Optional. Ssh public key base64
                                  encoded. The format should be: ':code:`<keyType>` :code:`<keyData>`',
                                  e.g. ssh-rsa AAAABBBB.
                            }
                        ],
                        "userId": 0  # Optional. A unique Identifier that is generated by the
                          server.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def create_or_update(
        self,
        resource_group_name: str,
        account_name: str,
        username: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create or update the properties of a local user associated with the storage account. Properties
        for NFSv3 enablement and extended groups cannot be set with other properties.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param username: The name of local user. The username must contain lowercase letters and
         numbers only. It must be unique only within the storage account. Required.
        :type username: str
        :param properties: The local user associated with a storage account. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "allowAclAuthorization": bool,  # Optional. Indicates whether ACL
                          authorization is allowed for this user. Set it to false to disallow using ACL
                          authorization.
                        "extendedGroups": [
                            0  # Optional. Supplementary group membership. Only
                              applicable for local users enabled for NFSv3 access.
                        ],
                        "groupId": 0,  # Optional. An identifier for associating a group of
                          users.
                        "hasSharedKey": bool,  # Optional. Indicates whether shared key
                          exists. Set it to false to remove existing shared key.
                        "hasSshKey": bool,  # Optional. Indicates whether ssh key exists. Set
                          it to false to remove existing SSH key.
                        "hasSshPassword": bool,  # Optional. Indicates whether ssh password
                          exists. Set it to false to remove existing SSH password.
                        "homeDirectory": "str",  # Optional. Optional, local user home
                          directory.
                        "isNFSv3Enabled": bool,  # Optional. Indicates if the local user is
                          enabled for access with NFSv3 protocol.
                        "permissionScopes": [
                            {
                                "permissions": "str",  # The permissions for the
                                  local user. Possible values include: Read (r), Write (w), Delete (d),
                                  List (l), Create (c), Modify Ownership (o), and Modify Permissions
                                  (p). Required.
                                "resourceName": "str",  # The name of resource,
                                  normally the container name or the file share name, used by the local
                                  user. Required.
                                "service": "str"  # The service used by the local
                                  user, e.g. blob, file. Required.
                            }
                        ],
                        "sid": "str",  # Optional. A unique Security Identifier that is
                          generated by the server.
                        "sshAuthorizedKeys": [
                            {
                                "description": "str",  # Optional. Optional. It is
                                  used to store the function/usage of the key.
                                "key": "str"  # Optional. Ssh public key base64
                                  encoded. The format should be: ':code:`<keyType>` :code:`<keyData>`',
                                  e.g. ssh-rsa AAAABBBB.
                            }
                        ],
                        "userId": 0  # Optional. A unique Identifier that is generated by the
                          server.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def create_or_update(
        self, resource_group_name: str, account_name: str, username: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create or update the properties of a local user associated with the storage account. Properties
        for NFSv3 enablement and extended groups cannot be set with other properties.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param username: The name of local user. The username must contain lowercase letters and
         numbers only. It must be unique only within the storage account. Required.
        :type username: str
        :param properties: The local user associated with a storage account. Is either a JSON type or a
         IO type. Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "allowAclAuthorization": bool,  # Optional. Indicates whether ACL
                          authorization is allowed for this user. Set it to false to disallow using ACL
                          authorization.
                        "extendedGroups": [
                            0  # Optional. Supplementary group membership. Only
                              applicable for local users enabled for NFSv3 access.
                        ],
                        "groupId": 0,  # Optional. An identifier for associating a group of
                          users.
                        "hasSharedKey": bool,  # Optional. Indicates whether shared key
                          exists. Set it to false to remove existing shared key.
                        "hasSshKey": bool,  # Optional. Indicates whether ssh key exists. Set
                          it to false to remove existing SSH key.
                        "hasSshPassword": bool,  # Optional. Indicates whether ssh password
                          exists. Set it to false to remove existing SSH password.
                        "homeDirectory": "str",  # Optional. Optional, local user home
                          directory.
                        "isNFSv3Enabled": bool,  # Optional. Indicates if the local user is
                          enabled for access with NFSv3 protocol.
                        "permissionScopes": [
                            {
                                "permissions": "str",  # The permissions for the
                                  local user. Possible values include: Read (r), Write (w), Delete (d),
                                  List (l), Create (c), Modify Ownership (o), and Modify Permissions
                                  (p). Required.
                                "resourceName": "str",  # The name of resource,
                                  normally the container name or the file share name, used by the local
                                  user. Required.
                                "service": "str"  # The service used by the local
                                  user, e.g. blob, file. Required.
                            }
                        ],
                        "sid": "str",  # Optional. A unique Security Identifier that is
                          generated by the server.
                        "sshAuthorizedKeys": [
                            {
                                "description": "str",  # Optional. Optional. It is
                                  used to store the function/usage of the key.
                                "key": "str"  # Optional. Ssh public key base64
                                  encoded. The format should be: ':code:`<keyType>` :code:`<keyData>`',
                                  e.g. ssh-rsa AAAABBBB.
                            }
                        ],
                        "userId": 0  # Optional. A unique Identifier that is generated by the
                          server.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "allowAclAuthorization": bool,  # Optional. Indicates whether ACL
                          authorization is allowed for this user. Set it to false to disallow using ACL
                          authorization.
                        "extendedGroups": [
                            0  # Optional. Supplementary group membership. Only
                              applicable for local users enabled for NFSv3 access.
                        ],
                        "groupId": 0,  # Optional. An identifier for associating a group of
                          users.
                        "hasSharedKey": bool,  # Optional. Indicates whether shared key
                          exists. Set it to false to remove existing shared key.
                        "hasSshKey": bool,  # Optional. Indicates whether ssh key exists. Set
                          it to false to remove existing SSH key.
                        "hasSshPassword": bool,  # Optional. Indicates whether ssh password
                          exists. Set it to false to remove existing SSH password.
                        "homeDirectory": "str",  # Optional. Optional, local user home
                          directory.
                        "isNFSv3Enabled": bool,  # Optional. Indicates if the local user is
                          enabled for access with NFSv3 protocol.
                        "permissionScopes": [
                            {
                                "permissions": "str",  # The permissions for the
                                  local user. Possible values include: Read (r), Write (w), Delete (d),
                                  List (l), Create (c), Modify Ownership (o), and Modify Permissions
                                  (p). Required.
                                "resourceName": "str",  # The name of resource,
                                  normally the container name or the file share name, used by the local
                                  user. Required.
                                "service": "str"  # The service used by the local
                                  user, e.g. blob, file. Required.
                            }
                        ],
                        "sid": "str",  # Optional. A unique Security Identifier that is
                          generated by the server.
                        "sshAuthorizedKeys": [
                            {
                                "description": "str",  # Optional. Optional. It is
                                  used to store the function/usage of the key.
                                "key": "str"  # Optional. Ssh public key base64
                                  encoded. The format should be: ':code:`<keyType>` :code:`<keyData>`',
                                  e.g. ssh-rsa AAAABBBB.
                            }
                        ],
                        "userId": 0  # Optional. A unique Identifier that is generated by the
                          server.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_local_users_create_or_update_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            username=username,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, account_name: str, username: str, **kwargs: Any
    ) -> None:
        """Deletes the local user associated with the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param username: The name of local user. The username must contain lowercase letters and
         numbers only. It must be unique only within the storage account. Required.
        :type username: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_local_users_delete_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            username=username,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list_keys(self, resource_group_name: str, account_name: str, username: str, **kwargs: Any) -> JSON:
        """List SSH authorized keys and shared key of the local user.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param username: The name of local user. The username must contain lowercase letters and
         numbers only. It must be unique only within the storage account. Required.
        :type username: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "sharedKey": "str",  # Optional. Auto generated by the server for SMB
                      authentication.
                    "sshAuthorizedKeys": [
                        {
                            "description": "str",  # Optional. Optional. It is used to
                              store the function/usage of the key.
                            "key": "str"  # Optional. Ssh public key base64 encoded. The
                              format should be: ':code:`<keyType>` :code:`<keyData>`', e.g. ssh-rsa
                              AAAABBBB.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_local_users_list_keys_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            username=username,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def regenerate_password(self, resource_group_name: str, account_name: str, username: str, **kwargs: Any) -> JSON:
        """Regenerate the local user SSH password.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param username: The name of local user. The username must contain lowercase letters and
         numbers only. It must be unique only within the storage account. Required.
        :type username: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "sshPassword": "str"  # Optional. Auto generated password by the server for
                      SSH authentication if hasSshPassword is set to true on the creation of local
                      user.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_local_users_regenerate_password_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            username=username,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class EncryptionScopesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~storage.mgmt.StorageManagementClient`'s
        :attr:`encryption_scopes` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def put(
        self,
        resource_group_name: str,
        account_name: str,
        encryption_scope_name: str,
        encryption_scope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Synchronously creates or updates an encryption scope under the specified storage account. If an
        encryption scope is already created and a subsequent request is issued with different
        properties, the encryption scope properties will be updated per the specified request.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param encryption_scope_name: The name of the encryption scope within the specified storage
         account. Encryption scope names must be between 3 and 63 characters in length and use numbers,
         lower-case letters and dash (-) only. Every dash (-) character must be immediately preceded and
         followed by a letter or number. Required.
        :type encryption_scope_name: str
        :param encryption_scope: Encryption scope properties to be used for the create or update.
         Required.
        :type encryption_scope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                encryption_scope = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def put(
        self,
        resource_group_name: str,
        account_name: str,
        encryption_scope_name: str,
        encryption_scope: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Synchronously creates or updates an encryption scope under the specified storage account. If an
        encryption scope is already created and a subsequent request is issued with different
        properties, the encryption scope properties will be updated per the specified request.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param encryption_scope_name: The name of the encryption scope within the specified storage
         account. Encryption scope names must be between 3 and 63 characters in length and use numbers,
         lower-case letters and dash (-) only. Every dash (-) character must be immediately preceded and
         followed by a letter or number. Required.
        :type encryption_scope_name: str
        :param encryption_scope: Encryption scope properties to be used for the create or update.
         Required.
        :type encryption_scope: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def put(
        self,
        resource_group_name: str,
        account_name: str,
        encryption_scope_name: str,
        encryption_scope: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Synchronously creates or updates an encryption scope under the specified storage account. If an
        encryption scope is already created and a subsequent request is issued with different
        properties, the encryption scope properties will be updated per the specified request.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param encryption_scope_name: The name of the encryption scope within the specified storage
         account. Encryption scope names must be between 3 and 63 characters in length and use numbers,
         lower-case letters and dash (-) only. Every dash (-) character must be immediately preceded and
         followed by a letter or number. Required.
        :type encryption_scope_name: str
        :param encryption_scope: Encryption scope properties to be used for the create or update. Is
         either a JSON type or a IO type. Required.
        :type encryption_scope: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                encryption_scope = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(encryption_scope, (IOBase, bytes)):
            _content = encryption_scope
        else:
            _json = encryption_scope

        request = build_encryption_scopes_put_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            encryption_scope_name=encryption_scope_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def patch(
        self,
        resource_group_name: str,
        account_name: str,
        encryption_scope_name: str,
        encryption_scope: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update encryption scope properties as specified in the request body. Update fails if the
        specified encryption scope does not already exist.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param encryption_scope_name: The name of the encryption scope within the specified storage
         account. Encryption scope names must be between 3 and 63 characters in length and use numbers,
         lower-case letters and dash (-) only. Every dash (-) character must be immediately preceded and
         followed by a letter or number. Required.
        :type encryption_scope_name: str
        :param encryption_scope: Encryption scope properties to be used for the update. Required.
        :type encryption_scope: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                encryption_scope = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def patch(
        self,
        resource_group_name: str,
        account_name: str,
        encryption_scope_name: str,
        encryption_scope: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update encryption scope properties as specified in the request body. Update fails if the
        specified encryption scope does not already exist.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param encryption_scope_name: The name of the encryption scope within the specified storage
         account. Encryption scope names must be between 3 and 63 characters in length and use numbers,
         lower-case letters and dash (-) only. Every dash (-) character must be immediately preceded and
         followed by a letter or number. Required.
        :type encryption_scope_name: str
        :param encryption_scope: Encryption scope properties to be used for the update. Required.
        :type encryption_scope: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def patch(
        self,
        resource_group_name: str,
        account_name: str,
        encryption_scope_name: str,
        encryption_scope: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Update encryption scope properties as specified in the request body. Update fails if the
        specified encryption scope does not already exist.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param encryption_scope_name: The name of the encryption scope within the specified storage
         account. Encryption scope names must be between 3 and 63 characters in length and use numbers,
         lower-case letters and dash (-) only. Every dash (-) character must be immediately preceded and
         followed by a letter or number. Required.
        :type encryption_scope_name: str
        :param encryption_scope: Encryption scope properties to be used for the update. Is either a
         JSON type or a IO type. Required.
        :type encryption_scope: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                encryption_scope = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(encryption_scope, (IOBase, bytes)):
            _content = encryption_scope
        else:
            _json = encryption_scope

        request = build_encryption_scopes_patch_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            encryption_scope_name=encryption_scope_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(self, resource_group_name: str, account_name: str, encryption_scope_name: str, **kwargs: Any) -> JSON:
        """Returns the properties for the specified encryption scope.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :param encryption_scope_name: The name of the encryption scope within the specified storage
         account. Encryption scope names must be between 3 and 63 characters in length and use numbers,
         lower-case letters and dash (-) only. Every dash (-) character must be immediately preceded and
         followed by a letter or number. Required.
        :type encryption_scope_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_encryption_scopes_get_request(
            resource_group_name=resource_group_name,
            account_name=account_name,
            encryption_scope_name=encryption_scope_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list(
        self,
        resource_group_name: str,
        account_name: str,
        *,
        filter: Optional[str] = None,
        include: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists all the encryption scopes available under the specified storage account.

        :param resource_group_name: The name of the resource group within the user's subscription. The
         name is case insensitive. Required.
        :type resource_group_name: str
        :param account_name: The name of the storage account within the specified resource group.
         Storage account names must be between 3 and 24 characters in length and use numbers and
         lower-case letters only. Required.
        :type account_name: str
        :keyword filter: Optional. When specified, only encryption scope names starting with the filter
         will be listed. Default value is None.
        :paramtype filter: str
        :keyword include: Optional, when specified, will list encryption scopes with the specific
         state. Defaults to All. Known values are: "All", "Enabled", and "Disabled". Default value is
         None.
        :paramtype include: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. Ex -
                      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "creationTime": "2020-02-20 00:00:00",  # Optional. Gets the creation
                          date and time of the encryption scope in UTC.
                        "keyVaultProperties": {
                            "currentVersionedKeyIdentifier": "str",  # Optional. The
                              object identifier of the current versioned Key Vault Key in use.
                            "keyUri": "str",  # Optional. The object identifier for a key
                              vault key object. When applied, the encryption scope will use the key
                              referenced by the identifier to enable customer-managed key support on
                              this encryption scope.
                            "lastKeyRotationTimestamp": "2020-02-20 00:00:00"  #
                              Optional. Timestamp of last rotation of the Key Vault Key.
                        },
                        "lastModifiedTime": "2020-02-20 00:00:00",  # Optional. Gets the last
                          modification date and time of the encryption scope in UTC.
                        "requireInfrastructureEncryption": bool,  # Optional. A boolean
                          indicating whether or not the service applies a secondary layer of encryption
                          with platform managed keys for data at rest.
                        "source": "str",  # Optional. The provider for the encryption scope.
                          Possible values (case-insensitive):  Microsoft.Storage, Microsoft.KeyVault.
                          Known values are: "Microsoft.Storage" and "Microsoft.KeyVault".
                        "state": "str"  # Optional. The state of the encryption scope.
                          Possible values (case-insensitive):  Enabled, Disabled. Known values are:
                          "Enabled" and "Disabled".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_encryption_scopes_list_request(
                    resource_group_name=resource_group_name,
                    account_name=account_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    include=include,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)
