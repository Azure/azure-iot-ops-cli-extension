# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer
from .._vendor import _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.DeviceRegistry/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_get_request(
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetEndpointProfileName": _SERIALIZER.url(
            "asset_endpoint_profile_name",
            asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_create_or_replace_request(
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetEndpointProfileName": _SERIALIZER.url(
            "asset_endpoint_profile_name",
            asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_update_request(
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetEndpointProfileName": _SERIALIZER.url(
            "asset_endpoint_profile_name",
            asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_asset_endpoint_profiles_delete_request(
    resource_group_name: str, asset_endpoint_profile_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assetEndpointProfiles/{assetEndpointProfileName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetEndpointProfileName": _SERIALIZER.url(
            "asset_endpoint_profile_name",
            asset_endpoint_profile_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/assets"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets"
    )
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_get_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_create_or_replace_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_update_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_assets_delete_request(
    resource_group_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_billing_containers_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/billingContainers"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_billing_containers_get_request(
    billing_container_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/billingContainers/{billingContainerName}"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "billingContainerName": _SERIALIZER.url(
            "billing_container_name",
            billing_container_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[0-9a-zA-Z][a-zA-Z0-9-]*$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_operation_status_get_request(
    location: str, operation_id: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/locations/{location}/operationStatuses/{operationId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "location": _SERIALIZER.url("location", location, "str", min_length=1),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str", min_length=1),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespaces_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/namespaces"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespaces_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespaces_get_request(
    resource_group_name: str, namespace_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespaces_create_or_replace_request(
    resource_group_name: str, namespace_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespaces_update_request(
    resource_group_name: str, namespace_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespaces_delete_request(
    resource_group_name: str, namespace_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespaces_migrate_request(
    resource_group_name: str, namespace_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/migrate"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/providers/Microsoft.DeviceRegistry/schemaRegistries"
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_list_by_resource_group_request(
    resource_group_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_get_request(
    resource_group_name: str, schema_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_create_or_replace_request(
    resource_group_name: str, schema_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_update_request(
    resource_group_name: str, schema_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_registries_delete_request(
    resource_group_name: str, schema_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_assets_list_by_resource_group_request(
    resource_group_name: str, namespace_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/assets"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_assets_get_request(
    resource_group_name: str, namespace_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_assets_create_or_replace_request(
    resource_group_name: str, namespace_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_assets_update_request(
    resource_group_name: str, namespace_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_assets_delete_request(
    resource_group_name: str, namespace_name: str, asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/assets/{assetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "assetName": _SERIALIZER.url(
            "asset_name", asset_name, "str", max_length=63, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_devices_list_by_resource_group_request(
    resource_group_name: str, namespace_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/devices"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_devices_get_request(
    resource_group_name: str, namespace_name: str, device_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/devices/{deviceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "deviceName": _SERIALIZER.url(
            "device_name", device_name, "str", max_length=64, min_length=3, pattern=r"^[0-9a-zA-Z][a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_devices_create_or_replace_request(
    resource_group_name: str, namespace_name: str, device_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/devices/{deviceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "deviceName": _SERIALIZER.url(
            "device_name", device_name, "str", max_length=64, min_length=3, pattern=r"^[0-9a-zA-Z][a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_devices_update_request(
    resource_group_name: str, namespace_name: str, device_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/devices/{deviceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "deviceName": _SERIALIZER.url(
            "device_name", device_name, "str", max_length=64, min_length=3, pattern=r"^[0-9a-zA-Z][a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_devices_delete_request(
    resource_group_name: str, namespace_name: str, device_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/devices/{deviceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "deviceName": _SERIALIZER.url(
            "device_name", device_name, "str", max_length=64, min_length=3, pattern=r"^[0-9a-zA-Z][a-zA-Z0-9-]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_discovered_assets_list_by_resource_group_request(
    resource_group_name: str, namespace_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/discoveredAssets"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_discovered_assets_get_request(
    resource_group_name: str, namespace_name: str, discovered_asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/discoveredAssets/{discoveredAssetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "discoveredAssetName": _SERIALIZER.url(
            "discovered_asset_name",
            discovered_asset_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_discovered_assets_create_or_replace_request(
    resource_group_name: str, namespace_name: str, discovered_asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/discoveredAssets/{discoveredAssetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "discoveredAssetName": _SERIALIZER.url(
            "discovered_asset_name",
            discovered_asset_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_discovered_assets_update_request(
    resource_group_name: str, namespace_name: str, discovered_asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/discoveredAssets/{discoveredAssetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "discoveredAssetName": _SERIALIZER.url(
            "discovered_asset_name",
            discovered_asset_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_discovered_assets_delete_request(
    resource_group_name: str, namespace_name: str, discovered_asset_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/discoveredAssets/{discoveredAssetName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "discoveredAssetName": _SERIALIZER.url(
            "discovered_asset_name",
            discovered_asset_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_discovered_devices_list_by_resource_group_request(
    resource_group_name: str, namespace_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/discoveredDevices"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_discovered_devices_get_request(
    resource_group_name: str, namespace_name: str, discovered_device_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/discoveredDevices/{discoveredDeviceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "discoveredDeviceName": _SERIALIZER.url(
            "discovered_device_name",
            discovered_device_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_discovered_devices_create_or_replace_request(
    resource_group_name: str, namespace_name: str, discovered_device_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/discoveredDevices/{discoveredDeviceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "discoveredDeviceName": _SERIALIZER.url(
            "discovered_device_name",
            discovered_device_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_discovered_devices_update_request(
    resource_group_name: str, namespace_name: str, discovered_device_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/discoveredDevices/{discoveredDeviceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "discoveredDeviceName": _SERIALIZER.url(
            "discovered_device_name",
            discovered_device_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_namespace_discovered_devices_delete_request(
    resource_group_name: str, namespace_name: str, discovered_device_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/namespaces/{namespaceName}/discoveredDevices/{discoveredDeviceName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "namespaceName": _SERIALIZER.url(
            "namespace_name",
            namespace_name,
            "str",
            max_length=64,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "discoveredDeviceName": _SERIALIZER.url(
            "discovered_device_name",
            discovered_device_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_list_by_schema_registry_request(
    resource_group_name: str, schema_registry_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_get_request(
    resource_group_name: str, schema_registry_name: str, schema_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_create_or_replace_request(
    resource_group_name: str, schema_registry_name: str, schema_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_schemas_delete_request(
    resource_group_name: str, schema_registry_name: str, schema_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_versions_list_by_schema_request(
    resource_group_name: str, schema_registry_name: str, schema_name: str, subscription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}/schemaVersions"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_versions_get_request(
    resource_group_name: str,
    schema_registry_name: str,
    schema_name: str,
    schema_version_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}/schemaVersions/{schemaVersionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "schemaVersionName": _SERIALIZER.url(
            "schema_version_name", schema_version_name, "str", max_length=10, min_length=1, pattern=r"^[0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_versions_create_or_replace_request(
    resource_group_name: str,
    schema_registry_name: str,
    schema_name: str,
    schema_version_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}/schemaVersions/{schemaVersionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "schemaVersionName": _SERIALIZER.url(
            "schema_version_name", schema_version_name, "str", max_length=10, min_length=1, pattern=r"^[0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_schema_versions_delete_request(
    resource_group_name: str,
    schema_registry_name: str,
    schema_name: str,
    schema_version_name: str,
    subscription_id: str,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-07-01-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DeviceRegistry/schemaRegistries/{schemaRegistryName}/schemas/{schemaName}/schemaVersions/{schemaVersionName}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
        "resourceGroupName": _SERIALIZER.url(
            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
        ),
        "schemaRegistryName": _SERIALIZER.url(
            "schema_registry_name",
            schema_registry_name,
            "str",
            max_length=63,
            min_length=3,
            pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$",
        ),
        "schemaName": _SERIALIZER.url(
            "schema_name", schema_name, "str", max_length=64, min_length=3, pattern=r"^[a-z0-9][a-z0-9-]*[a-z0-9]$"
        ),
        "schemaVersionName": _SERIALIZER.url(
            "schema_version_name", schema_version_name, "str", max_length=10, min_length=1, pattern=r"^[0-9]*$"
        ),
    }

    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """List the operations for the provider.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actionType": "str",  # Optional. Enum. Indicates the action type. "Internal"
                      refers to actions that are for internal only APIs. "Internal"
                    "display": {
                        "description": "str",  # Optional. The short, localized friendly
                          description of the operation; suitable for tool tips and detailed views.
                        "operation": "str",  # Optional. The concise, localized friendly name
                          for the operation; suitable for dropdowns. E.g. "Create or Update Virtual
                          Machine", "Restart Virtual Machine".
                        "provider": "str",  # Optional. The localized friendly form of the
                          resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft
                          Compute".
                        "resource": "str"  # Optional. The localized friendly name of the
                          resource type related to this operation. E.g. "Virtual Machines" or "Job
                          Schedule Collections".
                    },
                    "isDataAction": bool,  # Optional. Whether the operation applies to
                      data-plane. This is "true" for data-plane operations and "false" for
                      ARM/control-plane operations.
                    "name": "str",  # Optional. The name of the operation, as per Resource-Based
                      Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write",
                      "Microsoft.Compute/virtualMachines/capture/action".
                    "origin": "str"  # Optional. The intended executor of the operation; as in
                      Resource Based Access Control (RBAC) and audit logs UX. Default value is
                      "user,system". Known values are: "user", "system", and "user,system".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class AssetEndpointProfilesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`asset_endpoint_profiles` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List AssetEndpointProfile resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_asset_endpoint_profiles_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List AssetEndpointProfile resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_asset_endpoint_profiles_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, asset_endpoint_profile_name: str, **kwargs: Any) -> JSON:
        """Get a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_asset_endpoint_profiles_get_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self, resource_group_name: str, asset_endpoint_profile_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_asset_endpoint_profiles_create_or_replace_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self, resource_group_name: str, asset_endpoint_profile_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                asset_endpoint_profile_name=asset_endpoint_profile_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, resource_group_name: str, asset_endpoint_profile_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_asset_endpoint_profiles_update_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Optional. Defines the method to
                              authenticate the user of the client at the server. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # Optional. The name of
                                  the secret containing the password.
                                "usernameSecretName": "str"  # Optional. The name of
                                  the secret containing the username.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # Optional. The name
                                  of the secret containing the certificate and private key (e.g. stored
                                  as .der/.pem or .der/.pfx).
                            }
                        },
                        "endpointProfileType": "str",  # Optional. Defines the configuration
                          for the connector type that is being used with the endpoint profile.
                        "targetAddress": "str"  # Optional. The local valid URI specifying
                          the network address/DNS name of a southbound device. The scheme part of the
                          targetAddress URI specifies the type of the device. The
                          additionalConfiguration field holds further connector type specific
                          configuration.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_endpoint_profile_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_group_name: str, asset_endpoint_profile_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Optional. Defines the method to
                              authenticate the user of the client at the server. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # Optional. The name of
                                  the secret containing the password.
                                "usernameSecretName": "str"  # Optional. The name of
                                  the secret containing the username.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # Optional. The name
                                  of the secret containing the certificate and private key (e.g. stored
                                  as .der/.pem or .der/.pfx).
                            }
                        },
                        "endpointProfileType": "str",  # Optional. Defines the configuration
                          for the connector type that is being used with the endpoint profile.
                        "targetAddress": "str"  # Optional. The local valid URI specifying
                          the network address/DNS name of a southbound device. The scheme part of the
                          targetAddress URI specifies the type of the device. The
                          additionalConfiguration field holds further connector type specific
                          configuration.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "endpointProfileType": "str",  # Defines the configuration for the
                          connector type that is being used with the endpoint profile. Required.
                        "targetAddress": "str",  # The local valid URI specifying the network
                          address/DNS name of a southbound device. The scheme part of the targetAddress
                          URI specifies the type of the device. The additionalConfiguration field holds
                          further connector type specific configuration. Required.
                        "additionalConfiguration": "str",  # Optional. Stringified JSON that
                          contains connectivity type specific further configuration (e.g., OPC UA,
                          ONVIF).
                        "authentication": {
                            "method": "str",  # Defines the method to authenticate the
                              user of the client at the server. Required. Known values are:
                              "Anonymous", "Certificate", and "UsernamePassword".
                            "usernamePasswordCredentials": {
                                "passwordSecretName": "str",  # The name of the
                                  secret containing the password. Required.
                                "usernameSecretName": "str"  # The name of the secret
                                  containing the username. Required.
                            },
                            "x509Credentials": {
                                "certificateSecretName": "str"  # The name of the
                                  secret containing the certificate and private key (e.g. stored as
                                  .der/.pem or .der/.pfx). Required.
                            }
                        },
                        "discoveredAssetEndpointProfileRef": "str",  # Optional. Reference to
                          a discovered asset endpoint profile. Populated only if the asset endpoint
                          profile has been created from discovery flow. Discovered asset endpoint
                          profile name must be provided.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ctargetAddress 'foo' is not a valid url"u201d).
                                }
                            ]
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                asset_endpoint_profile_name=asset_endpoint_profile_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, asset_endpoint_profile_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_asset_endpoint_profiles_delete_request(
            resource_group_name=resource_group_name,
            asset_endpoint_profile_name=asset_endpoint_profile_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, asset_endpoint_profile_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a AssetEndpointProfile.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_endpoint_profile_name: Asset Endpoint Profile name parameter. Required.
        :type asset_endpoint_profile_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                asset_endpoint_profile_name=asset_endpoint_profile_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class AssetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`assets` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List Asset resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_assets_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List Asset resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_assets_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, asset_name: str, **kwargs: Any) -> JSON:
        """Get a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_assets_get_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self, resource_group_name: str, asset_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_assets_create_or_replace_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        asset_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self, resource_group_name: str, asset_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                asset_name=asset_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, resource_group_name: str, asset_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_assets_update_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # Optional. The topic path for messages
                              published to an MQTT broker.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        asset_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_group_name: str, asset_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # Optional. The topic path for messages
                              published to an MQTT broker.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str"  # Optional. Revision number of the
                          software.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "assetEndpointProfileRef": "str",  # A reference to the asset
                          endpoint profile (connection information) used by brokers to connect to an
                          endpoint that provides data points for this asset. Must provide asset
                          endpoint profile name. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "observabilityMode": "str"  #
                                          Optional. An indication of how the data point should be
                                          mapped to OpenTelemetry. Known values are: "None", "Counter",
                                          "Gauge", "Histogram", and "Log".
                                    }
                                ],
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultTopic": {
                            "path": "str",  # The topic path for messages published to an
                              MQTT broker. Required.
                            "retain": "str"  # Optional. When set to 'Keep', messages
                              published to an MQTT broker will have the retain flag set. Default:
                              'Never'. Known values are: "Keep" and "Never".
                        },
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Reference to the
                          documentation.
                        "enabled": bool,  # Optional. Enabled/Disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "observabilityMode": "str",  # Optional. An
                                  indication of how the event should be mapped to OpenTelemetry. Known
                                  values are: "None" and "Log".
                                "topic": {
                                    "path": "str",  # The topic path for messages
                                      published to an MQTT broker. Required.
                                    "retain": "str"  # Optional. When set to
                                      'Keep', messages published to an MQTT broker will have the retain
                                      flag set. Default: 'Never'. Known values are: "Keep" and "Never".
                                }
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset id provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Revision number of the
                          hardware.
                        "manufacturer": "str",  # Optional. Asset manufacturer name.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model name.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Revision number of the
                          software.
                        "status": {
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "errors": [
                                {
                                    "code": 0,  # Optional. Error code for
                                      classification of errors (ex: 400, 404, 500, etc.).
                                    "message": "str"  # Optional. Human readable
                                      helpful error message to provide additional context for error
                                      (ex: "u201ccapability Id 'foo' does not exist"u201d).
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "version": 0  # Optional. A read only incremental counter
                              indicating the number of times the configuration has been modified from
                              the perspective of the current actual (Edge) state of the Asset. Edge
                              would be the only writer of this value and would sync back up to the
                              cloud. In steady state, this should equal version.
                        },
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          id.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                asset_name=asset_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, asset_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_assets_delete_request(
            resource_group_name=resource_group_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(self, resource_group_name: str, asset_name: str, **kwargs: Any) -> LROPoller[None]:
        """Delete a Asset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                asset_name=asset_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class BillingContainersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`billing_containers` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List BillingContainer resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",  # Optional. Resource ETag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_billing_containers_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, billing_container_name: str, **kwargs: Any) -> JSON:
        """Get a BillingContainer.

        :param billing_container_name: Name of the billing container. Required.
        :type billing_container_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "etag": "str",  # Optional. Resource ETag.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_billing_containers_get_request(
            billing_container_name=billing_container_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class OperationStatusOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`operation_status` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, location: str, operation_id: str, **kwargs: Any) -> JSON:
        """Returns the current status of an async operation.

        :param location: The name of the Azure region. Required.
        :type location: str
        :param operation_id: The ID of an ongoing async operation. Required.
        :type operation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "status": "str",  # Operation status. Required.
                    "endTime": "2020-02-20 00:00:00",  # Optional. The end time of the operation.
                    "error": {
                        "additionalInfo": [
                            {
                                "info": {},  # Optional. The additional info.
                                "type": "str"  # Optional. The additional info type.
                            }
                        ],
                        "code": "str",  # Optional. The error code.
                        "details": [
                            ...
                        ],
                        "message": "str",  # Optional. The error message.
                        "target": "str"  # Optional. The error target.
                    },
                    "id": "str",  # Optional. Fully qualified ID for the async operation.
                    "name": "str",  # Optional. Name of the async operation.
                    "operations": [
                        ...
                    ],
                    "percentComplete": 0.0,  # Optional. Percent of the operation that is
                      complete.
                    "resourceId": "str",  # Optional. Fully qualified ID of the resource against
                      which the original async operation was started.
                    "startTime": "2020-02-20 00:00:00"  # Optional. The start time of the
                      operation.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_operation_status_get_request(
            location=location,
            operation_id=operation_id,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class NamespacesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`namespaces` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List Namespace resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_namespaces_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List Namespace resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_namespaces_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, namespace_name: str, **kwargs: Any) -> JSON:
        """Get a Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_namespaces_get_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self, resource_group_name: str, namespace_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_namespaces_create_or_replace_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self, resource_group_name: str, namespace_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, resource_group_name: str, namespace_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_namespaces_update_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str"  # Optional. The type of managed identity assigned to
                          this resource. Known values are: "None" and "SystemAssigned".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_group_name: str, namespace_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str"  # Optional. The type of managed identity assigned to
                          this resource. Known values are: "None" and "SystemAssigned".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "messaging": {
                            "endpoints": {
                                "str": {
                                    "address": "str",  # The endpoint address to
                                      connect to. Required.
                                    "endpointType": "str",  # Optional. Type of
                                      connection used for messaging endpoint.
                                    "resourceId": "str"  # Optional. The
                                      messaging endpoint Azure resource Id.
                                }
                            }
                        },
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, namespace_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_namespaces_delete_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(self, resource_group_name: str, namespace_name: str, **kwargs: Any) -> LROPoller[None]:
        """Delete a Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _migrate_initial(
        self, resource_group_name: str, namespace_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        request = build_namespaces_migrate_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_migrate(
        self,
        resource_group_name: str,
        namespace_name: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Migrate the resources into Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param body: The content of the action request. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "resourceIds": [
                        "str"  # Optional. List of asset resources to be migrated.
                    ],
                    "scope": "str"  # Optional. Scope of the migrate resources operation.
                      "Resources"
                }

                # response body for status code(s): 200
                response == {
                    "migrateResults": [
                        {
                            "error": {
                                "code": "str",  # Optional. Error code for
                                  classification of errors (ex: '400', '404', '500', etc.).
                                "details": [
                                    {
                                        "code": "str",  # Optional.
                                          Multi-part error code for classification and root causing of
                                          errors (ex: 400.200.100.432).
                                        "correlationId": "str",  # Optional.
                                          Unique identifier for the transaction to aid in debugging.
                                        "info": "str",  # Optional.
                                          Human-readable helpful detailed text context for debugging
                                          (ex: "u201cThe following mechanisms are supported..."u201d).
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (ex: "u201cAuthentication method not
                                          supported"u201d).
                                    }
                                ],
                                "message": "str"  # Optional. Human-readable helpful
                                  error message to provide additional context for error (e.g.,:
                                  "u201cCapability ID 'foo' does not exist"u201d).
                            },
                            "resourceId": "str",  # Optional. The resource Id of the
                              asset resource.
                            "result": "str"  # Optional. The result of the migrate
                              operation. Known values are: "Succeeded" and "Failed".
                        }
                    ]
                }
        """

    @overload
    def begin_migrate(
        self,
        resource_group_name: str,
        namespace_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Migrate the resources into Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param body: The content of the action request. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "migrateResults": [
                        {
                            "error": {
                                "code": "str",  # Optional. Error code for
                                  classification of errors (ex: '400', '404', '500', etc.).
                                "details": [
                                    {
                                        "code": "str",  # Optional.
                                          Multi-part error code for classification and root causing of
                                          errors (ex: 400.200.100.432).
                                        "correlationId": "str",  # Optional.
                                          Unique identifier for the transaction to aid in debugging.
                                        "info": "str",  # Optional.
                                          Human-readable helpful detailed text context for debugging
                                          (ex: "u201cThe following mechanisms are supported..."u201d).
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (ex: "u201cAuthentication method not
                                          supported"u201d).
                                    }
                                ],
                                "message": "str"  # Optional. Human-readable helpful
                                  error message to provide additional context for error (e.g.,:
                                  "u201cCapability ID 'foo' does not exist"u201d).
                            },
                            "resourceId": "str",  # Optional. The resource Id of the
                              asset resource.
                            "result": "str"  # Optional. The result of the migrate
                              operation. Known values are: "Succeeded" and "Failed".
                        }
                    ]
                }
        """

    @distributed_trace
    def begin_migrate(
        self, resource_group_name: str, namespace_name: str, body: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Migrate the resources into Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param body: The content of the action request. Is either a JSON type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "resourceIds": [
                        "str"  # Optional. List of asset resources to be migrated.
                    ],
                    "scope": "str"  # Optional. Scope of the migrate resources operation.
                      "Resources"
                }

                # response body for status code(s): 200
                response == {
                    "migrateResults": [
                        {
                            "error": {
                                "code": "str",  # Optional. Error code for
                                  classification of errors (ex: '400', '404', '500', etc.).
                                "details": [
                                    {
                                        "code": "str",  # Optional.
                                          Multi-part error code for classification and root causing of
                                          errors (ex: 400.200.100.432).
                                        "correlationId": "str",  # Optional.
                                          Unique identifier for the transaction to aid in debugging.
                                        "info": "str",  # Optional.
                                          Human-readable helpful detailed text context for debugging
                                          (ex: "u201cThe following mechanisms are supported..."u201d).
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (ex: "u201cAuthentication method not
                                          supported"u201d).
                                    }
                                ],
                                "message": "str"  # Optional. Human-readable helpful
                                  error message to provide additional context for error (e.g.,:
                                  "u201cCapability ID 'foo' does not exist"u201d).
                            },
                            "resourceId": "str",  # Optional. The resource Id of the
                              asset resource.
                            "result": "str"  # Optional. The result of the migrate
                              operation. Known values are: "Succeeded" and "Failed".
                        }
                    ]
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._migrate_initial(
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class SchemaRegistriesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`schema_registries` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_subscription(self, **kwargs: Any) -> Iterable[JSON]:
        """List SchemaRegistry resources by subscription ID.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_schema_registries_list_by_subscription_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List SchemaRegistry resources by resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_schema_registries_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, schema_registry_name: str, **kwargs: Any) -> JSON:
        """Get a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_schema_registries_get_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self, resource_group_name: str, schema_registry_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_schema_registries_create_or_replace_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self, resource_group_name: str, schema_registry_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                schema_registry_name=schema_registry_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, resource_group_name: str, schema_registry_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_schema_registries_update_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str"  # Optional. The type of managed identity assigned to
                          this resource. Known values are: "None" and "SystemAssigned".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str"  # Optional. Human-readable display name.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_group_name: str, schema_registry_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str"  # Optional. The type of managed identity assigned to
                          this resource. Known values are: "None" and "SystemAssigned".
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str"  # Optional. Human-readable display name.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "identity": {
                        "type": "str",  # Type of managed service identity (either system
                          assigned, or none). Required. Known values are: "None" and "SystemAssigned".
                        "principalId": "str",  # Optional. The service principal ID of the
                          system assigned identity. This property will only be provided for a system
                          assigned identity.
                        "tenantId": "str"  # Optional. The tenant ID of the system assigned
                          identity. This property will only be provided for a system assigned identity.
                    },
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "namespace": "str",  # Schema registry namespace. Uniquely identifies
                          a schema registry within a tenant. Required.
                        "storageAccountContainerUrl": "str",  # The Storage Account's
                          Container URL where schemas will be stored. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema registry.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                schema_registry_name=schema_registry_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, schema_registry_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_schema_registries_delete_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(self, resource_group_name: str, schema_registry_name: str, **kwargs: Any) -> LROPoller[None]:
        """Delete a SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                schema_registry_name=schema_registry_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class NamespaceAssetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`namespace_assets` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, namespace_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List NamespaceAsset resources by Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset ID provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "managementGroups": [
                                {
                                    "name": "str",  # The name of the management
                                      group. Must be unique within the status.managementGroups array.
                                      This name is used to correlate between the spec and status event
                                      information. Required.
                                    "actions": [
                                        {
                                            "name": "str",  # The name of
                                              the action. Must be unique within the status.actions
                                              array. This name is used to correlate between the spec
                                              and status event information. Required.
                                            "error": {
                                                "code": "str",  #
                                                  Optional. Error code for classification of errors
                                                  (ex: '400', '404', '500', etc.).
                                                "details": [
                                                    {
                "code": "str",  # Optional. Multi-part error
                                                          code for classification and root causing of
                                                          errors (ex: 400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                          identifier for the transaction to aid in
                                                          debugging.
                "info": "str",  # Optional. Human-readable
                                                          helpful detailed text context for debugging
                                                          (ex: "u201cThe following mechanisms are
                                                          supported..."u201d).
                "message": "str"  # Optional. Human-readable
                                                          helpful error message to provide additional
                                                          context for error (ex: "u201cAuthentication
                                                          method not supported"u201d).
                                                    }
                                                ],
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (e.g.,:
                                                  "u201cCapability ID 'foo' does not exist"u201d).
                                            },
                "requestMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            },
                "responseMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            }
                                        }
                                    ]
                                }
                            ],
                            "streams": [
                                {
                                    "name": "str",  # The name of the stream.
                                      Must be unique within the status.streams array. This name is used
                                      to correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ]
                        },
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          ID.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_namespace_assets_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    namespace_name=namespace_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, namespace_name: str, asset_name: str, **kwargs: Any) -> JSON:
        """Get a NamespaceAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset ID provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "managementGroups": [
                                {
                                    "name": "str",  # The name of the management
                                      group. Must be unique within the status.managementGroups array.
                                      This name is used to correlate between the spec and status event
                                      information. Required.
                                    "actions": [
                                        {
                                            "name": "str",  # The name of
                                              the action. Must be unique within the status.actions
                                              array. This name is used to correlate between the spec
                                              and status event information. Required.
                                            "error": {
                                                "code": "str",  #
                                                  Optional. Error code for classification of errors
                                                  (ex: '400', '404', '500', etc.).
                                                "details": [
                                                    {
                "code": "str",  # Optional. Multi-part error
                                                          code for classification and root causing of
                                                          errors (ex: 400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                          identifier for the transaction to aid in
                                                          debugging.
                "info": "str",  # Optional. Human-readable
                                                          helpful detailed text context for debugging
                                                          (ex: "u201cThe following mechanisms are
                                                          supported..."u201d).
                "message": "str"  # Optional. Human-readable
                                                          helpful error message to provide additional
                                                          context for error (ex: "u201cAuthentication
                                                          method not supported"u201d).
                                                    }
                                                ],
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (e.g.,:
                                                  "u201cCapability ID 'foo' does not exist"u201d).
                                            },
                "requestMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            },
                "responseMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            }
                                        }
                                    ]
                                }
                            ],
                            "streams": [
                                {
                                    "name": "str",  # The name of the stream.
                                      Must be unique within the status.streams array. This name is used
                                      to correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ]
                        },
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          ID.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_namespace_assets_get_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self, resource_group_name: str, namespace_name: str, asset_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_namespace_assets_create_or_replace_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        asset_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset ID provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "managementGroups": [
                                {
                                    "name": "str",  # The name of the management
                                      group. Must be unique within the status.managementGroups array.
                                      This name is used to correlate between the spec and status event
                                      information. Required.
                                    "actions": [
                                        {
                                            "name": "str",  # The name of
                                              the action. Must be unique within the status.actions
                                              array. This name is used to correlate between the spec
                                              and status event information. Required.
                                            "error": {
                                                "code": "str",  #
                                                  Optional. Error code for classification of errors
                                                  (ex: '400', '404', '500', etc.).
                                                "details": [
                                                    {
                "code": "str",  # Optional. Multi-part error
                                                          code for classification and root causing of
                                                          errors (ex: 400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                          identifier for the transaction to aid in
                                                          debugging.
                "info": "str",  # Optional. Human-readable
                                                          helpful detailed text context for debugging
                                                          (ex: "u201cThe following mechanisms are
                                                          supported..."u201d).
                "message": "str"  # Optional. Human-readable
                                                          helpful error message to provide additional
                                                          context for error (ex: "u201cAuthentication
                                                          method not supported"u201d).
                                                    }
                                                ],
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (e.g.,:
                                                  "u201cCapability ID 'foo' does not exist"u201d).
                                            },
                "requestMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            },
                "responseMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            }
                                        }
                                    ]
                                }
                            ],
                            "streams": [
                                {
                                    "name": "str",  # The name of the stream.
                                      Must be unique within the status.streams array. This name is used
                                      to correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ]
                        },
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          ID.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset ID provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "managementGroups": [
                                {
                                    "name": "str",  # The name of the management
                                      group. Must be unique within the status.managementGroups array.
                                      This name is used to correlate between the spec and status event
                                      information. Required.
                                    "actions": [
                                        {
                                            "name": "str",  # The name of
                                              the action. Must be unique within the status.actions
                                              array. This name is used to correlate between the spec
                                              and status event information. Required.
                                            "error": {
                                                "code": "str",  #
                                                  Optional. Error code for classification of errors
                                                  (ex: '400', '404', '500', etc.).
                                                "details": [
                                                    {
                "code": "str",  # Optional. Multi-part error
                                                          code for classification and root causing of
                                                          errors (ex: 400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                          identifier for the transaction to aid in
                                                          debugging.
                "info": "str",  # Optional. Human-readable
                                                          helpful detailed text context for debugging
                                                          (ex: "u201cThe following mechanisms are
                                                          supported..."u201d).
                "message": "str"  # Optional. Human-readable
                                                          helpful error message to provide additional
                                                          context for error (ex: "u201cAuthentication
                                                          method not supported"u201d).
                                                    }
                                                ],
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (e.g.,:
                                                  "u201cCapability ID 'foo' does not exist"u201d).
                                            },
                "requestMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            },
                "responseMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            }
                                        }
                                    ]
                                }
                            ],
                            "streams": [
                                {
                                    "name": "str",  # The name of the stream.
                                      Must be unique within the status.streams array. This name is used
                                      to correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ]
                        },
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          ID.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        asset_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset ID provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "managementGroups": [
                                {
                                    "name": "str",  # The name of the management
                                      group. Must be unique within the status.managementGroups array.
                                      This name is used to correlate between the spec and status event
                                      information. Required.
                                    "actions": [
                                        {
                                            "name": "str",  # The name of
                                              the action. Must be unique within the status.actions
                                              array. This name is used to correlate between the spec
                                              and status event information. Required.
                                            "error": {
                                                "code": "str",  #
                                                  Optional. Error code for classification of errors
                                                  (ex: '400', '404', '500', etc.).
                                                "details": [
                                                    {
                "code": "str",  # Optional. Multi-part error
                                                          code for classification and root causing of
                                                          errors (ex: 400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                          identifier for the transaction to aid in
                                                          debugging.
                "info": "str",  # Optional. Human-readable
                                                          helpful detailed text context for debugging
                                                          (ex: "u201cThe following mechanisms are
                                                          supported..."u201d).
                "message": "str"  # Optional. Human-readable
                                                          helpful error message to provide additional
                                                          context for error (ex: "u201cAuthentication
                                                          method not supported"u201d).
                                                    }
                                                ],
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (e.g.,:
                                                  "u201cCapability ID 'foo' does not exist"u201d).
                                            },
                "requestMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            },
                "responseMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            }
                                        }
                                    ]
                                }
                            ],
                            "streams": [
                                {
                                    "name": "str",  # The name of the stream.
                                      Must be unique within the status.streams array. This name is used
                                      to correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ]
                        },
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          ID.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self, resource_group_name: str, namespace_name: str, asset_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset ID provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "managementGroups": [
                                {
                                    "name": "str",  # The name of the management
                                      group. Must be unique within the status.managementGroups array.
                                      This name is used to correlate between the spec and status event
                                      information. Required.
                                    "actions": [
                                        {
                                            "name": "str",  # The name of
                                              the action. Must be unique within the status.actions
                                              array. This name is used to correlate between the spec
                                              and status event information. Required.
                                            "error": {
                                                "code": "str",  #
                                                  Optional. Error code for classification of errors
                                                  (ex: '400', '404', '500', etc.).
                                                "details": [
                                                    {
                "code": "str",  # Optional. Multi-part error
                                                          code for classification and root causing of
                                                          errors (ex: 400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                          identifier for the transaction to aid in
                                                          debugging.
                "info": "str",  # Optional. Human-readable
                                                          helpful detailed text context for debugging
                                                          (ex: "u201cThe following mechanisms are
                                                          supported..."u201d).
                "message": "str"  # Optional. Human-readable
                                                          helpful error message to provide additional
                                                          context for error (ex: "u201cAuthentication
                                                          method not supported"u201d).
                                                    }
                                                ],
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (e.g.,:
                                                  "u201cCapability ID 'foo' does not exist"u201d).
                                            },
                "requestMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            },
                "responseMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            }
                                        }
                                    ]
                                }
                            ],
                            "streams": [
                                {
                                    "name": "str",  # The name of the stream.
                                      Must be unique within the status.streams array. This name is used
                                      to correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ]
                        },
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          ID.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset ID provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "managementGroups": [
                                {
                                    "name": "str",  # The name of the management
                                      group. Must be unique within the status.managementGroups array.
                                      This name is used to correlate between the spec and status event
                                      information. Required.
                                    "actions": [
                                        {
                                            "name": "str",  # The name of
                                              the action. Must be unique within the status.actions
                                              array. This name is used to correlate between the spec
                                              and status event information. Required.
                                            "error": {
                                                "code": "str",  #
                                                  Optional. Error code for classification of errors
                                                  (ex: '400', '404', '500', etc.).
                                                "details": [
                                                    {
                "code": "str",  # Optional. Multi-part error
                                                          code for classification and root causing of
                                                          errors (ex: 400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                          identifier for the transaction to aid in
                                                          debugging.
                "info": "str",  # Optional. Human-readable
                                                          helpful detailed text context for debugging
                                                          (ex: "u201cThe following mechanisms are
                                                          supported..."u201d).
                "message": "str"  # Optional. Human-readable
                                                          helpful error message to provide additional
                                                          context for error (ex: "u201cAuthentication
                                                          method not supported"u201d).
                                                    }
                                                ],
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (e.g.,:
                                                  "u201cCapability ID 'foo' does not exist"u201d).
                                            },
                "requestMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            },
                "responseMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            }
                                        }
                                    ]
                                }
                            ],
                            "streams": [
                                {
                                    "name": "str",  # The name of the stream.
                                      Must be unique within the status.streams array. This name is used
                                      to correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ]
                        },
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          ID.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                asset_name=asset_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, resource_group_name: str, namespace_name: str, asset_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_namespace_assets_update_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        asset_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset ID provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "managementGroups": [
                                {
                                    "name": "str",  # The name of the management
                                      group. Must be unique within the status.managementGroups array.
                                      This name is used to correlate between the spec and status event
                                      information. Required.
                                    "actions": [
                                        {
                                            "name": "str",  # The name of
                                              the action. Must be unique within the status.actions
                                              array. This name is used to correlate between the spec
                                              and status event information. Required.
                                            "error": {
                                                "code": "str",  #
                                                  Optional. Error code for classification of errors
                                                  (ex: '400', '404', '500', etc.).
                                                "details": [
                                                    {
                "code": "str",  # Optional. Multi-part error
                                                          code for classification and root causing of
                                                          errors (ex: 400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                          identifier for the transaction to aid in
                                                          debugging.
                "info": "str",  # Optional. Human-readable
                                                          helpful detailed text context for debugging
                                                          (ex: "u201cThe following mechanisms are
                                                          supported..."u201d).
                "message": "str"  # Optional. Human-readable
                                                          helpful error message to provide additional
                                                          context for error (ex: "u201cAuthentication
                                                          method not supported"u201d).
                                                    }
                                                ],
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (e.g.,:
                                                  "u201cCapability ID 'foo' does not exist"u201d).
                                            },
                "requestMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            },
                "responseMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            }
                                        }
                                    ]
                                }
                            ],
                            "streams": [
                                {
                                    "name": "str",  # The name of the stream.
                                      Must be unique within the status.streams array. This name is used
                                      to correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ]
                        },
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          ID.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        asset_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset ID provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "managementGroups": [
                                {
                                    "name": "str",  # The name of the management
                                      group. Must be unique within the status.managementGroups array.
                                      This name is used to correlate between the spec and status event
                                      information. Required.
                                    "actions": [
                                        {
                                            "name": "str",  # The name of
                                              the action. Must be unique within the status.actions
                                              array. This name is used to correlate between the spec
                                              and status event information. Required.
                                            "error": {
                                                "code": "str",  #
                                                  Optional. Error code for classification of errors
                                                  (ex: '400', '404', '500', etc.).
                                                "details": [
                                                    {
                "code": "str",  # Optional. Multi-part error
                                                          code for classification and root causing of
                                                          errors (ex: 400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                          identifier for the transaction to aid in
                                                          debugging.
                "info": "str",  # Optional. Human-readable
                                                          helpful detailed text context for debugging
                                                          (ex: "u201cThe following mechanisms are
                                                          supported..."u201d).
                "message": "str"  # Optional. Human-readable
                                                          helpful error message to provide additional
                                                          context for error (ex: "u201cAuthentication
                                                          method not supported"u201d).
                                                    }
                                                ],
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (e.g.,:
                                                  "u201cCapability ID 'foo' does not exist"u201d).
                                            },
                "requestMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            },
                "responseMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            }
                                        }
                                    ]
                                }
                            ],
                            "streams": [
                                {
                                    "name": "str",  # The name of the stream.
                                      Must be unique within the status.streams array. This name is used
                                      to correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ]
                        },
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          ID.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self, resource_group_name: str, namespace_name: str, asset_name: str, properties: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific JSON string that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "description": "str",  # Optional. Human-readable description of the
                          asset.
                        "discoveredAssetRefs": [
                            "str"  # Optional. Reference to a list of discovered assets.
                              Populated only if the asset has been created from discovery flow.
                              Discovered asset names must be provided.
                        ],
                        "displayName": "str",  # Optional. Human-readable display name.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "enabled": bool,  # Optional. Enabled/disabled status of the asset.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str"  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "externalAssetId": "str",  # Optional. Asset ID provided by the
                          customer.
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "datasets": [
                                {
                                    "name": "str",  # The name of the dataset.
                                      Must be unique within the status.datasets array. This name is
                                      used to correlate between the spec and status dataset
                                      information. Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "events": [
                                {
                                    "name": "str",  # The name of the event. Must
                                      be unique within the status.events array. This name is used to
                                      correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ],
                            "managementGroups": [
                                {
                                    "name": "str",  # The name of the management
                                      group. Must be unique within the status.managementGroups array.
                                      This name is used to correlate between the spec and status event
                                      information. Required.
                                    "actions": [
                                        {
                                            "name": "str",  # The name of
                                              the action. Must be unique within the status.actions
                                              array. This name is used to correlate between the spec
                                              and status event information. Required.
                                            "error": {
                                                "code": "str",  #
                                                  Optional. Error code for classification of errors
                                                  (ex: '400', '404', '500', etc.).
                                                "details": [
                                                    {
                "code": "str",  # Optional. Multi-part error
                                                          code for classification and root causing of
                                                          errors (ex: 400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                          identifier for the transaction to aid in
                                                          debugging.
                "info": "str",  # Optional. Human-readable
                                                          helpful detailed text context for debugging
                                                          (ex: "u201cThe following mechanisms are
                                                          supported..."u201d).
                "message": "str"  # Optional. Human-readable
                                                          helpful error message to provide additional
                                                          context for error (ex: "u201cAuthentication
                                                          method not supported"u201d).
                                                    }
                                                ],
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (e.g.,:
                                                  "u201cCapability ID 'foo' does not exist"u201d).
                                            },
                "requestMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            },
                "responseMessageSchemaReference": {
                                                "schemaName": "str",
                                                  # The message schema name. Required.
                "schemaRegistryNamespace": "str",  # The message
                                                  schema registry namespace. Required.
                                                "schemaVersion":
                                                  "str"  # The message schema version. Required.
                                            }
                                        }
                                    ]
                                }
                            ],
                            "streams": [
                                {
                                    "name": "str",  # The name of the stream.
                                      Must be unique within the status.streams array. This name is used
                                      to correlate between the spec and status event information.
                                      Required.
                                    "error": {
                                        "code": "str",  # Optional. Error
                                          code for classification of errors (ex: '400', '404', '500',
                                          etc.).
                                        "details": [
                                            {
                                                "code": "str",  #
                                                  Optional. Multi-part error code for classification
                                                  and root causing of errors (ex: 400.200.100.432).
                                                "correlationId":
                                                  "str",  # Optional. Unique identifier for the
                                                  transaction to aid in debugging.
                                                "info": "str",  #
                                                  Optional. Human-readable helpful detailed text
                                                  context for debugging (ex: "u201cThe following
                                                  mechanisms are supported..."u201d).
                                                "message": "str"  #
                                                  Optional. Human-readable helpful error message to
                                                  provide additional context for error (ex:
                                                  "u201cAuthentication method not supported"u201d).
                                            }
                                        ],
                                        "message": "str"  # Optional.
                                          Human-readable helpful error message to provide additional
                                          context for error (e.g.,: "u201cCapability ID 'foo' does not
                                          exist"u201d).
                                    },
                                    "messageSchemaReference": {
                                        "schemaName": "str",  # The message
                                          schema name. Required.
                                        "schemaRegistryNamespace": "str",  #
                                          The message schema registry namespace. Required.
                                        "schemaVersion": "str"  # The message
                                          schema version. Required.
                                    }
                                }
                            ]
                        },
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "uuid": "str",  # Optional. Globally unique, immutable, non-reusable
                          ID.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                asset_name=asset_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, namespace_name: str, asset_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_namespace_assets_delete_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            asset_name=asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, namespace_name: str, asset_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a NamespaceAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param asset_name: The name of the asset. Required.
        :type asset_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                asset_name=asset_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class NamespaceDevicesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`namespace_devices` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, namespace_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List NamespaceDevice resources by Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "etag": "str",  # Optional. Resource Tag.
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "deviceTemplateId": "str",  # Optional. Device Template Id used to
                          create a device.
                        "discoveredDeviceRef": "str",  # Optional. Reference to a device.
                          Populated only if the device had been created from discovery flow. Discovered
                          device name must be provided.
                        "enabled": True,  # Optional. Default value is True. Indicates if the
                          resource and identity are enabled or not. A disabled device cannot
                          authenticate with Microsoft Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "authentication": {
                                        "method": "str",  # Defines the
                                          method to authenticate the user of the client at the server.
                                          Required. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # The name of the secret containing the password.
                                              Required.
                                            "usernameSecretName": "str"
                                              # The name of the secret containing the username.
                                              Required.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx). Required.
                                        }
                                    },
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. The Device ID provided by the
                          customer.
                        "identity": {
                            "principalId": "str",  # Optional. Principal id for the
                              device resource.
                            "tenantId": "str"  # Optional. Tenant id for the Microsoft
                              Entra ID tenant.
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "endpoints": {
                                "inbound": {
                                    "str": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code for classification of errors (ex: '400',
                                              '404', '500', etc.).
                                            "details": [
                                                {
                                                    "code":
                                                      "str",  # Optional. Multi-part error code for
                                                      classification and root causing of errors (ex:
                                                      400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                      identifier for the transaction to aid in
                                                      debugging.
                                                    "info":
                                                      "str",  # Optional. Human-readable helpful
                                                      detailed text context for debugging (ex:
                                                      "u201cThe following mechanisms are
                                                      supported..."u201d).
                                                    "message":
                                                      "str"  # Optional. Human-readable helpful error
                                                      message to provide additional context for error
                                                      (ex: "u201cAuthentication method not
                                                      supported"u201d).
                                                }
                                            ],
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (e.g.,: "u201cCapability ID
                                              'foo' does not exist"u201d).
                                        }
                                    }
                                }
                            }
                        },
                        "uuid": "str",  # Optional. A unique identifier for the device.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_namespace_devices_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    namespace_name=namespace_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, namespace_name: str, device_name: str, **kwargs: Any) -> JSON:
        """Get a NamespaceDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param device_name: The name of the device. Required.
        :type device_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "etag": "str",  # Optional. Resource Tag.
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "deviceTemplateId": "str",  # Optional. Device Template Id used to
                          create a device.
                        "discoveredDeviceRef": "str",  # Optional. Reference to a device.
                          Populated only if the device had been created from discovery flow. Discovered
                          device name must be provided.
                        "enabled": True,  # Optional. Default value is True. Indicates if the
                          resource and identity are enabled or not. A disabled device cannot
                          authenticate with Microsoft Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "authentication": {
                                        "method": "str",  # Defines the
                                          method to authenticate the user of the client at the server.
                                          Required. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # The name of the secret containing the password.
                                              Required.
                                            "usernameSecretName": "str"
                                              # The name of the secret containing the username.
                                              Required.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx). Required.
                                        }
                                    },
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. The Device ID provided by the
                          customer.
                        "identity": {
                            "principalId": "str",  # Optional. Principal id for the
                              device resource.
                            "tenantId": "str"  # Optional. Tenant id for the Microsoft
                              Entra ID tenant.
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "endpoints": {
                                "inbound": {
                                    "str": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code for classification of errors (ex: '400',
                                              '404', '500', etc.).
                                            "details": [
                                                {
                                                    "code":
                                                      "str",  # Optional. Multi-part error code for
                                                      classification and root causing of errors (ex:
                                                      400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                      identifier for the transaction to aid in
                                                      debugging.
                                                    "info":
                                                      "str",  # Optional. Human-readable helpful
                                                      detailed text context for debugging (ex:
                                                      "u201cThe following mechanisms are
                                                      supported..."u201d).
                                                    "message":
                                                      "str"  # Optional. Human-readable helpful error
                                                      message to provide additional context for error
                                                      (ex: "u201cAuthentication method not
                                                      supported"u201d).
                                                }
                                            ],
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (e.g.,: "u201cCapability ID
                                              'foo' does not exist"u201d).
                                        }
                                    }
                                }
                            }
                        },
                        "uuid": "str",  # Optional. A unique identifier for the device.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_namespace_devices_get_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            device_name=device_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self, resource_group_name: str, namespace_name: str, device_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_namespace_devices_create_or_replace_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            device_name=device_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        device_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param device_name: The name of the device. Required.
        :type device_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "etag": "str",  # Optional. Resource Tag.
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "deviceTemplateId": "str",  # Optional. Device Template Id used to
                          create a device.
                        "discoveredDeviceRef": "str",  # Optional. Reference to a device.
                          Populated only if the device had been created from discovery flow. Discovered
                          device name must be provided.
                        "enabled": True,  # Optional. Default value is True. Indicates if the
                          resource and identity are enabled or not. A disabled device cannot
                          authenticate with Microsoft Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "authentication": {
                                        "method": "str",  # Defines the
                                          method to authenticate the user of the client at the server.
                                          Required. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # The name of the secret containing the password.
                                              Required.
                                            "usernameSecretName": "str"
                                              # The name of the secret containing the username.
                                              Required.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx). Required.
                                        }
                                    },
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. The Device ID provided by the
                          customer.
                        "identity": {
                            "principalId": "str",  # Optional. Principal id for the
                              device resource.
                            "tenantId": "str"  # Optional. Tenant id for the Microsoft
                              Entra ID tenant.
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "endpoints": {
                                "inbound": {
                                    "str": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code for classification of errors (ex: '400',
                                              '404', '500', etc.).
                                            "details": [
                                                {
                                                    "code":
                                                      "str",  # Optional. Multi-part error code for
                                                      classification and root causing of errors (ex:
                                                      400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                      identifier for the transaction to aid in
                                                      debugging.
                                                    "info":
                                                      "str",  # Optional. Human-readable helpful
                                                      detailed text context for debugging (ex:
                                                      "u201cThe following mechanisms are
                                                      supported..."u201d).
                                                    "message":
                                                      "str"  # Optional. Human-readable helpful error
                                                      message to provide additional context for error
                                                      (ex: "u201cAuthentication method not
                                                      supported"u201d).
                                                }
                                            ],
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (e.g.,: "u201cCapability ID
                                              'foo' does not exist"u201d).
                                        }
                                    }
                                }
                            }
                        },
                        "uuid": "str",  # Optional. A unique identifier for the device.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "etag": "str",  # Optional. Resource Tag.
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "deviceTemplateId": "str",  # Optional. Device Template Id used to
                          create a device.
                        "discoveredDeviceRef": "str",  # Optional. Reference to a device.
                          Populated only if the device had been created from discovery flow. Discovered
                          device name must be provided.
                        "enabled": True,  # Optional. Default value is True. Indicates if the
                          resource and identity are enabled or not. A disabled device cannot
                          authenticate with Microsoft Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "authentication": {
                                        "method": "str",  # Defines the
                                          method to authenticate the user of the client at the server.
                                          Required. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # The name of the secret containing the password.
                                              Required.
                                            "usernameSecretName": "str"
                                              # The name of the secret containing the username.
                                              Required.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx). Required.
                                        }
                                    },
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. The Device ID provided by the
                          customer.
                        "identity": {
                            "principalId": "str",  # Optional. Principal id for the
                              device resource.
                            "tenantId": "str"  # Optional. Tenant id for the Microsoft
                              Entra ID tenant.
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "endpoints": {
                                "inbound": {
                                    "str": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code for classification of errors (ex: '400',
                                              '404', '500', etc.).
                                            "details": [
                                                {
                                                    "code":
                                                      "str",  # Optional. Multi-part error code for
                                                      classification and root causing of errors (ex:
                                                      400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                      identifier for the transaction to aid in
                                                      debugging.
                                                    "info":
                                                      "str",  # Optional. Human-readable helpful
                                                      detailed text context for debugging (ex:
                                                      "u201cThe following mechanisms are
                                                      supported..."u201d).
                                                    "message":
                                                      "str"  # Optional. Human-readable helpful error
                                                      message to provide additional context for error
                                                      (ex: "u201cAuthentication method not
                                                      supported"u201d).
                                                }
                                            ],
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (e.g.,: "u201cCapability ID
                                              'foo' does not exist"u201d).
                                        }
                                    }
                                }
                            }
                        },
                        "uuid": "str",  # Optional. A unique identifier for the device.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        device_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param device_name: The name of the device. Required.
        :type device_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "etag": "str",  # Optional. Resource Tag.
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "deviceTemplateId": "str",  # Optional. Device Template Id used to
                          create a device.
                        "discoveredDeviceRef": "str",  # Optional. Reference to a device.
                          Populated only if the device had been created from discovery flow. Discovered
                          device name must be provided.
                        "enabled": True,  # Optional. Default value is True. Indicates if the
                          resource and identity are enabled or not. A disabled device cannot
                          authenticate with Microsoft Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "authentication": {
                                        "method": "str",  # Defines the
                                          method to authenticate the user of the client at the server.
                                          Required. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # The name of the secret containing the password.
                                              Required.
                                            "usernameSecretName": "str"
                                              # The name of the secret containing the username.
                                              Required.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx). Required.
                                        }
                                    },
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. The Device ID provided by the
                          customer.
                        "identity": {
                            "principalId": "str",  # Optional. Principal id for the
                              device resource.
                            "tenantId": "str"  # Optional. Tenant id for the Microsoft
                              Entra ID tenant.
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "endpoints": {
                                "inbound": {
                                    "str": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code for classification of errors (ex: '400',
                                              '404', '500', etc.).
                                            "details": [
                                                {
                                                    "code":
                                                      "str",  # Optional. Multi-part error code for
                                                      classification and root causing of errors (ex:
                                                      400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                      identifier for the transaction to aid in
                                                      debugging.
                                                    "info":
                                                      "str",  # Optional. Human-readable helpful
                                                      detailed text context for debugging (ex:
                                                      "u201cThe following mechanisms are
                                                      supported..."u201d).
                                                    "message":
                                                      "str"  # Optional. Human-readable helpful error
                                                      message to provide additional context for error
                                                      (ex: "u201cAuthentication method not
                                                      supported"u201d).
                                                }
                                            ],
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (e.g.,: "u201cCapability ID
                                              'foo' does not exist"u201d).
                                        }
                                    }
                                }
                            }
                        },
                        "uuid": "str",  # Optional. A unique identifier for the device.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self, resource_group_name: str, namespace_name: str, device_name: str, resource: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param device_name: The name of the device. Required.
        :type device_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "etag": "str",  # Optional. Resource Tag.
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "deviceTemplateId": "str",  # Optional. Device Template Id used to
                          create a device.
                        "discoveredDeviceRef": "str",  # Optional. Reference to a device.
                          Populated only if the device had been created from discovery flow. Discovered
                          device name must be provided.
                        "enabled": True,  # Optional. Default value is True. Indicates if the
                          resource and identity are enabled or not. A disabled device cannot
                          authenticate with Microsoft Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "authentication": {
                                        "method": "str",  # Defines the
                                          method to authenticate the user of the client at the server.
                                          Required. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # The name of the secret containing the password.
                                              Required.
                                            "usernameSecretName": "str"
                                              # The name of the secret containing the username.
                                              Required.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx). Required.
                                        }
                                    },
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. The Device ID provided by the
                          customer.
                        "identity": {
                            "principalId": "str",  # Optional. Principal id for the
                              device resource.
                            "tenantId": "str"  # Optional. Tenant id for the Microsoft
                              Entra ID tenant.
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "endpoints": {
                                "inbound": {
                                    "str": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code for classification of errors (ex: '400',
                                              '404', '500', etc.).
                                            "details": [
                                                {
                                                    "code":
                                                      "str",  # Optional. Multi-part error code for
                                                      classification and root causing of errors (ex:
                                                      400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                      identifier for the transaction to aid in
                                                      debugging.
                                                    "info":
                                                      "str",  # Optional. Human-readable helpful
                                                      detailed text context for debugging (ex:
                                                      "u201cThe following mechanisms are
                                                      supported..."u201d).
                                                    "message":
                                                      "str"  # Optional. Human-readable helpful error
                                                      message to provide additional context for error
                                                      (ex: "u201cAuthentication method not
                                                      supported"u201d).
                                                }
                                            ],
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (e.g.,: "u201cCapability ID
                                              'foo' does not exist"u201d).
                                        }
                                    }
                                }
                            }
                        },
                        "uuid": "str",  # Optional. A unique identifier for the device.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "etag": "str",  # Optional. Resource Tag.
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "deviceTemplateId": "str",  # Optional. Device Template Id used to
                          create a device.
                        "discoveredDeviceRef": "str",  # Optional. Reference to a device.
                          Populated only if the device had been created from discovery flow. Discovered
                          device name must be provided.
                        "enabled": True,  # Optional. Default value is True. Indicates if the
                          resource and identity are enabled or not. A disabled device cannot
                          authenticate with Microsoft Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "authentication": {
                                        "method": "str",  # Defines the
                                          method to authenticate the user of the client at the server.
                                          Required. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # The name of the secret containing the password.
                                              Required.
                                            "usernameSecretName": "str"
                                              # The name of the secret containing the username.
                                              Required.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx). Required.
                                        }
                                    },
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. The Device ID provided by the
                          customer.
                        "identity": {
                            "principalId": "str",  # Optional. Principal id for the
                              device resource.
                            "tenantId": "str"  # Optional. Tenant id for the Microsoft
                              Entra ID tenant.
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "endpoints": {
                                "inbound": {
                                    "str": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code for classification of errors (ex: '400',
                                              '404', '500', etc.).
                                            "details": [
                                                {
                                                    "code":
                                                      "str",  # Optional. Multi-part error code for
                                                      classification and root causing of errors (ex:
                                                      400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                      identifier for the transaction to aid in
                                                      debugging.
                                                    "info":
                                                      "str",  # Optional. Human-readable helpful
                                                      detailed text context for debugging (ex:
                                                      "u201cThe following mechanisms are
                                                      supported..."u201d).
                                                    "message":
                                                      "str"  # Optional. Human-readable helpful error
                                                      message to provide additional context for error
                                                      (ex: "u201cAuthentication method not
                                                      supported"u201d).
                                                }
                                            ],
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (e.g.,: "u201cCapability ID
                                              'foo' does not exist"u201d).
                                        }
                                    }
                                }
                            }
                        },
                        "uuid": "str",  # Optional. A unique identifier for the device.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                device_name=device_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        namespace_name: str,
        device_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_namespace_devices_update_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            device_name=device_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        device_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param device_name: The name of the device. Required.
        :type device_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "enabled": bool,  # Optional. Indicates if the resource and identity
                          are enabled or not. A disabled device cannot authenticate with Microsoft
                          Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "address": "str",  # Optional. The endpoint
                                      address & port. This can be either an IP address (e.g.,
                                      192.168.1.1) or a fully qualified domain name (FQDN, e.g.,
                                      server.example.com).
                                    "authentication": {
                                        "method": "str",  # Optional. Defines
                                          the method to authenticate the user of the client at the
                                          server. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # Optional. The name of the secret containing the
                                              password.
                                            "usernameSecretName": "str"
                                              # Optional. The name of the secret containing the
                                              username.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # Optional. The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx).
                                        }
                                    },
                                    "endpointType": "str",  # Optional. Type of
                                      connection endpoint.
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # Optional. The
                                          endpoint address to connect to.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # Optional. The
                                          endpoint address to connect to.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "operatingSystemVersion": "str"  # Optional. Device operating system
                          version.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "etag": "str",  # Optional. Resource Tag.
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "deviceTemplateId": "str",  # Optional. Device Template Id used to
                          create a device.
                        "discoveredDeviceRef": "str",  # Optional. Reference to a device.
                          Populated only if the device had been created from discovery flow. Discovered
                          device name must be provided.
                        "enabled": True,  # Optional. Default value is True. Indicates if the
                          resource and identity are enabled or not. A disabled device cannot
                          authenticate with Microsoft Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "authentication": {
                                        "method": "str",  # Defines the
                                          method to authenticate the user of the client at the server.
                                          Required. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # The name of the secret containing the password.
                                              Required.
                                            "usernameSecretName": "str"
                                              # The name of the secret containing the username.
                                              Required.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx). Required.
                                        }
                                    },
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. The Device ID provided by the
                          customer.
                        "identity": {
                            "principalId": "str",  # Optional. Principal id for the
                              device resource.
                            "tenantId": "str"  # Optional. Tenant id for the Microsoft
                              Entra ID tenant.
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "endpoints": {
                                "inbound": {
                                    "str": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code for classification of errors (ex: '400',
                                              '404', '500', etc.).
                                            "details": [
                                                {
                                                    "code":
                                                      "str",  # Optional. Multi-part error code for
                                                      classification and root causing of errors (ex:
                                                      400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                      identifier for the transaction to aid in
                                                      debugging.
                                                    "info":
                                                      "str",  # Optional. Human-readable helpful
                                                      detailed text context for debugging (ex:
                                                      "u201cThe following mechanisms are
                                                      supported..."u201d).
                                                    "message":
                                                      "str"  # Optional. Human-readable helpful error
                                                      message to provide additional context for error
                                                      (ex: "u201cAuthentication method not
                                                      supported"u201d).
                                                }
                                            ],
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (e.g.,: "u201cCapability ID
                                              'foo' does not exist"u201d).
                                        }
                                    }
                                }
                            }
                        },
                        "uuid": "str",  # Optional. A unique identifier for the device.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        device_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param device_name: The name of the device. Required.
        :type device_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "etag": "str",  # Optional. Resource Tag.
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "deviceTemplateId": "str",  # Optional. Device Template Id used to
                          create a device.
                        "discoveredDeviceRef": "str",  # Optional. Reference to a device.
                          Populated only if the device had been created from discovery flow. Discovered
                          device name must be provided.
                        "enabled": True,  # Optional. Default value is True. Indicates if the
                          resource and identity are enabled or not. A disabled device cannot
                          authenticate with Microsoft Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "authentication": {
                                        "method": "str",  # Defines the
                                          method to authenticate the user of the client at the server.
                                          Required. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # The name of the secret containing the password.
                                              Required.
                                            "usernameSecretName": "str"
                                              # The name of the secret containing the username.
                                              Required.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx). Required.
                                        }
                                    },
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. The Device ID provided by the
                          customer.
                        "identity": {
                            "principalId": "str",  # Optional. Principal id for the
                              device resource.
                            "tenantId": "str"  # Optional. Tenant id for the Microsoft
                              Entra ID tenant.
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "endpoints": {
                                "inbound": {
                                    "str": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code for classification of errors (ex: '400',
                                              '404', '500', etc.).
                                            "details": [
                                                {
                                                    "code":
                                                      "str",  # Optional. Multi-part error code for
                                                      classification and root causing of errors (ex:
                                                      400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                      identifier for the transaction to aid in
                                                      debugging.
                                                    "info":
                                                      "str",  # Optional. Human-readable helpful
                                                      detailed text context for debugging (ex:
                                                      "u201cThe following mechanisms are
                                                      supported..."u201d).
                                                    "message":
                                                      "str"  # Optional. Human-readable helpful error
                                                      message to provide additional context for error
                                                      (ex: "u201cAuthentication method not
                                                      supported"u201d).
                                                }
                                            ],
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (e.g.,: "u201cCapability ID
                                              'foo' does not exist"u201d).
                                        }
                                    }
                                }
                            }
                        },
                        "uuid": "str",  # Optional. A unique identifier for the device.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        device_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param device_name: The name of the device. Required.
        :type device_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "enabled": bool,  # Optional. Indicates if the resource and identity
                          are enabled or not. A disabled device cannot authenticate with Microsoft
                          Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "address": "str",  # Optional. The endpoint
                                      address & port. This can be either an IP address (e.g.,
                                      192.168.1.1) or a fully qualified domain name (FQDN, e.g.,
                                      server.example.com).
                                    "authentication": {
                                        "method": "str",  # Optional. Defines
                                          the method to authenticate the user of the client at the
                                          server. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # Optional. The name of the secret containing the
                                              password.
                                            "usernameSecretName": "str"
                                              # Optional. The name of the secret containing the
                                              username.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # Optional. The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx).
                                        }
                                    },
                                    "endpointType": "str",  # Optional. Type of
                                      connection endpoint.
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # Optional. The
                                          endpoint address to connect to.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # Optional. The
                                          endpoint address to connect to.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "operatingSystemVersion": "str"  # Optional. Device operating system
                          version.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "etag": "str",  # Optional. Resource Tag.
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes set by the customer.
                        },
                        "deviceGroupId": "str",  # Optional. The Microsoft Entra ID group the
                          device is a member of.
                        "deviceTemplateId": "str",  # Optional. Device Template Id used to
                          create a device.
                        "discoveredDeviceRef": "str",  # Optional. Reference to a device.
                          Populated only if the device had been created from discovery flow. Discovered
                          device name must be provided.
                        "enabled": True,  # Optional. Default value is True. Indicates if the
                          resource and identity are enabled or not. A disabled device cannot
                          authenticate with Microsoft Entra ID.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "authentication": {
                                        "method": "str",  # Defines the
                                          method to authenticate the user of the client at the server.
                                          Required. Known values are: "Anonymous", "Certificate", and
                                          "UsernamePassword".
                                        "usernamePasswordCredentials": {
                                            "passwordSecretName": "str",
                                              # The name of the secret containing the password.
                                              Required.
                                            "usernameSecretName": "str"
                                              # The name of the secret containing the username.
                                              Required.
                                        },
                                        "x509Credentials": {
                                            "certificateSecretName":
                                              "str"  # The name of the secret containing the
                                              certificate and private key (e.g. stored as .der/.pem or
                                              .der/.pfx). Required.
                                        }
                                    },
                                    "trustSettings": {
                                        "trustList": "str"  # Optional.
                                          Defines a secret reference for certificates to trust.
                                    },
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                },
                                "unassigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. The Device ID provided by the
                          customer.
                        "identity": {
                            "principalId": "str",  # Optional. Principal id for the
                              device resource.
                            "tenantId": "str"  # Optional. Tenant id for the Microsoft
                              Entra ID tenant.
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",  # Optional. A timestamp
                          (in UTC) that is updated each time the resource is modified.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "status": {
                            "config": {
                                "error": {
                                    "code": "str",  # Optional. Error code for
                                      classification of errors (ex: '400', '404', '500', etc.).
                                    "details": [
                                        {
                                            "code": "str",  # Optional.
                                              Multi-part error code for classification and root causing
                                              of errors (ex: 400.200.100.432).
                                            "correlationId": "str",  #
                                              Optional. Unique identifier for the transaction to aid in
                                              debugging.
                                            "info": "str",  # Optional.
                                              Human-readable helpful detailed text context for
                                              debugging (ex: "u201cThe following mechanisms are
                                              supported..."u201d).
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (ex: "u201cAuthentication
                                              method not supported"u201d).
                                        }
                                    ],
                                    "message": "str"  # Optional. Human-readable
                                      helpful error message to provide additional context for error
                                      (e.g.,: "u201cCapability ID 'foo' does not exist"u201d).
                                },
                                "lastTransitionTime": "2020-02-20 00:00:00",  #
                                  Optional. A read-only timestamp indicating the last time the
                                  configuration has been modified from the perspective of the current
                                  actual (edge) state of the CRD. Edge would be the only writer of this
                                  value and would sync back up to the cloud.
                                "version": 0  # Optional. A read-only incremental
                                  counter indicating the number of times the configuration has been
                                  modified from the perspective of the current actual (edge) state of
                                  the CRD. Edge would be the only writer of this value and would sync
                                  back up to the cloud. In steady state, this should equal version.
                            },
                            "endpoints": {
                                "inbound": {
                                    "str": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code for classification of errors (ex: '400',
                                              '404', '500', etc.).
                                            "details": [
                                                {
                                                    "code":
                                                      "str",  # Optional. Multi-part error code for
                                                      classification and root causing of errors (ex:
                                                      400.200.100.432).
                "correlationId": "str",  # Optional. Unique
                                                      identifier for the transaction to aid in
                                                      debugging.
                                                    "info":
                                                      "str",  # Optional. Human-readable helpful
                                                      detailed text context for debugging (ex:
                                                      "u201cThe following mechanisms are
                                                      supported..."u201d).
                                                    "message":
                                                      "str"  # Optional. Human-readable helpful error
                                                      message to provide additional context for error
                                                      (ex: "u201cAuthentication method not
                                                      supported"u201d).
                                                }
                                            ],
                                            "message": "str"  # Optional.
                                              Human-readable helpful error message to provide
                                              additional context for error (e.g.,: "u201cCapability ID
                                              'foo' does not exist"u201d).
                                        }
                                    }
                                }
                            }
                        },
                        "uuid": "str",  # Optional. A unique identifier for the device.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                device_name=device_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, namespace_name: str, device_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_namespace_devices_delete_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            device_name=device_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, namespace_name: str, device_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a NamespaceDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param device_name: The name of the device. Required.
        :type device_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                device_name=device_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class NamespaceDiscoveredAssetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`namespace_discovered_assets` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, namespace_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List NamespaceDiscoveredAsset resources by Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_namespace_discovered_assets_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    namespace_name=namespace_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, namespace_name: str, discovered_asset_name: str, **kwargs: Any) -> JSON:
        """Get a NamespaceDiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_asset_name: The name of the discovered asset. Required.
        :type discovered_asset_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_namespace_discovered_assets_get_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            discovered_asset_name=discovered_asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_asset_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_namespace_discovered_assets_create_or_replace_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            discovered_asset_name=discovered_asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_asset_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceDiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_asset_name: The name of the discovered asset. Required.
        :type discovered_asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_asset_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceDiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_asset_name: The name of the discovered asset. Required.
        :type discovered_asset_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_asset_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceDiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_asset_name: The name of the discovered asset. Required.
        :type discovered_asset_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                discovered_asset_name=discovered_asset_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_asset_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_namespace_discovered_assets_update_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            discovered_asset_name=discovered_asset_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_asset_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceDiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_asset_name: The name of the discovered asset. Required.
        :type discovered_asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "deviceRef": {
                            "deviceName": "str",  # Optional. Name of the device
                              resource.
                            "endpointName": "str"  # Optional. The name of endpoint to
                              use.
                        },
                        "discoveryId": "str",  # Optional. Identifier used to detect changes
                          in the asset.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_asset_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceDiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_asset_name: The name of the discovered asset. Required.
        :type discovered_asset_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_asset_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceDiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_asset_name: The name of the discovered asset. Required.
        :type discovered_asset_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "deviceRef": {
                            "deviceName": "str",  # Optional. Name of the device
                              resource.
                            "endpointName": "str"  # Optional. The name of endpoint to
                              use.
                        },
                        "discoveryId": "str",  # Optional. Identifier used to detect changes
                          in the asset.
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "deviceRef": {
                            "deviceName": "str",  # Name of the device resource.
                              Required.
                            "endpointName": "str"  # The name of endpoint to use.
                              Required.
                        },
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          asset. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "assetTypeRefs": [
                            "str"  # Optional. URIs or type definition IDs.
                        ],
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "datasets": [
                            {
                                "name": "str",  # Name of the dataset. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. UTC timestamp indicating when the
                                          data point was added or modified.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "dataSource": "str",  # Optional. Name of the data
                                  source within a dataset.
                                "datasetConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific properties that
                                  describes configuration for the specific dataset.
                                "destinations": [
                                    dataset_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the dataset was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "defaultDatasetsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all datasets. Each
                          dataset can have its own configuration that overrides the default settings
                          here.
                        "defaultDatasetsDestinations": [
                            dataset_destination
                        ],
                        "defaultEventsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all events. Each
                          event can have its own configuration that overrides the default settings
                          here.
                        "defaultEventsDestinations": [
                            event_destination
                        ],
                        "defaultManagementGroupsConfiguration": "str",  # Optional.
                          Stringified JSON that contains connector-specific default configuration for
                          all management groups. Each management group can have its own configuration
                          that overrides the default settings here.
                        "defaultStreamsConfiguration": "str",  # Optional. Stringified JSON
                          that contains connector-specific default configuration for all streams. Each
                          stream can have its own configuration that overrides the default settings
                          here.
                        "defaultStreamsDestinations": [
                            stream_destination
                        ],
                        "documentationUri": "str",  # Optional. Asset documentation
                          reference.
                        "events": [
                            {
                                "eventNotifier": "str",  # The address of the
                                  notifier of the event in the asset (e.g. URL) so that a client can
                                  access the event on the asset. Required.
                                "name": "str",  # The name of the event. Required.
                                "dataPoints": [
                                    {
                                        "dataSource": "str",  # The address
                                          of the source of the data in the asset (e.g. URL) so that a
                                          client can access the data source on the asset. Required.
                                        "name": "str",  # The name of the
                                          data point. Required.
                                        "dataPointConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the data point. For OPC UA, this could
                                          include configuration like, publishingInterval,
                                          samplingInterval, and queueSize.
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00"  # Optional. UTC timestamp indicating when the data
                                          point was added or modified.
                                    }
                                ],
                                "destinations": [
                                    event_destination
                                ],
                                "eventConfiguration": "str",  # Optional. Stringified
                                  JSON that contains connector-specific configuration for the event.
                                  For OPC UA, this could include configuration like,
                                  publishingInterval, samplingInterval, and queueSize.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  UTC timestamp indicating when the event was added or modified.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "hardwareRevision": "str",  # Optional. Asset hardware revision
                          number.
                        "managementGroups": [
                            {
                                "name": "str",  # Name of the management group.
                                  Required.
                                "actions": [
                                    {
                                        "name": "str",  # Name of the action.
                                          Required.
                                        "targetUri": "str",  # The target URI
                                          on which a client can invoke the specific action. Required.
                                        "actionConfiguration": "str",  #
                                          Optional. Stringified JSON that contains connector-specific
                                          configuration for the action.
                                        "actionType": "str",  # Optional. The
                                          type of the action. Known values are: "Call", "Read", and
                                          "Write".
                                        "lastUpdatedOn": "2020-02-20
                                          00:00:00",  # Optional. Timestamp (in UTC) indicating when
                                          the management action was added or modified.
                                        "timeoutInSeconds": 0,  # Optional.
                                          Response timeout for the action.
                                        "topic": "str",  # Optional. The MQTT
                                          topic path on which a client will receive the request for the
                                          action.
                                        "typeRef": "str"  # Optional. URI or
                                          type definition ID.
                                    }
                                ],
                                "defaultTimeoutInSeconds": 100,  # Optional. Default
                                  value is 100. Default response timeout for all actions that are part
                                  of the management group.
                                "defaultTopic": "str",  # Optional. Default MQTT
                                  topic path on which a client will receive the request for all actions
                                  that are part of the management group.
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the management group was added or
                                  modified.
                                "managementGroupConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the management group.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ],
                        "manufacturer": "str",  # Optional. Asset manufacturer.
                        "manufacturerUri": "str",  # Optional. Asset manufacturer URI.
                        "model": "str",  # Optional. Asset model.
                        "productCode": "str",  # Optional. Asset product code.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "serialNumber": "str",  # Optional. Asset serial number.
                        "softwareRevision": "str",  # Optional. Asset software revision
                          number.
                        "streams": [
                            {
                                "name": "str",  # Name of the stream definition.
                                  Required.
                                "destinations": [
                                    stream_destination
                                ],
                                "lastUpdatedOn": "2020-02-20 00:00:00",  # Optional.
                                  Timestamp (in UTC) indicating when the stream was added or modified.
                                "streamConfiguration": "str",  # Optional.
                                  Stringified JSON that contains connector-specific configuration for
                                  the specific stream.
                                "typeRef": "str"  # Optional. URI or type definition
                                  ID.
                            }
                        ]
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                discovered_asset_name=discovered_asset_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, namespace_name: str, discovered_asset_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_namespace_discovered_assets_delete_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            discovered_asset_name=discovered_asset_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, namespace_name: str, discovered_asset_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a NamespaceDiscoveredAsset.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_asset_name: The name of the discovered asset. Required.
        :type discovered_asset_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                discovered_asset_name=discovered_asset_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class NamespaceDiscoveredDevicesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`namespace_discovered_devices` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, namespace_name: str, **kwargs: Any) -> Iterable[JSON]:
        """List NamespaceDiscoveredDevice resources by Namespace.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          discovered device. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_namespace_discovered_devices_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    namespace_name=namespace_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, namespace_name: str, discovered_device_name: str, **kwargs: Any) -> JSON:
        """Get a NamespaceDiscoveredDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_device_name: The name of the discovered device. Required.
        :type discovered_device_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          discovered device. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_namespace_discovered_devices_get_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            discovered_device_name=discovered_device_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_or_replace_initial(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_device_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_namespace_discovered_devices_create_or_replace_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            discovered_device_name=discovered_device_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_device_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceDiscoveredDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_device_name: The name of the discovered device. Required.
        :type discovered_device_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          discovered device. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          discovered device. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_device_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceDiscoveredDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_device_name: The name of the discovered device. Required.
        :type discovered_device_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          discovered device. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_create_or_replace(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_device_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a NamespaceDiscoveredDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_device_name: The name of the discovered device. Required.
        :type discovered_device_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          discovered device. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          discovered device. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                discovered_device_name=discovered_device_name,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_device_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[JSON]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(properties, (IOBase, bytes)):
            _content = properties
        else:
            _json = properties

        request = build_namespace_discovered_devices_update_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            discovered_device_name=discovered_device_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_device_name: str,
        properties: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceDiscoveredDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_device_name: The name of the discovered device. Required.
        :type discovered_device_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "discoveryId": "str",  # Optional. Identifier used to detect changes
                          in the discovered device.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "address": "str",  # Optional. The endpoint
                                      address & port. This can be either an IP address (e.g.,
                                      192.168.1.1) or a fully qualified domain name (FQDN, e.g.,
                                      server.example.com).
                                    "endpointType": "str",  # Optional. Type of
                                      connection endpoint.
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # Optional. The
                                          endpoint address to connect to.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          discovered device. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_device_name: str,
        properties: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceDiscoveredDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_device_name: The name of the discovered device. Required.
        :type discovered_device_name: str
        :param properties: The resource properties to be updated. Required.
        :type properties: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          discovered device. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def begin_update(
        self,
        resource_group_name: str,
        namespace_name: str,
        discovered_device_name: str,
        properties: Union[JSON, IO],
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Update a NamespaceDiscoveredDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_device_name: The name of the discovered device. Required.
        :type discovered_device_name: str
        :param properties: The resource properties to be updated. Is either a JSON type or a IO type.
         Required.
        :type properties: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                properties = {
                    "properties": {
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "discoveryId": "str",  # Optional. Identifier used to detect changes
                          in the discovered device.
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "address": "str",  # Optional. The endpoint
                                      address & port. This can be either an IP address (e.g.,
                                      192.168.1.1) or a fully qualified domain name (FQDN, e.g.,
                                      server.example.com).
                                    "endpointType": "str",  # Optional. Type of
                                      connection endpoint.
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # Optional. The
                                          endpoint address to connect to.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "version": 0  # Optional. An integer that is incremented each time
                          the resource is modified.
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "extendedLocation": {
                        "name": "str",  # The extended location name. Required.
                        "type": "str"  # The extended location type. Required.
                    },
                    "location": "str",  # The geo-location where the resource lives. Required.
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "discoveryId": "str",  # Identifier used to detect changes in the
                          discovered device. Required.
                        "version": 0,  # An integer that is incremented each time the
                          resource is modified. Required.
                        "attributes": {
                            "str": {}  # Optional. A set of key-value pairs that contain
                              custom attributes.
                        },
                        "endpoints": {
                            "inbound": {
                                "str": {
                                    "address": "str",  # The endpoint address &
                                      port. This can be either an IP address (e.g., 192.168.1.1) or a
                                      fully qualified domain name (FQDN, e.g., server.example.com).
                                      Required.
                                    "endpointType": "str",  # Type of connection
                                      endpoint. Required.
                                    "additionalConfiguration": "str",  #
                                      Optional. Stringified JSON that contains connectivity type
                                      specific further configuration (e.g., OPC UA, ONVIF).
                                    "lastUpdatedOn": "2020-02-20 00:00:00",  #
                                      Optional. The timestamp (in UTC) when the endpoint was
                                      discovered.
                                    "supportedAuthenticationMethods": [
                                        "str"  # Optional. List of supported
                                          authentication methods supported by device for Inbound
                                          connections.
                                    ],
                                    "version": "str"  # Optional. Version
                                      associated with device endpoint.
                                }
                            },
                            "outbound": {
                                "assigned": {
                                    "str": {
                                        "address": "str",  # The endpoint
                                          address to connect to. Required.
                                        "endpointType": "str"  # Optional.
                                          Type of connection used for the messaging endpoint.
                                    }
                                }
                            }
                        },
                        "externalDeviceId": "str",  # Optional. A device ID that represents
                          the device in a system external to Azure. Unique within scope of an Azure
                          tenant.
                        "manufacturer": "str",  # Optional. Device manufacturer.
                        "model": "str",  # Optional. Device model.
                        "operatingSystem": "str",  # Optional. Device operating system name.
                        "operatingSystemVersion": "str",  # Optional. Device operating system
                          version.
                        "provisioningState": "str"  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                discovered_device_name=discovered_device_name,
                properties=properties,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, namespace_name: str, discovered_device_name: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_namespace_discovered_devices_delete_request(
            resource_group_name=resource_group_name,
            namespace_name=namespace_name,
            discovered_device_name=discovered_device_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)

    @distributed_trace
    def begin_delete(
        self, resource_group_name: str, namespace_name: str, discovered_device_name: str, **kwargs: Any
    ) -> LROPoller[None]:
        """Delete a NamespaceDiscoveredDevice.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param namespace_name: The name of the namespace. Required.
        :type namespace_name: str
        :param discovered_device_name: The name of the discovered device. Required.
        :type discovered_device_name: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(  # type: ignore
                resource_group_name=resource_group_name,
                namespace_name=namespace_name,
                discovered_device_name=discovered_device_name,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class SchemasOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`schemas` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_schema_registry(
        self, resource_group_name: str, schema_registry_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        """List Schema resources by SchemaRegistry.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_schemas_list_by_schema_registry_request(
                    resource_group_name=resource_group_name,
                    schema_registry_name=schema_registry_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, resource_group_name: str, schema_registry_name: str, schema_name: str, **kwargs: Any) -> JSON:
        """Get a Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_schemas_get_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Create a Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "format": "str",  # Format of the schema. Required. Known values are:
                          "JsonSchema/draft-07" and "Delta/1.0".
                        "schemaType": "str",  # Type of the schema. Required. "MessageSchema"
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "displayName": "str",  # Optional. Human-readable display name.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "tags": {
                            "str": "str"  # Optional. Schema tags.
                        },
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_schemas_create_or_replace_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, resource_group_name: str, schema_registry_name: str, schema_name: str, **kwargs: Any
    ) -> None:
        """Delete a Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_schemas_delete_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class SchemaVersionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.deviceregistry.MicrosoftDeviceRegistryManagementService`'s
        :attr:`schema_versions` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_schema(
        self, resource_group_name: str, schema_registry_name: str, schema_name: str, **kwargs: Any
    ) -> Iterable[JSON]:
        """List SchemaVersion resources by Schema.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_schema_versions_list_by_schema_request(
                    resource_group_name=resource_group_name,
                    schema_registry_name=schema_registry_name,
                    schema_name=schema_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                request.url = self._client.format_url(request.url)

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        schema_version_name: str,
        **kwargs: Any
    ) -> JSON:
        """Get a SchemaVersion.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param schema_version_name: Schema version name parameter. Required.
        :type schema_version_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        request = build_schema_versions_get_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            schema_version_name=schema_version_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        schema_version_name: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a SchemaVersion.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param schema_version_name: Schema version name parameter. Required.
        :type schema_version_name: str
        :param resource: Resource create parameters. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @overload
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        schema_version_name: str,
        resource: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a SchemaVersion.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param schema_version_name: Schema version name parameter. Required.
        :type schema_version_name: str
        :param resource: Resource create parameters. Required.
        :type resource: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """

    @distributed_trace
    def create_or_replace(
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        schema_version_name: str,
        resource: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Create a SchemaVersion.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param schema_version_name: Schema version name parameter. Required.
        :type schema_version_name: str
        :param resource: Resource create parameters. Is either a JSON type or a IO type. Required.
        :type resource: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }

                # response body for status code(s): 200, 201
                response == {
                    "id": "str",  # Optional. Fully qualified resource ID for the resource. E.g.
                      "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
                    "name": "str",  # Optional. The name of the resource.
                    "properties": {
                        "schemaContent": "str",  # Schema content. Required.
                        "description": "str",  # Optional. Human-readable description of the
                          schema.
                        "hash": "str",  # Optional. Hash of the schema content.
                        "provisioningState": "str",  # Optional. Provisioning state of the
                          resource. Known values are: "Succeeded", "Failed", "Canceled", "Accepted",
                          and "Deleting".
                        "uuid": "str"  # Optional. Globally unique, immutable, non-reusable
                          ID.
                    },
                    "systemData": {
                        "createdAt": "2020-02-20 00:00:00",  # Optional. The timestamp of
                          resource creation (UTC).
                        "createdBy": "str",  # Optional. The identity that created the
                          resource.
                        "createdByType": "str",  # Optional. The type of identity that
                          created the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                        "lastModifiedAt": "2020-02-20 00:00:00",  # Optional. The timestamp
                          of resource last modification (UTC).
                        "lastModifiedBy": "str",  # Optional. The identity that last modified
                          the resource.
                        "lastModifiedByType": "str"  # Optional. The type of identity that
                          last modified the resource. Known values are: "User", "Application",
                          "ManagedIdentity", and "Key".
                    },
                    "type": "str"  # Optional. The type of the resource. E.g.
                      "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _json = resource

        request = build_schema_versions_create_or_replace_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            schema_version_name=schema_version_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self,
        resource_group_name: str,
        schema_registry_name: str,
        schema_name: str,
        schema_version_name: str,
        **kwargs: Any
    ) -> None:
        """Delete a SchemaVersion.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param schema_registry_name: Schema registry name parameter. Required.
        :type schema_registry_name: str
        :param schema_name: Schema name parameter. Required.
        :type schema_name: str
        :param schema_version_name: Schema version name parameter. Required.
        :type schema_version_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        request = build_schema_versions_delete_request(
            resource_group_name=resource_group_name,
            schema_registry_name=schema_registry_name,
            schema_name=schema_name,
            schema_version_name=schema_version_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
